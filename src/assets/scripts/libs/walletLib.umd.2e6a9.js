(function (root) {
  var exports = undefined,
    module = undefined,
    require = undefined;
  var define = undefined;
  var self = root,
    window = root,
    global = root,
    globalThis = root;
  (function () {
    (function (Tt, kt) {
      typeof exports == "object" && typeof module != "undefined" ? kt(exports) : typeof define == "function" && define.amd ? define(["exports"], kt) : (Tt = typeof globalThis != "undefined" ? globalThis : Tt || self, kt(Tt.walletLib = {}));
    })(this, function (Tt) {
      "use strict";

      var U2 = Object.defineProperty;
      var Gb = Tt => {
        throw TypeError(Tt);
      };
      var F2 = (Tt, kt, un) => kt in Tt ? U2(Tt, kt, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: un
      }) : Tt[kt] = un;
      var ce = (Tt, kt, un) => F2(Tt, typeof kt != "symbol" ? kt + "" : kt, un),
        Gd = (Tt, kt, un) => kt.has(Tt) || Gb("Cannot " + un);
      var k = (Tt, kt, un) => (Gd(Tt, kt, "read from private field"), un ? un.call(Tt) : kt.get(Tt)),
        de = (Tt, kt, un) => kt.has(Tt) ? Gb("Cannot add the same private member more than once") : kt instanceof WeakSet ? kt.add(Tt) : kt.set(Tt, un),
        z = (Tt, kt, un, pn) => (Gd(Tt, kt, "write to private field"), pn ? pn.call(Tt, un) : kt.set(Tt, un), un),
        _e = (Tt, kt, un) => (Gd(Tt, kt, "access private method"), un);
      var Dl = (Tt, kt, un, pn) => ({
        set _(Ge) {
          z(Tt, kt, Ge, un);
        },
        get _() {
          return k(Tt, kt, pn);
        }
      });
      var Ba, ks, eo, ka, Ma, Pr, bi, Ka, La, Cn, cr, wi, Ms, Ks, Ls, qr, Ir, to, Us, Pl, ml, bl, wl, lr, Ua, Fs, Br, Ft, qn, Kt, oa, Pi, Vd, zd, $d, Qd, Fa, xi, Hs, ja, kf, Yn, ur, js, Ws, ro, Xs, Yd, Vb, Wa, Jr, Xa, qs, _i, Gs, Mr, qa, Ja, Ga, Va, za, $a, Qa, Ya, Za, ec, tc, Vs, io, Gr, oo, nc, rc, Mf, xl, Ci, ic, Of, zb, Pn, Kr, _l, Zd, oc, Kf, so, Ec, zr, $r, Qr, Kn, Yr, Lf, Uf, Oi, El, ao, sc, Cl, Ol, qb, co, $s, lo, Cc, Nf, $b, Rl, Nl, cc, lc, uo, Ai, br, fo, Zr, fc, Ff, Qs, Ys, ho, dc, Ri, Sf, hc, Ni, pc, gc, po, wr, Tf, Qb, Ln, go, Un, vc, fr, Zs, vo, Si, Sl, xr, yc, mc, gt, dr, eh, th, Il, nh, Bl, Hf, Jn, ei, ea, yo, ta, bc, mo, rh, ih, na, ra, wc, Ti, ti, Lr, _r, Zn, Tl, oh, bo, xc, _c;
      const kt = "6.15.0";
      function un(n, e, t) {
        const r = e.split("|").map(a => a.trim());
        for (let a = 0; a < r.length; a++) switch (e) {
          case "any":
            return;
          case "bigint":
          case "boolean":
          case "number":
          case "string":
            if (typeof n === e) return;
        }
        const i = new Error(`invalid value for type ${e}`);
        throw i.code = "INVALID_ARGUMENT", i.argument = `value.${t}`, i.value = n, i;
      }
      async function pn(n) {
        const e = Object.keys(n);
        return (await Promise.all(e.map(r => Promise.resolve(n[r])))).reduce((r, i, a) => (r[e[a]] = i, r), {});
      }
      function Ge(n, e, t) {
        for (let r in e) {
          let i = e[r];
          const a = t ? t[r] : null;
          a && un(i, a, r), Object.defineProperty(n, r, {
            enumerable: !0,
            value: i,
            writable: !1
          });
        }
      }
      function sa(n, e) {
        if (n == null) return "null";
        if (e == null && (e = new Set()), typeof n == "object") {
          if (e.has(n)) return "[Circular]";
          e.add(n);
        }
        if (Array.isArray(n)) return "[ " + n.map(t => sa(t, e)).join(", ") + " ]";
        if (n instanceof Uint8Array) {
          const t = "0123456789abcdef";
          let r = "0x";
          for (let i = 0; i < n.length; i++) r += t[n[i] >> 4], r += t[n[i] & 15];
          return r;
        }
        if (typeof n == "object" && typeof n.toJSON == "function") return sa(n.toJSON(), e);
        switch (typeof n) {
          case "boolean":
          case "number":
          case "symbol":
            return n.toString();
          case "bigint":
            return BigInt(n).toString();
          case "string":
            return JSON.stringify(n);
          case "object":
            {
              const t = Object.keys(n);
              return t.sort(), "{ " + t.map(r => `${sa(r, e)}: ${sa(n[r], e)}`).join(", ") + " }";
            }
        }
        return "[ COULD NOT SERIALIZE ]";
      }
      function Nn(n, e) {
        return n && n.code === e;
      }
      function jf(n) {
        return Nn(n, "CALL_EXCEPTION");
      }
      function Vt(n, e, t) {
        let r = n;
        {
          const a = [];
          if (t) {
            if ("message" in t || "code" in t || "name" in t) throw new Error(`value will overwrite populated values: ${sa(t)}`);
            for (const l in t) {
              if (l === "shortMessage") continue;
              const s = t[l];
              a.push(l + "=" + sa(s));
            }
          }
          a.push(`code=${e}`), a.push(`version=${kt}`), a.length && (n += " (" + a.join(", ") + ")");
        }
        let i;
        switch (e) {
          case "INVALID_ARGUMENT":
            i = new TypeError(n);
            break;
          case "NUMERIC_FAULT":
          case "BUFFER_OVERRUN":
            i = new RangeError(n);
            break;
          default:
            i = new Error(n);
        }
        return Ge(i, {
          code: e
        }), t && Object.assign(i, t), i.shortMessage == null && Ge(i, {
          shortMessage: r
        }), i;
      }
      function be(n, e, t, r) {
        if (!n) throw Vt(e, t, r);
      }
      function re(n, e, t, r) {
        be(n, e, "INVALID_ARGUMENT", {
          argument: t,
          value: r
        });
      }
      function ah(n, e, t) {
        t == null && (t = ""), t && (t = ": " + t), be(n >= e, "missing argument" + t, "MISSING_ARGUMENT", {
          count: n,
          expectedCount: e
        }), be(n <= e, "too many arguments" + t, "UNEXPECTED_ARGUMENT", {
          count: n,
          expectedCount: e
        });
      }
      ["NFD", "NFC", "NFKD", "NFKC"].reduce((n, e) => {
        try {
          if ("test".normalize(e) !== "test") throw new Error("bad");
          if (e === "NFD" && "é".normalize("NFD") !== "é") throw new Error("broken");
          n.push(e);
        } catch {}
        return n;
      }, []);
      function Oc(n, e, t) {
        if (t == null && (t = ""), n !== e) {
          let r = t,
            i = "new";
          t && (r += ".", i += " " + t), be(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
            operation: i
          });
        }
      }
      function ch(n, e, t) {
        if (n instanceof Uint8Array) return t ? new Uint8Array(n) : n;
        if (typeof n == "string" && n.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
          const r = new Uint8Array((n.length - 2) / 2);
          let i = 2;
          for (let a = 0; a < r.length; a++) r[a] = parseInt(n.substring(i, i + 2), 16), i += 2;
          return r;
        }
        re(!1, "invalid BytesLike value", e || "value", n);
      }
      function ft(n, e) {
        return ch(n, e, !1);
      }
      function Fn(n, e) {
        return ch(n, e, !0);
      }
      function Xt(n, e) {
        return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && n.length !== 2 + 2 * e || e === !0 && n.length % 2 !== 0);
      }
      function Wf(n) {
        return Xt(n, !0) || n instanceof Uint8Array;
      }
      const lh = "0123456789abcdef";
      function Se(n) {
        const e = ft(n);
        let t = "0x";
        for (let r = 0; r < e.length; r++) {
          const i = e[r];
          t += lh[(i & 240) >> 4] + lh[i & 15];
        }
        return t;
      }
      function sn(n) {
        return "0x" + n.map(e => Se(e).substring(2)).join("");
      }
      function aa(n) {
        return Xt(n, !0) ? (n.length - 2) / 2 : ft(n).length;
      }
      function an(n, e, t) {
        const r = ft(n);
        return t != null && t > r.length && be(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
          buffer: r,
          length: r.length,
          offset: t
        }), Se(r.slice(e == null ? 0 : e, t == null ? r.length : t));
      }
      function uh(n, e, t) {
        const r = ft(n);
        be(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
          buffer: new Uint8Array(r),
          length: e,
          offset: e + 1
        });
        const i = new Uint8Array(e);
        return i.fill(0), t ? i.set(r, e - r.length) : i.set(r, 0), Se(i);
      }
      function ri(n, e) {
        return uh(n, e, !0);
      }
      function Yb(n, e) {
        return uh(n, e, !1);
      }
      const kl = BigInt(0),
        Er = BigInt(1),
        ca = 9007199254740991;
      function Ml(n, e) {
        const t = Kl(n, "value"),
          r = BigInt(ct(e, "width"));
        if (be(t >> r === kl, "overflow", "NUMERIC_FAULT", {
          operation: "fromTwos",
          fault: "overflow",
          value: n
        }), t >> r - Er) {
          const i = (Er << r) - Er;
          return -((~t & i) + Er);
        }
        return t;
      }
      function fh(n, e) {
        let t = Le(n, "value");
        const r = BigInt(ct(e, "width")),
          i = Er << r - Er;
        if (t < kl) {
          t = -t, be(t <= i, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: n
          });
          const a = (Er << r) - Er;
          return (~t & a) + Er;
        } else be(t < i, "too high", "NUMERIC_FAULT", {
          operation: "toTwos",
          fault: "overflow",
          value: n
        });
        return t;
      }
      function wo(n, e) {
        const t = Kl(n, "value"),
          r = BigInt(ct(e, "bits"));
        return t & (Er << r) - Er;
      }
      function Le(n, e) {
        switch (typeof n) {
          case "bigint":
            return n;
          case "number":
            return re(Number.isInteger(n), "underflow", e || "value", n), re(n >= -ca && n <= ca, "overflow", e || "value", n), BigInt(n);
          case "string":
            try {
              if (n === "") throw new Error("empty string");
              return n[0] === "-" && n[1] !== "-" ? -BigInt(n.substring(1)) : BigInt(n);
            } catch (t) {
              re(!1, `invalid BigNumberish string: ${t.message}`, e || "value", n);
            }
        }
        re(!1, "invalid BigNumberish value", e || "value", n);
      }
      function Kl(n, e) {
        const t = Le(n, e);
        return be(t >= kl, "unsigned value cannot be negative", "NUMERIC_FAULT", {
          fault: "overflow",
          operation: "getUint",
          value: n
        }), t;
      }
      const dh = "0123456789abcdef";
      function Ll(n) {
        if (n instanceof Uint8Array) {
          let e = "0x0";
          for (const t of n) e += dh[t >> 4], e += dh[t & 15];
          return BigInt(e);
        }
        return Le(n);
      }
      function ct(n, e) {
        switch (typeof n) {
          case "bigint":
            return re(n >= -ca && n <= ca, "overflow", e || "value", n), Number(n);
          case "number":
            return re(Number.isInteger(n), "underflow", e || "value", n), re(n >= -ca && n <= ca, "overflow", e || "value", n), n;
          case "string":
            try {
              if (n === "") throw new Error("empty string");
              return ct(BigInt(n), e);
            } catch (t) {
              re(!1, `invalid numeric string: ${t.message}`, e || "value", n);
            }
        }
        re(!1, "invalid numeric value", e || "value", n);
      }
      function Zb(n) {
        return ct(Ll(n));
      }
      function Ii(n, e) {
        let r = Kl(n, "value").toString(16);
        if (e == null) r.length % 2 && (r = "0" + r);else {
          const i = ct(e, "width");
          for (be(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: n
          }); r.length < i * 2;) r = "0" + r;
        }
        return "0x" + r;
      }
      function wn(n) {
        const e = Kl(n, "value");
        if (e === kl) return new Uint8Array([]);
        let t = e.toString(16);
        t.length % 2 && (t = "0" + t);
        const r = new Uint8Array(t.length / 2);
        for (let i = 0; i < r.length; i++) {
          const a = i * 2;
          r[i] = parseInt(t.substring(a, a + 2), 16);
        }
        return r;
      }
      function Cr(n) {
        let e = Se(Wf(n) ? n : wn(n)).substring(2);
        for (; e.startsWith("0");) e = e.substring(1);
        return e === "" && (e = "0"), "0x" + e;
      }
      const hh = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      BigInt(0);
      const ph = BigInt(58);
      function e1(n) {
        const e = ft(n);
        let t = Ll(e),
          r = "";
        for (; t;) r = hh[Number(t % ph)] + r, t /= ph;
        for (let i = 0; i < e.length && !e[i]; i++) r = hh[0] + r;
        return r;
      }
      function t1(n) {
        n = atob(n);
        const e = new Uint8Array(n.length);
        for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
        return ft(e);
      }
      function n1(n) {
        const e = ft(n);
        let t = "";
        for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
        return btoa(t);
      }
      class gh {
        constructor(e, t, r) {
          ce(this, "filter");
          ce(this, "emitter");
          de(this, Ba);
          z(this, Ba, t), Ge(this, {
            emitter: e,
            filter: r
          });
        }
        async removeListener() {
          k(this, Ba) != null && (await this.emitter.off(this.filter, k(this, Ba)));
        }
      }
      Ba = new WeakMap();
      function r1(n, e, t, r, i) {
        re(!1, `invalid codepoint at offset ${e}; ${n}`, "bytes", t);
      }
      function vh(n, e, t, r, i) {
        if (n === "BAD_PREFIX" || n === "UNEXPECTED_CONTINUE") {
          let a = 0;
          for (let l = e + 1; l < t.length && t[l] >> 6 === 2; l++) a++;
          return a;
        }
        return n === "OVERRUN" ? t.length - e - 1 : 0;
      }
      function i1(n, e, t, r, i) {
        return n === "OVERLONG" ? (re(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), r.push(i), 0) : (r.push(65533), vh(n, e, t));
      }
      const o1 = Object.freeze({
        error: r1,
        ignore: vh,
        replace: i1
      });
      function s1(n, e) {
        e == null && (e = o1.error);
        const t = ft(n, "bytes"),
          r = [];
        let i = 0;
        for (; i < t.length;) {
          const a = t[i++];
          if (a >> 7 === 0) {
            r.push(a);
            continue;
          }
          let l = null,
            s = null;
          if ((a & 224) === 192) l = 1, s = 127;else if ((a & 240) === 224) l = 2, s = 2047;else if ((a & 248) === 240) l = 3, s = 65535;else {
            (a & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, t, r) : i += e("BAD_PREFIX", i - 1, t, r);
            continue;
          }
          if (i - 1 + l >= t.length) {
            i += e("OVERRUN", i - 1, t, r);
            continue;
          }
          let o = a & (1 << 8 - l - 1) - 1;
          for (let c = 0; c < l; c++) {
            let u = t[i];
            if ((u & 192) != 128) {
              i += e("MISSING_CONTINUE", i, t, r), o = null;
              break;
            }
            o = o << 6 | u & 63, i++;
          }
          if (o !== null) {
            if (o > 1114111) {
              i += e("OUT_OF_RANGE", i - 1 - l, t, r, o);
              continue;
            }
            if (o >= 55296 && o <= 57343) {
              i += e("UTF16_SURROGATE", i - 1 - l, t, r, o);
              continue;
            }
            if (o <= s) {
              i += e("OVERLONG", i - 1 - l, t, r, o);
              continue;
            }
            r.push(o);
          }
        }
        return r;
      }
      function ii(n, e) {
        re(typeof n == "string", "invalid string value", "str", n);
        let t = [];
        for (let r = 0; r < n.length; r++) {
          const i = n.charCodeAt(r);
          if (i < 128) t.push(i);else if (i < 2048) t.push(i >> 6 | 192), t.push(i & 63 | 128);else if ((i & 64512) == 55296) {
            r++;
            const a = n.charCodeAt(r);
            re(r < n.length && (a & 64512) === 56320, "invalid surrogate pair", "str", n);
            const l = 65536 + ((i & 1023) << 10) + (a & 1023);
            t.push(l >> 18 | 240), t.push(l >> 12 & 63 | 128), t.push(l >> 6 & 63 | 128), t.push(l & 63 | 128);
          } else t.push(i >> 12 | 224), t.push(i >> 6 & 63 | 128), t.push(i & 63 | 128);
        }
        return new Uint8Array(t);
      }
      function a1(n) {
        return n.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
      }
      function Ul(n, e) {
        return a1(s1(n, e));
      }
      function yh(n) {
        async function e(t, r) {
          be(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
          const i = t.url.split(":")[0].toLowerCase();
          be(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
            info: {
              protocol: i
            },
            operation: "request"
          }), be(i === "https" || !t.credentials || t.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
          });
          let a = null;
          const l = new AbortController(),
            s = setTimeout(() => {
              a = Vt("request timeout", "TIMEOUT"), l.abort();
            }, t.timeout);
          r && r.addListener(() => {
            a = Vt("request cancelled", "CANCELLED"), l.abort();
          });
          const o = Object.assign({}, n, {
            method: t.method,
            headers: new Headers(Array.from(t)),
            body: t.body || void 0,
            signal: l.signal
          });
          let c;
          try {
            c = await fetch(t.url, o);
          } catch (p) {
            throw clearTimeout(s), a || p;
          }
          clearTimeout(s);
          const u = {};
          c.headers.forEach((p, v) => {
            u[v.toLowerCase()] = p;
          });
          const f = await c.arrayBuffer(),
            d = f == null ? null : new Uint8Array(f);
          return {
            statusCode: c.status,
            statusMessage: c.statusText,
            headers: u,
            body: d
          };
        }
        return e;
      }
      const c1 = 12,
        l1 = 250;
      let mh = yh();
      const u1 = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
        f1 = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
      let Xf = !1;
      async function bh(n, e) {
        try {
          const t = n.match(u1);
          if (!t) throw new Error("invalid data");
          return new ki(200, "OK", {
            "content-type": t[1] || "text/plain"
          }, t[2] ? t1(t[3]) : h1(t[3]));
        } catch {
          return new ki(599, "BAD REQUEST (invalid data: URI)", {}, null, new Bi(n));
        }
      }
      function wh(n) {
        async function e(t, r) {
          try {
            const i = t.match(f1);
            if (!i) throw new Error("invalid link");
            return new Bi(`${n}${i[2]}`);
          } catch {
            return new ki(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Bi(t));
          }
        }
        return e;
      }
      const Fl = {
          data: bh,
          ipfs: wh("https://gateway.ipfs.io/ipfs/")
        },
        xh = new WeakMap();
      class d1 {
        constructor(e) {
          de(this, ks);
          de(this, eo);
          z(this, ks, []), z(this, eo, !1), xh.set(e, () => {
            if (!k(this, eo)) {
              z(this, eo, !0);
              for (const t of k(this, ks)) setTimeout(() => {
                t();
              }, 0);
              z(this, ks, []);
            }
          });
        }
        addListener(e) {
          be(!k(this, eo), "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
          }), k(this, ks).push(e);
        }
        get cancelled() {
          return k(this, eo);
        }
        checkSignal() {
          be(!this.cancelled, "cancelled", "CANCELLED", {});
        }
      }
      ks = new WeakMap(), eo = new WeakMap();
      function Hl(n) {
        if (n == null) throw new Error("missing signal; should not happen");
        return n.checkSignal(), n;
      }
      const Cf = class Cf {
        constructor(e) {
          de(this, Us);
          de(this, ka);
          de(this, Ma);
          de(this, Pr);
          de(this, bi);
          de(this, Ka);
          de(this, La);
          de(this, Cn);
          de(this, cr);
          de(this, wi);
          de(this, Ms);
          de(this, Ks);
          de(this, Ls);
          de(this, qr);
          de(this, Ir);
          de(this, to);
          z(this, La, String(e)), z(this, ka, !1), z(this, Ma, !0), z(this, Pr, {}), z(this, bi, ""), z(this, Ka, 3e5), z(this, Ir, {
            slotInterval: l1,
            maxAttempts: c1
          }), z(this, to, null);
        }
        get url() {
          return k(this, La);
        }
        set url(e) {
          z(this, La, String(e));
        }
        get body() {
          return k(this, Cn) == null ? null : new Uint8Array(k(this, Cn));
        }
        set body(e) {
          if (e == null) z(this, Cn, void 0), z(this, cr, void 0);else if (typeof e == "string") z(this, Cn, ii(e)), z(this, cr, "text/plain");else if (e instanceof Uint8Array) z(this, Cn, e), z(this, cr, "application/octet-stream");else if (typeof e == "object") z(this, Cn, ii(JSON.stringify(e))), z(this, cr, "application/json");else throw new Error("invalid body");
        }
        hasBody() {
          return k(this, Cn) != null;
        }
        get method() {
          return k(this, bi) ? k(this, bi) : this.hasBody() ? "POST" : "GET";
        }
        set method(e) {
          e == null && (e = ""), z(this, bi, String(e).toUpperCase());
        }
        get headers() {
          const e = Object.assign({}, k(this, Pr));
          return k(this, wi) && (e.authorization = `Basic ${n1(ii(k(this, wi)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && k(this, cr) && (e["content-type"] = k(this, cr)), this.body && (e["content-length"] = String(this.body.length)), e;
        }
        getHeader(e) {
          return this.headers[e.toLowerCase()];
        }
        setHeader(e, t) {
          k(this, Pr)[String(e).toLowerCase()] = String(t);
        }
        clearHeaders() {
          z(this, Pr, {});
        }
        [Symbol.iterator]() {
          const e = this.headers,
            t = Object.keys(e);
          let r = 0;
          return {
            next: () => {
              if (r < t.length) {
                const i = t[r++];
                return {
                  value: [i, e[i]],
                  done: !1
                };
              }
              return {
                value: void 0,
                done: !0
              };
            }
          };
        }
        get credentials() {
          return k(this, wi) || null;
        }
        setCredentials(e, t) {
          re(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), z(this, wi, `${e}:${t}`);
        }
        get allowGzip() {
          return k(this, Ma);
        }
        set allowGzip(e) {
          z(this, Ma, !!e);
        }
        get allowInsecureAuthentication() {
          return !!k(this, ka);
        }
        set allowInsecureAuthentication(e) {
          z(this, ka, !!e);
        }
        get timeout() {
          return k(this, Ka);
        }
        set timeout(e) {
          re(e >= 0, "timeout must be non-zero", "timeout", e), z(this, Ka, e);
        }
        get preflightFunc() {
          return k(this, Ms) || null;
        }
        set preflightFunc(e) {
          z(this, Ms, e);
        }
        get processFunc() {
          return k(this, Ks) || null;
        }
        set processFunc(e) {
          z(this, Ks, e);
        }
        get retryFunc() {
          return k(this, Ls) || null;
        }
        set retryFunc(e) {
          z(this, Ls, e);
        }
        get getUrlFunc() {
          return k(this, to) || mh;
        }
        set getUrlFunc(e) {
          z(this, to, e);
        }
        toString() {
          return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${k(this, Cn) ? Se(k(this, Cn)) : "null"}>`;
        }
        setThrottleParams(e) {
          e.slotInterval != null && (k(this, Ir).slotInterval = e.slotInterval), e.maxAttempts != null && (k(this, Ir).maxAttempts = e.maxAttempts);
        }
        send() {
          return be(k(this, qr) == null, "request already sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.send"
          }), z(this, qr, new d1(this)), _e(this, Us, Pl).call(this, 0, _h() + this.timeout, 0, this, new ki(0, "", {}, null, this));
        }
        cancel() {
          be(k(this, qr) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.cancel"
          });
          const e = xh.get(this);
          if (!e) throw new Error("missing signal; should not happen");
          e();
        }
        redirect(e) {
          const t = this.url.split(":")[0].toLowerCase(),
            r = e.split(":")[0].toLowerCase();
          be(this.method === "GET" && (t !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
          });
          const i = new Cf(e);
          return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, z(i, Pr, Object.assign({}, k(this, Pr))), k(this, Cn) && z(i, Cn, new Uint8Array(k(this, Cn))), z(i, cr, k(this, cr)), i;
        }
        clone() {
          const e = new Cf(this.url);
          return z(e, bi, k(this, bi)), k(this, Cn) && z(e, Cn, k(this, Cn)), z(e, cr, k(this, cr)), z(e, Pr, Object.assign({}, k(this, Pr))), z(e, wi, k(this, wi)), this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), z(e, Ms, k(this, Ms)), z(e, Ks, k(this, Ks)), z(e, Ls, k(this, Ls)), z(e, Ir, Object.assign({}, k(this, Ir))), z(e, to, k(this, to)), e;
        }
        static lockConfig() {
          Xf = !0;
        }
        static getGateway(e) {
          return Fl[e.toLowerCase()] || null;
        }
        static registerGateway(e, t) {
          if (e = e.toLowerCase(), e === "http" || e === "https") throw new Error(`cannot intercept ${e}; use registerGetUrl`);
          if (Xf) throw new Error("gateways locked");
          Fl[e] = t;
        }
        static registerGetUrl(e) {
          if (Xf) throw new Error("gateways locked");
          mh = e;
        }
        static createGetUrlFunc(e) {
          return yh(e);
        }
        static createDataGateway() {
          return bh;
        }
        static createIpfsGatewayFunc(e) {
          return wh(e);
        }
      };
      ka = new WeakMap(), Ma = new WeakMap(), Pr = new WeakMap(), bi = new WeakMap(), Ka = new WeakMap(), La = new WeakMap(), Cn = new WeakMap(), cr = new WeakMap(), wi = new WeakMap(), Ms = new WeakMap(), Ks = new WeakMap(), Ls = new WeakMap(), qr = new WeakMap(), Ir = new WeakMap(), to = new WeakMap(), Us = new WeakSet(), Pl = async function (e, t, r, i, a) {
        var u, f, d;
        if (e >= k(this, Ir).maxAttempts) return a.makeServerError("exceeded maximum retry limit");
        be(_h() <= t, "timeout", "TIMEOUT", {
          operation: "request.send",
          reason: "timeout",
          request: i
        }), r > 0 && (await p1(r));
        let l = this.clone();
        const s = (l.url.split(":")[0] || "").toLowerCase();
        if (s in Fl) {
          const p = await Fl[s](l.url, Hl(k(i, qr)));
          if (p instanceof ki) {
            let v = p;
            if (this.processFunc) {
              Hl(k(i, qr));
              try {
                v = await this.processFunc(l, v);
              } catch (h) {
                (h.throttle == null || typeof h.stall != "number") && v.makeServerError("error in post-processing function", h).assertOk();
              }
            }
            return v;
          }
          l = p;
        }
        this.preflightFunc && (l = await this.preflightFunc(l));
        const o = await this.getUrlFunc(l, Hl(k(i, qr)));
        let c = new ki(o.statusCode, o.statusMessage, o.headers, o.body, i);
        if (c.statusCode === 301 || c.statusCode === 302) {
          try {
            const p = c.headers.location || "";
            return _e(u = l.redirect(p), Us, Pl).call(u, e + 1, t, 0, i, c);
          } catch {}
          return c;
        } else if (c.statusCode === 429 && (this.retryFunc == null || (await this.retryFunc(l, c, e)))) {
          const p = c.headers["retry-after"];
          let v = k(this, Ir).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
          return typeof p == "string" && p.match(/^[1-9][0-9]*$/) && (v = parseInt(p)), _e(f = l.clone(), Us, Pl).call(f, e + 1, t, v, i, c);
        }
        if (this.processFunc) {
          Hl(k(i, qr));
          try {
            c = await this.processFunc(l, c);
          } catch (p) {
            (p.throttle == null || typeof p.stall != "number") && c.makeServerError("error in post-processing function", p).assertOk();
            let v = k(this, Ir).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
            return p.stall >= 0 && (v = p.stall), _e(d = l.clone(), Us, Pl).call(d, e + 1, t, v, i, c);
          }
        }
        return c;
      };
      let Bi = Cf;
      const Xd = class Xd {
        constructor(e, t, r, i, a) {
          de(this, ml);
          de(this, bl);
          de(this, wl);
          de(this, lr);
          de(this, Ua);
          de(this, Fs);
          z(this, ml, e), z(this, bl, t), z(this, wl, Object.keys(r).reduce((l, s) => (l[s.toLowerCase()] = String(r[s]), l), {})), z(this, lr, i == null ? null : new Uint8Array(i)), z(this, Ua, a || null), z(this, Fs, {
            message: ""
          });
        }
        toString() {
          return `<FetchResponse status=${this.statusCode} body=${k(this, lr) ? Se(k(this, lr)) : "null"}>`;
        }
        get statusCode() {
          return k(this, ml);
        }
        get statusMessage() {
          return k(this, bl);
        }
        get headers() {
          return Object.assign({}, k(this, wl));
        }
        get body() {
          return k(this, lr) == null ? null : new Uint8Array(k(this, lr));
        }
        get bodyText() {
          try {
            return k(this, lr) == null ? "" : Ul(k(this, lr));
          } catch {
            be(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
              operation: "bodyText",
              info: {
                response: this
              }
            });
          }
        }
        get bodyJson() {
          try {
            return JSON.parse(this.bodyText);
          } catch {
            be(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
              operation: "bodyJson",
              info: {
                response: this
              }
            });
          }
        }
        [Symbol.iterator]() {
          const e = this.headers,
            t = Object.keys(e);
          let r = 0;
          return {
            next: () => {
              if (r < t.length) {
                const i = t[r++];
                return {
                  value: [i, e[i]],
                  done: !1
                };
              }
              return {
                value: void 0,
                done: !0
              };
            }
          };
        }
        makeServerError(e, t) {
          let r;
          e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
          const i = new Xd(599, r, this.headers, this.body, k(this, Ua) || void 0);
          return z(i, Fs, {
            message: e,
            error: t
          }), i;
        }
        throwThrottleError(e, t) {
          t == null ? t = -1 : re(Number.isInteger(t) && t >= 0, "invalid stall timeout", "stall", t);
          const r = new Error(e || "throttling requests");
          throw Ge(r, {
            stall: t,
            throttle: !0
          }), r;
        }
        getHeader(e) {
          return this.headers[e.toLowerCase()];
        }
        hasBody() {
          return k(this, lr) != null;
        }
        get request() {
          return k(this, Ua);
        }
        ok() {
          return k(this, Fs).message === "" && this.statusCode >= 200 && this.statusCode < 300;
        }
        assertOk() {
          if (this.ok()) return;
          let {
            message: e,
            error: t
          } = k(this, Fs);
          e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
          let r = null;
          this.request && (r = this.request.url);
          let i = null;
          try {
            k(this, lr) && (i = Ul(k(this, lr)));
          } catch {}
          be(!1, e, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error: t,
            info: {
              requestUrl: r,
              responseBody: i,
              responseStatus: `${this.statusCode} ${this.statusMessage}`
            }
          });
        }
      };
      ml = new WeakMap(), bl = new WeakMap(), wl = new WeakMap(), lr = new WeakMap(), Ua = new WeakMap(), Fs = new WeakMap();
      let ki = Xd;
      function _h() {
        return new Date().getTime();
      }
      function h1(n) {
        return ii(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
      }
      function p1(n) {
        return new Promise(e => setTimeout(e, n));
      }
      const g1 = BigInt(-1),
        Or = BigInt(0),
        la = BigInt(1),
        v1 = BigInt(5),
        ua = {};
      let fa = "0000";
      for (; fa.length < 80;) fa += fa;
      function xo(n) {
        let e = fa;
        for (; e.length < n;) e += e;
        return BigInt("1" + e.substring(0, n));
      }
      function Ac(n, e, t) {
        const r = BigInt(e.width);
        if (e.signed) {
          const i = la << r - la;
          be(t == null || n >= -i && n < i, "overflow", "NUMERIC_FAULT", {
            operation: t,
            fault: "overflow",
            value: n
          }), n > Or ? n = Ml(wo(n, r), r) : n = -Ml(wo(-n, r), r);
        } else {
          const i = la << r;
          be(t == null || n >= 0 && n < i, "overflow", "NUMERIC_FAULT", {
            operation: t,
            fault: "overflow",
            value: n
          }), n = (n % i + i) % i & i - la;
        }
        return n;
      }
      function qf(n) {
        typeof n == "number" && (n = `fixed128x${n}`);
        let e = !0,
          t = 128,
          r = 18;
        if (typeof n == "string") {
          if (n !== "fixed") if (n === "ufixed") e = !1;else {
            const a = n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            re(a, "invalid fixed format", "format", n), e = a[1] !== "u", t = parseInt(a[2]), r = parseInt(a[3]);
          }
        } else if (n) {
          const a = n,
            l = (s, o, c) => a[s] == null ? c : (re(typeof a[s] === o, "invalid fixed format (" + s + " not " + o + ")", "format." + s, a[s]), a[s]);
          e = l("signed", "boolean", e), t = l("width", "number", t), r = l("decimals", "number", r);
        }
        re(t % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", t), re(r <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", r);
        const i = (e ? "" : "u") + "fixed" + String(t) + "x" + String(r);
        return {
          signed: e,
          width: t,
          decimals: r,
          name: i
        };
      }
      function y1(n, e) {
        let t = "";
        n < Or && (t = "-", n *= g1);
        let r = n.toString();
        if (e === 0) return t + r;
        for (; r.length <= e;) r = fa + r;
        const i = r.length - e;
        for (r = r.substring(0, i) + "." + r.substring(i); r[0] === "0" && r[1] !== ".";) r = r.substring(1);
        for (; r[r.length - 1] === "0" && r[r.length - 2] !== ".";) r = r.substring(0, r.length - 1);
        return t + r;
      }
      const no = class no {
        constructor(e, t, r) {
          de(this, Kt);
          ce(this, "format");
          de(this, Br);
          de(this, Ft);
          de(this, qn);
          ce(this, "_value");
          Oc(e, ua, "FixedNumber"), z(this, Ft, t), z(this, Br, r);
          const i = y1(t, r.decimals);
          Ge(this, {
            format: r.name,
            _value: i
          }), z(this, qn, xo(r.decimals));
        }
        get signed() {
          return k(this, Br).signed;
        }
        get width() {
          return k(this, Br).width;
        }
        get decimals() {
          return k(this, Br).decimals;
        }
        get value() {
          return k(this, Ft);
        }
        addUnsafe(e) {
          return _e(this, Kt, Vd).call(this, e);
        }
        add(e) {
          return _e(this, Kt, Vd).call(this, e, "add");
        }
        subUnsafe(e) {
          return _e(this, Kt, zd).call(this, e);
        }
        sub(e) {
          return _e(this, Kt, zd).call(this, e, "sub");
        }
        mulUnsafe(e) {
          return _e(this, Kt, $d).call(this, e);
        }
        mul(e) {
          return _e(this, Kt, $d).call(this, e, "mul");
        }
        mulSignal(e) {
          _e(this, Kt, oa).call(this, e);
          const t = k(this, Ft) * k(e, Ft);
          return be(t % k(this, qn) === Or, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
          }), _e(this, Kt, Pi).call(this, t / k(this, qn), "mulSignal");
        }
        divUnsafe(e) {
          return _e(this, Kt, Qd).call(this, e);
        }
        div(e) {
          return _e(this, Kt, Qd).call(this, e, "div");
        }
        divSignal(e) {
          be(k(e, Ft) !== Or, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
          }), _e(this, Kt, oa).call(this, e);
          const t = k(this, Ft) * k(this, qn);
          return be(t % k(e, Ft) === Or, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
          }), _e(this, Kt, Pi).call(this, t / k(e, Ft), "divSignal");
        }
        cmp(e) {
          let t = this.value,
            r = e.value;
          const i = this.decimals - e.decimals;
          return i > 0 ? r *= xo(i) : i < 0 && (t *= xo(-i)), t < r ? -1 : t > r ? 1 : 0;
        }
        eq(e) {
          return this.cmp(e) === 0;
        }
        lt(e) {
          return this.cmp(e) < 0;
        }
        lte(e) {
          return this.cmp(e) <= 0;
        }
        gt(e) {
          return this.cmp(e) > 0;
        }
        gte(e) {
          return this.cmp(e) >= 0;
        }
        floor() {
          let e = k(this, Ft);
          return k(this, Ft) < Or && (e -= k(this, qn) - la), e = k(this, Ft) / k(this, qn) * k(this, qn), _e(this, Kt, Pi).call(this, e, "floor");
        }
        ceiling() {
          let e = k(this, Ft);
          return k(this, Ft) > Or && (e += k(this, qn) - la), e = k(this, Ft) / k(this, qn) * k(this, qn), _e(this, Kt, Pi).call(this, e, "ceiling");
        }
        round(e) {
          if (e == null && (e = 0), e >= this.decimals) return this;
          const t = this.decimals - e,
            r = v1 * xo(t - 1);
          let i = this.value + r;
          const a = xo(t);
          return i = i / a * a, Ac(i, k(this, Br), "round"), new no(ua, i, k(this, Br));
        }
        isZero() {
          return k(this, Ft) === Or;
        }
        isNegative() {
          return k(this, Ft) < Or;
        }
        toString() {
          return this._value;
        }
        toUnsafeFloat() {
          return parseFloat(this.toString());
        }
        toFormat(e) {
          return no.fromString(this.toString(), e);
        }
        static fromValue(e, t, r) {
          const i = t == null ? 0 : ct(t),
            a = qf(r);
          let l = Le(e, "value");
          const s = i - a.decimals;
          if (s > 0) {
            const o = xo(s);
            be(l % o === Or, "value loses precision for format", "NUMERIC_FAULT", {
              operation: "fromValue",
              fault: "underflow",
              value: e
            }), l /= o;
          } else s < 0 && (l *= xo(-s));
          return Ac(l, a, "fromValue"), new no(ua, l, a);
        }
        static fromString(e, t) {
          const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
          re(r && r[2].length + r[3].length > 0, "invalid FixedNumber string value", "value", e);
          const i = qf(t);
          let a = r[2] || "0",
            l = r[3] || "";
          for (; l.length < i.decimals;) l += fa;
          be(l.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: e
          }), l = l.substring(0, i.decimals);
          const s = BigInt(r[1] + a + l);
          return Ac(s, i, "fromString"), new no(ua, s, i);
        }
        static fromBytes(e, t) {
          let r = Ll(ft(e, "value"));
          const i = qf(t);
          return i.signed && (r = Ml(r, i.width)), Ac(r, i, "fromBytes"), new no(ua, r, i);
        }
      };
      Br = new WeakMap(), Ft = new WeakMap(), qn = new WeakMap(), Kt = new WeakSet(), oa = function (e) {
        re(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e);
      }, Pi = function (e, t) {
        return e = Ac(e, k(this, Br), t), new no(ua, e, k(this, Br));
      }, Vd = function (e, t) {
        return _e(this, Kt, oa).call(this, e), _e(this, Kt, Pi).call(this, k(this, Ft) + k(e, Ft), t);
      }, zd = function (e, t) {
        return _e(this, Kt, oa).call(this, e), _e(this, Kt, Pi).call(this, k(this, Ft) - k(e, Ft), t);
      }, $d = function (e, t) {
        return _e(this, Kt, oa).call(this, e), _e(this, Kt, Pi).call(this, k(this, Ft) * k(e, Ft) / k(this, qn), t);
      }, Qd = function (e, t) {
        return be(k(e, Ft) !== Or, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        }), _e(this, Kt, oa).call(this, e), _e(this, Kt, Pi).call(this, k(this, Ft) * k(this, qn) / k(e, Ft), t);
      };
      let jl = no;
      function m1(n) {
        let e = n.toString(16);
        for (; e.length < 2;) e = "0" + e;
        return "0x" + e;
      }
      function Eh(n, e, t) {
        let r = 0;
        for (let i = 0; i < t; i++) r = r * 256 + n[e + i];
        return r;
      }
      function Ch(n, e, t, r) {
        const i = [];
        for (; t < e + 1 + r;) {
          const a = Oh(n, t);
          i.push(a.result), t += a.consumed, be(t <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
            buffer: n,
            length: r,
            offset: e
          });
        }
        return {
          consumed: 1 + r,
          result: i
        };
      }
      function Oh(n, e) {
        be(n.length !== 0, "data too short", "BUFFER_OVERRUN", {
          buffer: n,
          length: 0,
          offset: 1
        });
        const t = r => {
          be(r <= n.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: n,
            length: n.length,
            offset: r
          });
        };
        if (n[e] >= 248) {
          const r = n[e] - 247;
          t(e + 1 + r);
          const i = Eh(n, e + 1, r);
          return t(e + 1 + r + i), Ch(n, e, e + 1 + r, r + i);
        } else if (n[e] >= 192) {
          const r = n[e] - 192;
          return t(e + 1 + r), Ch(n, e, e + 1, r);
        } else if (n[e] >= 184) {
          const r = n[e] - 183;
          t(e + 1 + r);
          const i = Eh(n, e + 1, r);
          t(e + 1 + r + i);
          const a = Se(n.slice(e + 1 + r, e + 1 + r + i));
          return {
            consumed: 1 + r + i,
            result: a
          };
        } else if (n[e] >= 128) {
          const r = n[e] - 128;
          t(e + 1 + r);
          const i = Se(n.slice(e + 1, e + 1 + r));
          return {
            consumed: 1 + r,
            result: i
          };
        }
        return {
          consumed: 1,
          result: m1(n[e])
        };
      }
      function Rc(n) {
        const e = ft(n, "data"),
          t = Oh(e, 0);
        return re(t.consumed === e.length, "unexpected junk after rlp payload", "data", n), t.result;
      }
      function Ah(n) {
        const e = [];
        for (; n;) e.unshift(n & 255), n >>= 8;
        return e;
      }
      function Rh(n) {
        if (Array.isArray(n)) {
          let r = [];
          if (n.forEach(function (a) {
            r = r.concat(Rh(a));
          }), r.length <= 55) return r.unshift(192 + r.length), r;
          const i = Ah(r.length);
          return i.unshift(247 + i.length), i.concat(r);
        }
        const e = Array.prototype.slice.call(ft(n, "object"));
        if (e.length === 1 && e[0] <= 127) return e;
        if (e.length <= 55) return e.unshift(128 + e.length), e;
        const t = Ah(e.length);
        return t.unshift(183 + t.length), t.concat(e);
      }
      const Nh = "0123456789abcdef";
      function Mi(n) {
        let e = "0x";
        for (const t of Rh(n)) e += Nh[t >> 4], e += Nh[t & 15];
        return e;
      }
      function b1(n, e) {
        let t = 18;
        return t = ct(e, "unit"), jl.fromValue(n, t, {
          decimals: t,
          width: 512
        }).toString();
      }
      function w1(n, e) {
        re(typeof n == "string", "value must be a string", "value", n);
        let t = 18;
        return t = ct(e, "unit"), jl.fromString(n, {
          decimals: t,
          width: 512
        }).value;
      }
      function x1(n) {
        return b1(n, 18);
      }
      function _1(n) {
        return w1(n, 18);
      }
      const Hn = 32,
        Jf = new Uint8Array(Hn),
        E1 = ["then"],
        Wl = {},
        Sh = new WeakMap();
      function _o(n) {
        return Sh.get(n);
      }
      function Th(n, e) {
        Sh.set(n, e);
      }
      function Nc(n, e) {
        const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
        throw t.error = e, t;
      }
      function Gf(n, e, t) {
        return n.indexOf(null) >= 0 ? e.map((r, i) => r instanceof da ? Gf(_o(r), r, t) : r) : n.reduce((r, i, a) => {
          let l = e.getValue(i);
          return i in r || (t && l instanceof da && (l = Gf(_o(l), l, t)), r[i] = l), r;
        }, {});
      }
      const Ha = class Ha extends Array {
        constructor(...t) {
          const r = t[0];
          let i = t[1],
            a = (t[2] || []).slice(),
            l = !0;
          r !== Wl && (i = t, a = [], l = !1);
          super(i.length);
          de(this, Fa);
          i.forEach((c, u) => {
            this[u] = c;
          });
          const s = a.reduce((c, u) => (typeof u == "string" && c.set(u, (c.get(u) || 0) + 1), c), new Map());
          if (Th(this, Object.freeze(i.map((c, u) => {
            const f = a[u];
            return f != null && s.get(f) === 1 ? f : null;
          }))), z(this, Fa, []), k(this, Fa) == null && k(this, Fa), !l) return;
          Object.freeze(this);
          const o = new Proxy(this, {
            get: (c, u, f) => {
              if (typeof u == "string") {
                if (u.match(/^[0-9]+$/)) {
                  const p = ct(u, "%index");
                  if (p < 0 || p >= this.length) throw new RangeError("out of result range");
                  const v = c[p];
                  return v instanceof Error && Nc(`index ${p}`, v), v;
                }
                if (E1.indexOf(u) >= 0) return Reflect.get(c, u, f);
                const d = c[u];
                if (d instanceof Function) return function (...p) {
                  return d.apply(this === f ? c : this, p);
                };
                if (!(u in c)) return c.getValue.apply(this === f ? c : this, [u]);
              }
              return Reflect.get(c, u, f);
            }
          });
          return Th(o, _o(this)), o;
        }
        toArray(t) {
          const r = [];
          return this.forEach((i, a) => {
            i instanceof Error && Nc(`index ${a}`, i), t && i instanceof Ha && (i = i.toArray(t)), r.push(i);
          }), r;
        }
        toObject(t) {
          const r = _o(this);
          return r.reduce((i, a, l) => (be(a != null, `value at index ${l} unnamed`, "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
          }), Gf(r, this, t)), {});
        }
        slice(t, r) {
          t == null && (t = 0), t < 0 && (t += this.length, t < 0 && (t = 0)), r == null && (r = this.length), r < 0 && (r += this.length, r < 0 && (r = 0)), r > this.length && (r = this.length);
          const i = _o(this),
            a = [],
            l = [];
          for (let s = t; s < r; s++) a.push(this[s]), l.push(i[s]);
          return new Ha(Wl, a, l);
        }
        filter(t, r) {
          const i = _o(this),
            a = [],
            l = [];
          for (let s = 0; s < this.length; s++) {
            const o = this[s];
            o instanceof Error && Nc(`index ${s}`, o), t.call(r, o, s, this) && (a.push(o), l.push(i[s]));
          }
          return new Ha(Wl, a, l);
        }
        map(t, r) {
          const i = [];
          for (let a = 0; a < this.length; a++) {
            const l = this[a];
            l instanceof Error && Nc(`index ${a}`, l), i.push(t.call(r, l, a, this));
          }
          return i;
        }
        getValue(t) {
          const r = _o(this).indexOf(t);
          if (r === -1) return;
          const i = this[r];
          return i instanceof Error && Nc(`property ${JSON.stringify(t)}`, i.error), i;
        }
        static fromItems(t, r) {
          return new Ha(Wl, t, r);
        }
      };
      Fa = new WeakMap();
      let da = Ha;
      function Dh(n) {
        let e = wn(n);
        return be(e.length <= Hn, "value out-of-bounds", "BUFFER_OVERRUN", {
          buffer: e,
          length: Hn,
          offset: e.length
        }), e.length !== Hn && (e = Fn(sn([Jf.slice(e.length % Hn), e]))), e;
      }
      class oi {
        constructor(e, t, r, i) {
          ce(this, "name");
          ce(this, "type");
          ce(this, "localName");
          ce(this, "dynamic");
          Ge(this, {
            name: e,
            type: t,
            localName: r,
            dynamic: i
          }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
          });
        }
        _throwError(e, t) {
          re(!1, e, this.localName, t);
        }
      }
      class Vf {
        constructor() {
          de(this, ja);
          de(this, xi);
          de(this, Hs);
          z(this, xi, []), z(this, Hs, 0);
        }
        get data() {
          return sn(k(this, xi));
        }
        get length() {
          return k(this, Hs);
        }
        appendWriter(e) {
          return _e(this, ja, kf).call(this, Fn(e.data));
        }
        writeBytes(e) {
          let t = Fn(e);
          const r = t.length % Hn;
          return r && (t = Fn(sn([t, Jf.slice(r)]))), _e(this, ja, kf).call(this, t);
        }
        writeValue(e) {
          return _e(this, ja, kf).call(this, Dh(e));
        }
        writeUpdatableValue() {
          const e = k(this, xi).length;
          return k(this, xi).push(Jf), z(this, Hs, k(this, Hs) + Hn), t => {
            k(this, xi)[e] = Dh(t);
          };
        }
      }
      xi = new WeakMap(), Hs = new WeakMap(), ja = new WeakSet(), kf = function (e) {
        return k(this, xi).push(e), z(this, Hs, k(this, Hs) + e.length), e.length;
      };
      const qd = class qd {
        constructor(e, t, r) {
          de(this, Xs);
          ce(this, "allowLoose");
          de(this, Yn);
          de(this, ur);
          de(this, js);
          de(this, Ws);
          de(this, ro);
          Ge(this, {
            allowLoose: !!t
          }), z(this, Yn, Fn(e)), z(this, js, 0), z(this, Ws, null), z(this, ro, r != null ? r : 1024), z(this, ur, 0);
        }
        get data() {
          return Se(k(this, Yn));
        }
        get dataLength() {
          return k(this, Yn).length;
        }
        get consumed() {
          return k(this, ur);
        }
        get bytes() {
          return new Uint8Array(k(this, Yn));
        }
        subReader(e) {
          const t = new qd(k(this, Yn).slice(k(this, ur) + e), this.allowLoose, k(this, ro));
          return z(t, Ws, this), t;
        }
        readBytes(e, t) {
          let r = _e(this, Xs, Vb).call(this, 0, e, !!t);
          return _e(this, Xs, Yd).call(this, e), z(this, ur, k(this, ur) + r.length), r.slice(0, e);
        }
        readValue() {
          return Ll(this.readBytes(Hn));
        }
        readIndex() {
          return Zb(this.readBytes(Hn));
        }
      };
      Yn = new WeakMap(), ur = new WeakMap(), js = new WeakMap(), Ws = new WeakMap(), ro = new WeakMap(), Xs = new WeakSet(), Yd = function (e) {
        var t;
        if (k(this, Ws)) return _e(t = k(this, Ws), Xs, Yd).call(t, e);
        z(this, js, k(this, js) + e), be(k(this, ro) < 1 || k(this, js) <= k(this, ro) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${k(this, ro)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
          buffer: Fn(k(this, Yn)),
          offset: k(this, ur),
          length: e,
          info: {
            bytesRead: k(this, js),
            dataLength: this.dataLength
          }
        });
      }, Vb = function (e, t, r) {
        let i = Math.ceil(t / Hn) * Hn;
        return k(this, ur) + i > k(this, Yn).length && (this.allowLoose && r && k(this, ur) + t <= k(this, Yn).length ? i = t : be(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: Fn(k(this, Yn)),
          length: k(this, Yn).length,
          offset: k(this, ur) + i
        })), k(this, Yn).slice(k(this, ur), k(this, ur) + i);
      };
      let zf = qd;
      function Xl(n) {
        if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
      }
      function $f(n, ...e) {
        if (!(n instanceof Uint8Array)) throw new Error("Expected Uint8Array");
        if (e.length > 0 && !e.includes(n.length)) throw new Error(`Expected Uint8Array of length ${e}, not of length=${n.length}`);
      }
      function C1(n) {
        if (typeof n != "function" || typeof n.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
        Xl(n.outputLen), Xl(n.blockLen);
      }
      function ha(n, e = !0) {
        if (n.destroyed) throw new Error("Hash instance has been destroyed");
        if (e && n.finished) throw new Error("Hash#digest() has already been called");
      }
      function Ph(n, e) {
        $f(n);
        const t = e.outputLen;
        if (n.length < t) throw new Error(`digestInto() expects output buffer of length at least ${t}`);
      }
      const Qf = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const Ih = n => n instanceof Uint8Array,
        O1 = n => new Uint32Array(n.buffer, n.byteOffset, Math.floor(n.byteLength / 4)),
        Yf = n => new DataView(n.buffer, n.byteOffset, n.byteLength),
        Ur = (n, e) => n << 32 - e | n >>> e;
      if (!(new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)) throw new Error("Non little-endian hardware is not supported");
      function A1(n) {
        if (typeof n != "string") throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
        return new Uint8Array(new TextEncoder().encode(n));
      }
      function ql(n) {
        if (typeof n == "string" && (n = A1(n)), !Ih(n)) throw new Error(`expected Uint8Array, got ${typeof n}`);
        return n;
      }
      function R1(...n) {
        const e = new Uint8Array(n.reduce((r, i) => r + i.length, 0));
        let t = 0;
        return n.forEach(r => {
          if (!Ih(r)) throw new Error("Uint8Array expected");
          e.set(r, t), t += r.length;
        }), e;
      }
      class Zf {
        clone() {
          return this._cloneInto();
        }
      }
      function e0(n) {
        const e = r => n().update(ql(r)).digest(),
          t = n();
        return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => n(), e;
      }
      function N1(n = 32) {
        if (Qf && typeof Qf.getRandomValues == "function") return Qf.getRandomValues(new Uint8Array(n));
        throw new Error("crypto.getRandomValues must be defined");
      }
      class Bh extends Zf {
        constructor(e, t) {
          super(), this.finished = !1, this.destroyed = !1, C1(e);
          const r = ql(t);
          if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
          const i = this.blockLen,
            a = new Uint8Array(i);
          a.set(r.length > i ? e.create().update(r).digest() : r);
          for (let l = 0; l < a.length; l++) a[l] ^= 54;
          this.iHash.update(a), this.oHash = e.create();
          for (let l = 0; l < a.length; l++) a[l] ^= 106;
          this.oHash.update(a), a.fill(0);
        }
        update(e) {
          return ha(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          ha(this), $f(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
        }
        digest() {
          const e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          const {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: a,
            blockLen: l,
            outputLen: s
          } = this;
          return e = e, e.finished = i, e.destroyed = a, e.blockLen = l, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
        }
        destroy() {
          this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
        }
      }
      const kh = (n, e, t) => new Bh(n, e).update(t).digest();
      kh.create = (n, e) => new Bh(n, e);
      function S1(n, e, t, r) {
        if (typeof n.setBigUint64 == "function") return n.setBigUint64(e, t, r);
        const i = BigInt(32),
          a = BigInt(4294967295),
          l = Number(t >> i & a),
          s = Number(t & a),
          o = r ? 4 : 0,
          c = r ? 0 : 4;
        n.setUint32(e + o, l, r), n.setUint32(e + c, s, r);
      }
      class Mh extends Zf {
        constructor(e, t, r, i) {
          super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Yf(this.buffer);
        }
        update(e) {
          ha(this);
          const {
            view: t,
            buffer: r,
            blockLen: i
          } = this;
          e = ql(e);
          const a = e.length;
          for (let l = 0; l < a;) {
            const s = Math.min(i - this.pos, a - l);
            if (s === i) {
              const o = Yf(e);
              for (; i <= a - l; l += i) this.process(o, l);
              continue;
            }
            r.set(e.subarray(l, l + s), this.pos), this.pos += s, l += s, this.pos === i && (this.process(t, 0), this.pos = 0);
          }
          return this.length += e.length, this.roundClean(), this;
        }
        digestInto(e) {
          ha(this), Ph(e, this), this.finished = !0;
          const {
            buffer: t,
            view: r,
            blockLen: i,
            isLE: a
          } = this;
          let {
            pos: l
          } = this;
          t[l++] = 128, this.buffer.subarray(l).fill(0), this.padOffset > i - l && (this.process(r, 0), l = 0);
          for (let f = l; f < i; f++) t[f] = 0;
          S1(r, i - 8, BigInt(this.length * 8), a), this.process(r, 0);
          const s = Yf(e),
            o = this.outputLen;
          if (o % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
          const c = o / 4,
            u = this.get();
          if (c > u.length) throw new Error("_sha2: outputLen bigger than state");
          for (let f = 0; f < c; f++) s.setUint32(4 * f, u[f], a);
        }
        digest() {
          const {
            buffer: e,
            outputLen: t
          } = this;
          this.digestInto(e);
          const r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          const {
            blockLen: t,
            buffer: r,
            length: i,
            finished: a,
            destroyed: l,
            pos: s
          } = this;
          return e.length = i, e.pos = s, e.finished = a, e.destroyed = l, i % t && e.buffer.set(r), e;
        }
      }
      const T1 = (n, e, t) => n & e ^ ~n & t,
        D1 = (n, e, t) => n & e ^ n & t ^ e & t,
        P1 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
        Ki = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        Li = new Uint32Array(64);
      class I1 extends Mh {
        constructor() {
          super(64, 32, 8, !1), this.A = Ki[0] | 0, this.B = Ki[1] | 0, this.C = Ki[2] | 0, this.D = Ki[3] | 0, this.E = Ki[4] | 0, this.F = Ki[5] | 0, this.G = Ki[6] | 0, this.H = Ki[7] | 0;
        }
        get() {
          const {
            A: e,
            B: t,
            C: r,
            D: i,
            E: a,
            F: l,
            G: s,
            H: o
          } = this;
          return [e, t, r, i, a, l, s, o];
        }
        set(e, t, r, i, a, l, s, o) {
          this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = i | 0, this.E = a | 0, this.F = l | 0, this.G = s | 0, this.H = o | 0;
        }
        process(e, t) {
          for (let f = 0; f < 16; f++, t += 4) Li[f] = e.getUint32(t, !1);
          for (let f = 16; f < 64; f++) {
            const d = Li[f - 15],
              p = Li[f - 2],
              v = Ur(d, 7) ^ Ur(d, 18) ^ d >>> 3,
              h = Ur(p, 17) ^ Ur(p, 19) ^ p >>> 10;
            Li[f] = h + Li[f - 7] + v + Li[f - 16] | 0;
          }
          let {
            A: r,
            B: i,
            C: a,
            D: l,
            E: s,
            F: o,
            G: c,
            H: u
          } = this;
          for (let f = 0; f < 64; f++) {
            const d = Ur(s, 6) ^ Ur(s, 11) ^ Ur(s, 25),
              p = u + d + T1(s, o, c) + P1[f] + Li[f] | 0,
              h = (Ur(r, 2) ^ Ur(r, 13) ^ Ur(r, 22)) + D1(r, i, a) | 0;
            u = c, c = o, o = s, s = l + p | 0, l = a, a = i, i = r, r = p + h | 0;
          }
          r = r + this.A | 0, i = i + this.B | 0, a = a + this.C | 0, l = l + this.D | 0, s = s + this.E | 0, o = o + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, i, a, l, s, o, c, u);
        }
        roundClean() {
          Li.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
        }
      }
      const Kh = e0(() => new I1()),
        Jl = BigInt(2 ** 32 - 1),
        t0 = BigInt(32);
      function Lh(n, e = !1) {
        return e ? {
          h: Number(n & Jl),
          l: Number(n >> t0 & Jl)
        } : {
          h: Number(n >> t0 & Jl) | 0,
          l: Number(n & Jl) | 0
        };
      }
      function Uh(n, e = !1) {
        let t = new Uint32Array(n.length),
          r = new Uint32Array(n.length);
        for (let i = 0; i < n.length; i++) {
          const {
            h: a,
            l
          } = Lh(n[i], e);
          [t[i], r[i]] = [a, l];
        }
        return [t, r];
      }
      const B1 = (n, e) => BigInt(n >>> 0) << t0 | BigInt(e >>> 0),
        k1 = (n, e, t) => n >>> t,
        M1 = (n, e, t) => n << 32 - t | e >>> t,
        K1 = (n, e, t) => n >>> t | e << 32 - t,
        L1 = (n, e, t) => n << 32 - t | e >>> t,
        U1 = (n, e, t) => n << 64 - t | e >>> t - 32,
        F1 = (n, e, t) => n >>> t - 32 | e << 64 - t,
        H1 = (n, e) => e,
        j1 = (n, e) => n,
        Fh = (n, e, t) => n << t | e >>> 32 - t,
        Hh = (n, e, t) => e << t | n >>> 32 - t,
        jh = (n, e, t) => e << t - 32 | n >>> 64 - t,
        Wh = (n, e, t) => n << t - 32 | e >>> 64 - t;
      function W1(n, e, t, r) {
        const i = (e >>> 0) + (r >>> 0);
        return {
          h: n + t + (i / 2 ** 32 | 0) | 0,
          l: i | 0
        };
      }
      const lt = {
          fromBig: Lh,
          split: Uh,
          toBig: B1,
          shrSH: k1,
          shrSL: M1,
          rotrSH: K1,
          rotrSL: L1,
          rotrBH: U1,
          rotrBL: F1,
          rotr32H: H1,
          rotr32L: j1,
          rotlSH: Fh,
          rotlSL: Hh,
          rotlBH: jh,
          rotlBL: Wh,
          add: W1,
          add3L: (n, e, t) => (n >>> 0) + (e >>> 0) + (t >>> 0),
          add3H: (n, e, t, r) => e + t + r + (n / 2 ** 32 | 0) | 0,
          add4L: (n, e, t, r) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0),
          add4H: (n, e, t, r, i) => e + t + r + i + (n / 2 ** 32 | 0) | 0,
          add5H: (n, e, t, r, i, a) => e + t + r + i + a + (n / 2 ** 32 | 0) | 0,
          add5L: (n, e, t, r, i) => (n >>> 0) + (e >>> 0) + (t >>> 0) + (r >>> 0) + (i >>> 0)
        },
        [X1, q1] = lt.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(n => BigInt(n))),
        Ui = new Uint32Array(80),
        Fi = new Uint32Array(80);
      class J1 extends Mh {
        constructor() {
          super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
        }
        get() {
          const {
            Ah: e,
            Al: t,
            Bh: r,
            Bl: i,
            Ch: a,
            Cl: l,
            Dh: s,
            Dl: o,
            Eh: c,
            El: u,
            Fh: f,
            Fl: d,
            Gh: p,
            Gl: v,
            Hh: h,
            Hl: g
          } = this;
          return [e, t, r, i, a, l, s, o, c, u, f, d, p, v, h, g];
        }
        set(e, t, r, i, a, l, s, o, c, u, f, d, p, v, h, g) {
          this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = a | 0, this.Cl = l | 0, this.Dh = s | 0, this.Dl = o | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = p | 0, this.Gl = v | 0, this.Hh = h | 0, this.Hl = g | 0;
        }
        process(e, t) {
          for (let _ = 0; _ < 16; _++, t += 4) Ui[_] = e.getUint32(t), Fi[_] = e.getUint32(t += 4);
          for (let _ = 16; _ < 80; _++) {
            const N = Ui[_ - 15] | 0,
              O = Fi[_ - 15] | 0,
              y = lt.rotrSH(N, O, 1) ^ lt.rotrSH(N, O, 8) ^ lt.shrSH(N, O, 7),
              w = lt.rotrSL(N, O, 1) ^ lt.rotrSL(N, O, 8) ^ lt.shrSL(N, O, 7),
              A = Ui[_ - 2] | 0,
              R = Fi[_ - 2] | 0,
              T = lt.rotrSH(A, R, 19) ^ lt.rotrBH(A, R, 61) ^ lt.shrSH(A, R, 6),
              D = lt.rotrSL(A, R, 19) ^ lt.rotrBL(A, R, 61) ^ lt.shrSL(A, R, 6),
              M = lt.add4L(w, D, Fi[_ - 7], Fi[_ - 16]),
              q = lt.add4H(M, y, T, Ui[_ - 7], Ui[_ - 16]);
            Ui[_] = q | 0, Fi[_] = M | 0;
          }
          let {
            Ah: r,
            Al: i,
            Bh: a,
            Bl: l,
            Ch: s,
            Cl: o,
            Dh: c,
            Dl: u,
            Eh: f,
            El: d,
            Fh: p,
            Fl: v,
            Gh: h,
            Gl: g,
            Hh: b,
            Hl: m
          } = this;
          for (let _ = 0; _ < 80; _++) {
            const N = lt.rotrSH(f, d, 14) ^ lt.rotrSH(f, d, 18) ^ lt.rotrBH(f, d, 41),
              O = lt.rotrSL(f, d, 14) ^ lt.rotrSL(f, d, 18) ^ lt.rotrBL(f, d, 41),
              y = f & p ^ ~f & h,
              w = d & v ^ ~d & g,
              A = lt.add5L(m, O, w, q1[_], Fi[_]),
              R = lt.add5H(A, b, N, y, X1[_], Ui[_]),
              T = A | 0,
              D = lt.rotrSH(r, i, 28) ^ lt.rotrBH(r, i, 34) ^ lt.rotrBH(r, i, 39),
              M = lt.rotrSL(r, i, 28) ^ lt.rotrBL(r, i, 34) ^ lt.rotrBL(r, i, 39),
              q = r & a ^ r & s ^ a & s,
              W = i & l ^ i & o ^ l & o;
            b = h | 0, m = g | 0, h = p | 0, g = v | 0, p = f | 0, v = d | 0, ({
              h: f,
              l: d
            } = lt.add(c | 0, u | 0, R | 0, T | 0)), c = s | 0, u = o | 0, s = a | 0, o = l | 0, a = r | 0, l = i | 0;
            const x = lt.add3L(T, M, W);
            r = lt.add3H(x, R, D, q), i = x | 0;
          }
          ({
            h: r,
            l: i
          } = lt.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), ({
            h: a,
            l
          } = lt.add(this.Bh | 0, this.Bl | 0, a | 0, l | 0)), ({
            h: s,
            l: o
          } = lt.add(this.Ch | 0, this.Cl | 0, s | 0, o | 0)), ({
            h: c,
            l: u
          } = lt.add(this.Dh | 0, this.Dl | 0, c | 0, u | 0)), ({
            h: f,
            l: d
          } = lt.add(this.Eh | 0, this.El | 0, f | 0, d | 0)), ({
            h: p,
            l: v
          } = lt.add(this.Fh | 0, this.Fl | 0, p | 0, v | 0)), ({
            h,
            l: g
          } = lt.add(this.Gh | 0, this.Gl | 0, h | 0, g | 0)), ({
            h: b,
            l: m
          } = lt.add(this.Hh | 0, this.Hl | 0, b | 0, m | 0)), this.set(r, i, a, l, s, o, c, u, f, d, p, v, h, g, b, m);
        }
        roundClean() {
          Ui.fill(0), Fi.fill(0);
        }
        destroy() {
          this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      }
      const G1 = e0(() => new J1());
      function V1() {
        if (typeof self != "undefined") return self;
        if (typeof window != "undefined") return window;
        if (typeof global != "undefined") return global;
        throw new Error("unable to locate global object");
      }
      const Xh = V1();
      Xh.crypto || Xh.msCrypto;
      function z1(n) {
        switch (n) {
          case "sha256":
            return Kh.create();
          case "sha512":
            return G1.create();
        }
        re(!1, "invalid hashing algorithm name", "algorithm", n);
      }
      const [qh, Jh, Gh] = [[], [], []],
        $1 = BigInt(0),
        Sc = BigInt(1),
        Q1 = BigInt(2),
        Y1 = BigInt(7),
        Z1 = BigInt(256),
        ew = BigInt(113);
      for (let n = 0, e = Sc, t = 1, r = 0; n < 24; n++) {
        [t, r] = [r, (2 * t + 3 * r) % 5], qh.push(2 * (5 * r + t)), Jh.push((n + 1) * (n + 2) / 2 % 64);
        let i = $1;
        for (let a = 0; a < 7; a++) e = (e << Sc ^ (e >> Y1) * ew) % Z1, e & Q1 && (i ^= Sc << (Sc << BigInt(a)) - Sc);
        Gh.push(i);
      }
      const [tw, nw] = Uh(Gh, !0),
        Vh = (n, e, t) => t > 32 ? jh(n, e, t) : Fh(n, e, t),
        zh = (n, e, t) => t > 32 ? Wh(n, e, t) : Hh(n, e, t);
      function rw(n, e = 24) {
        const t = new Uint32Array(10);
        for (let r = 24 - e; r < 24; r++) {
          for (let l = 0; l < 10; l++) t[l] = n[l] ^ n[l + 10] ^ n[l + 20] ^ n[l + 30] ^ n[l + 40];
          for (let l = 0; l < 10; l += 2) {
            const s = (l + 8) % 10,
              o = (l + 2) % 10,
              c = t[o],
              u = t[o + 1],
              f = Vh(c, u, 1) ^ t[s],
              d = zh(c, u, 1) ^ t[s + 1];
            for (let p = 0; p < 50; p += 10) n[l + p] ^= f, n[l + p + 1] ^= d;
          }
          let i = n[2],
            a = n[3];
          for (let l = 0; l < 24; l++) {
            const s = Jh[l],
              o = Vh(i, a, s),
              c = zh(i, a, s),
              u = qh[l];
            i = n[u], a = n[u + 1], n[u] = o, n[u + 1] = c;
          }
          for (let l = 0; l < 50; l += 10) {
            for (let s = 0; s < 10; s++) t[s] = n[l + s];
            for (let s = 0; s < 10; s++) n[l + s] ^= ~t[(s + 2) % 10] & t[(s + 4) % 10];
          }
          n[0] ^= tw[r], n[1] ^= nw[r];
        }
        t.fill(0);
      }
      class n0 extends Zf {
        constructor(e, t, r, i = !1, a = 24) {
          if (super(), this.blockLen = e, this.suffix = t, this.outputLen = r, this.enableXOF = i, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Xl(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200), this.state32 = O1(this.state);
        }
        keccak() {
          rw(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
        }
        update(e) {
          ha(this);
          const {
            blockLen: t,
            state: r
          } = this;
          e = ql(e);
          const i = e.length;
          for (let a = 0; a < i;) {
            const l = Math.min(t - this.pos, i - a);
            for (let s = 0; s < l; s++) r[this.pos++] ^= e[a++];
            this.pos === t && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished) return;
          this.finished = !0;
          const {
            state: e,
            suffix: t,
            pos: r,
            blockLen: i
          } = this;
          e[r] ^= t, (t & 128) !== 0 && r === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
        }
        writeInto(e) {
          ha(this, !1), $f(e), this.finish();
          const t = this.state,
            {
              blockLen: r
            } = this;
          for (let i = 0, a = e.length; i < a;) {
            this.posOut >= r && this.keccak();
            const l = Math.min(r - this.posOut, a - i);
            e.set(t.subarray(this.posOut, this.posOut + l), i), this.posOut += l, i += l;
          }
          return e;
        }
        xofInto(e) {
          if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
          return this.writeInto(e);
        }
        xof(e) {
          return Xl(e), this.xofInto(new Uint8Array(e));
        }
        digestInto(e) {
          if (Ph(e, this), this.finished) throw new Error("digest() was already called");
          return this.writeInto(e), this.destroy(), e;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = !0, this.state.fill(0);
        }
        _cloneInto(e) {
          const {
            blockLen: t,
            suffix: r,
            outputLen: i,
            rounds: a,
            enableXOF: l
          } = this;
          return e || (e = new n0(t, r, i, l, a)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = a, e.suffix = r, e.outputLen = i, e.enableXOF = l, e.destroyed = this.destroyed, e;
        }
      }
      const iw = ((n, e, t) => e0(() => new n0(e, n, t)))(1, 136, 256 / 8);
      let $h = !1;
      const Qh = function (n) {
        return iw(n);
      };
      let Yh = Qh;
      function gn(n) {
        const e = ft(n, "data");
        return Se(Yh(e));
      }
      gn._ = Qh, gn.lock = function () {
        $h = !0;
      }, gn.register = function (n) {
        if ($h) throw new TypeError("keccak256 is locked");
        Yh = n;
      }, Object.freeze(gn);
      const Zh = function (n) {
        return z1("sha256").update(n).digest();
      };
      let ep = Zh,
        tp = !1;
      function pa(n) {
        const e = ft(n, "data");
        return Se(ep(e));
      }
      pa._ = Zh, pa.lock = function () {
        tp = !0;
      }, pa.register = function (n) {
        if (tp) throw new Error("sha256 is locked");
        ep = n;
      }, Object.freeze(pa), Object.freeze(pa); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const np = BigInt(0),
        Gl = BigInt(1),
        ow = BigInt(2),
        Vl = n => n instanceof Uint8Array,
        sw = Array.from({
          length: 256
        }, (n, e) => e.toString(16).padStart(2, "0"));
      function ga(n) {
        if (!Vl(n)) throw new Error("Uint8Array expected");
        let e = "";
        for (let t = 0; t < n.length; t++) e += sw[n[t]];
        return e;
      }
      function rp(n) {
        const e = n.toString(16);
        return e.length & 1 ? `0${e}` : e;
      }
      function r0(n) {
        if (typeof n != "string") throw new Error("hex string expected, got " + typeof n);
        return BigInt(n === "" ? "0" : `0x${n}`);
      }
      function va(n) {
        if (typeof n != "string") throw new Error("hex string expected, got " + typeof n);
        const e = n.length;
        if (e % 2) throw new Error("padded hex string expected, got unpadded hex of length " + e);
        const t = new Uint8Array(e / 2);
        for (let r = 0; r < t.length; r++) {
          const i = r * 2,
            a = n.slice(i, i + 2),
            l = Number.parseInt(a, 16);
          if (Number.isNaN(l) || l < 0) throw new Error("Invalid byte sequence");
          t[r] = l;
        }
        return t;
      }
      function Eo(n) {
        return r0(ga(n));
      }
      function i0(n) {
        if (!Vl(n)) throw new Error("Uint8Array expected");
        return r0(ga(Uint8Array.from(n).reverse()));
      }
      function ya(n, e) {
        return va(n.toString(16).padStart(e * 2, "0"));
      }
      function o0(n, e) {
        return ya(n, e).reverse();
      }
      function aw(n) {
        return va(rp(n));
      }
      function Ar(n, e, t) {
        let r;
        if (typeof e == "string") try {
          r = va(e);
        } catch (a) {
          throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${a}`);
        } else if (Vl(e)) r = Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);
        const i = r.length;
        if (typeof t == "number" && i !== t) throw new Error(`${n} expected ${t} bytes, got ${i}`);
        return r;
      }
      function Tc(...n) {
        const e = new Uint8Array(n.reduce((r, i) => r + i.length, 0));
        let t = 0;
        return n.forEach(r => {
          if (!Vl(r)) throw new Error("Uint8Array expected");
          e.set(r, t), t += r.length;
        }), e;
      }
      function cw(n, e) {
        if (n.length !== e.length) return !1;
        for (let t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1;
        return !0;
      }
      function lw(n) {
        if (typeof n != "string") throw new Error(`utf8ToBytes expected string, got ${typeof n}`);
        return new Uint8Array(new TextEncoder().encode(n));
      }
      function uw(n) {
        let e;
        for (e = 0; n > np; n >>= Gl, e += 1);
        return e;
      }
      function fw(n, e) {
        return n >> BigInt(e) & Gl;
      }
      const dw = (n, e, t) => n | (t ? Gl : np) << BigInt(e),
        s0 = n => (ow << BigInt(n - 1)) - Gl,
        a0 = n => new Uint8Array(n),
        ip = n => Uint8Array.from(n);
      function op(n, e, t) {
        if (typeof n != "number" || n < 2) throw new Error("hashLen must be a number");
        if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
        if (typeof t != "function") throw new Error("hmacFn must be a function");
        let r = a0(n),
          i = a0(n),
          a = 0;
        const l = () => {
            r.fill(1), i.fill(0), a = 0;
          },
          s = (...f) => t(i, r, ...f),
          o = (f = a0()) => {
            i = s(ip([0]), f), r = s(), f.length !== 0 && (i = s(ip([1]), f), r = s());
          },
          c = () => {
            if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let f = 0;
            const d = [];
            for (; f < e;) {
              r = s();
              const p = r.slice();
              d.push(p), f += r.length;
            }
            return Tc(...d);
          };
        return (f, d) => {
          l(), o(f);
          let p;
          for (; !(p = d(c()));) o();
          return l(), p;
        };
      }
      const hw = {
        bigint: n => typeof n == "bigint",
        function: n => typeof n == "function",
        boolean: n => typeof n == "boolean",
        string: n => typeof n == "string",
        stringOrUint8Array: n => typeof n == "string" || n instanceof Uint8Array,
        isSafeInteger: n => Number.isSafeInteger(n),
        array: n => Array.isArray(n),
        field: (n, e) => e.Fp.isValid(n),
        hash: n => typeof n == "function" && Number.isSafeInteger(n.outputLen)
      };
      function Dc(n, e, t = {}) {
        const r = (i, a, l) => {
          const s = hw[a];
          if (typeof s != "function") throw new Error(`Invalid validator "${a}", expected function`);
          const o = n[i];
          if (!(l && o === void 0) && !s(o, n)) throw new Error(`Invalid param ${String(i)}=${o} (${typeof o}), expected ${a}`);
        };
        for (const [i, a] of Object.entries(e)) r(i, a, !1);
        for (const [i, a] of Object.entries(t)) r(i, a, !0);
        return n;
      }
      const pw = Object.freeze(Object.defineProperty({
        __proto__: null,
        bitGet: fw,
        bitLen: uw,
        bitMask: s0,
        bitSet: dw,
        bytesToHex: ga,
        bytesToNumberBE: Eo,
        bytesToNumberLE: i0,
        concatBytes: Tc,
        createHmacDrbg: op,
        ensureBytes: Ar,
        equalBytes: cw,
        hexToBytes: va,
        hexToNumber: r0,
        numberToBytesBE: ya,
        numberToBytesLE: o0,
        numberToHexUnpadded: rp,
        numberToVarBytesBE: aw,
        utf8ToBytes: lw,
        validateObject: Dc
      }, Symbol.toStringTag, {
        value: "Module"
      })); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const xn = BigInt(0),
        fn = BigInt(1),
        Co = BigInt(2),
        gw = BigInt(3),
        c0 = BigInt(4),
        sp = BigInt(5),
        ap = BigInt(8);
      BigInt(9), BigInt(16);
      function Vn(n, e) {
        const t = n % e;
        return t >= xn ? t : e + t;
      }
      function vw(n, e, t) {
        if (t <= xn || e < xn) throw new Error("Expected power/modulo > 0");
        if (t === fn) return xn;
        let r = fn;
        for (; e > xn;) e & fn && (r = r * n % t), n = n * n % t, e >>= fn;
        return r;
      }
      function hr(n, e, t) {
        let r = n;
        for (; e-- > xn;) r *= r, r %= t;
        return r;
      }
      function l0(n, e) {
        if (n === xn || e <= xn) throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);
        let t = Vn(n, e),
          r = e,
          i = xn,
          a = fn;
        for (; t !== xn;) {
          const s = r / t,
            o = r % t,
            c = i - a * s;
          r = t, t = o, i = a, a = c;
        }
        if (r !== fn) throw new Error("invert: does not exist");
        return Vn(i, e);
      }
      function yw(n) {
        const e = (n - fn) / Co;
        let t, r, i;
        for (t = n - fn, r = 0; t % Co === xn; t /= Co, r++);
        for (i = Co; i < n && vw(i, e, n) !== n - fn; i++);
        if (r === 1) {
          const l = (n + fn) / c0;
          return function (o, c) {
            const u = o.pow(c, l);
            if (!o.eql(o.sqr(u), c)) throw new Error("Cannot find square root");
            return u;
          };
        }
        const a = (t + fn) / Co;
        return function (s, o) {
          if (s.pow(o, e) === s.neg(s.ONE)) throw new Error("Cannot find square root");
          let c = r,
            u = s.pow(s.mul(s.ONE, i), t),
            f = s.pow(o, a),
            d = s.pow(o, t);
          for (; !s.eql(d, s.ONE);) {
            if (s.eql(d, s.ZERO)) return s.ZERO;
            let p = 1;
            for (let h = s.sqr(d); p < c && !s.eql(h, s.ONE); p++) h = s.sqr(h);
            const v = s.pow(u, fn << BigInt(c - p - 1));
            u = s.sqr(v), f = s.mul(f, v), d = s.mul(d, u), c = p;
          }
          return f;
        };
      }
      function mw(n) {
        if (n % c0 === gw) {
          const e = (n + fn) / c0;
          return function (r, i) {
            const a = r.pow(i, e);
            if (!r.eql(r.sqr(a), i)) throw new Error("Cannot find square root");
            return a;
          };
        }
        if (n % ap === sp) {
          const e = (n - sp) / ap;
          return function (r, i) {
            const a = r.mul(i, Co),
              l = r.pow(a, e),
              s = r.mul(i, l),
              o = r.mul(r.mul(s, Co), l),
              c = r.mul(s, r.sub(o, r.ONE));
            if (!r.eql(r.sqr(c), i)) throw new Error("Cannot find square root");
            return c;
          };
        }
        return yw(n);
      }
      const bw = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
      function ww(n) {
        const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
          },
          t = bw.reduce((r, i) => (r[i] = "function", r), e);
        return Dc(n, t);
      }
      function xw(n, e, t) {
        if (t < xn) throw new Error("Expected power > 0");
        if (t === xn) return n.ONE;
        if (t === fn) return e;
        let r = n.ONE,
          i = e;
        for (; t > xn;) t & fn && (r = n.mul(r, i)), i = n.sqr(i), t >>= fn;
        return r;
      }
      function _w(n, e) {
        const t = new Array(e.length),
          r = e.reduce((a, l, s) => n.is0(l) ? a : (t[s] = a, n.mul(a, l)), n.ONE),
          i = n.inv(r);
        return e.reduceRight((a, l, s) => n.is0(l) ? a : (t[s] = n.mul(a, t[s]), n.mul(a, l)), i), t;
      }
      function cp(n, e) {
        const t = e !== void 0 ? e : n.toString(2).length,
          r = Math.ceil(t / 8);
        return {
          nBitLength: t,
          nByteLength: r
        };
      }
      function Ew(n, e, t = !1, r = {}) {
        if (n <= xn) throw new Error(`Expected Field ORDER > 0, got ${n}`);
        const {
          nBitLength: i,
          nByteLength: a
        } = cp(n, e);
        if (a > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
        const l = mw(n),
          s = Object.freeze({
            ORDER: n,
            BITS: i,
            BYTES: a,
            MASK: s0(i),
            ZERO: xn,
            ONE: fn,
            create: o => Vn(o, n),
            isValid: o => {
              if (typeof o != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof o}`);
              return xn <= o && o < n;
            },
            is0: o => o === xn,
            isOdd: o => (o & fn) === fn,
            neg: o => Vn(-o, n),
            eql: (o, c) => o === c,
            sqr: o => Vn(o * o, n),
            add: (o, c) => Vn(o + c, n),
            sub: (o, c) => Vn(o - c, n),
            mul: (o, c) => Vn(o * c, n),
            pow: (o, c) => xw(s, o, c),
            div: (o, c) => Vn(o * l0(c, n), n),
            sqrN: o => o * o,
            addN: (o, c) => o + c,
            subN: (o, c) => o - c,
            mulN: (o, c) => o * c,
            inv: o => l0(o, n),
            sqrt: r.sqrt || (o => l(s, o)),
            invertBatch: o => _w(s, o),
            cmov: (o, c, u) => u ? c : o,
            toBytes: o => t ? o0(o, a) : ya(o, a),
            fromBytes: o => {
              if (o.length !== a) throw new Error(`Fp.fromBytes: expected ${a}, got ${o.length}`);
              return t ? i0(o) : Eo(o);
            }
          });
        return Object.freeze(s);
      }
      function lp(n) {
        if (typeof n != "bigint") throw new Error("field order must be bigint");
        const e = n.toString(2).length;
        return Math.ceil(e / 8);
      }
      function up(n) {
        const e = lp(n);
        return e + Math.ceil(e / 2);
      }
      function Cw(n, e, t = !1) {
        const r = n.length,
          i = lp(e),
          a = up(e);
        if (r < 16 || r < a || r > 1024) throw new Error(`expected ${a}-1024 bytes of input, got ${r}`);
        const l = t ? Eo(n) : i0(n),
          s = Vn(l, e - fn) + fn;
        return t ? o0(s, i) : ya(s, i);
      } /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const Ow = BigInt(0),
        u0 = BigInt(1);
      function Aw(n, e) {
        const t = (i, a) => {
            const l = a.negate();
            return i ? l : a;
          },
          r = i => {
            const a = Math.ceil(e / i) + 1,
              l = 2 ** (i - 1);
            return {
              windows: a,
              windowSize: l
            };
          };
        return {
          constTimeNegate: t,
          unsafeLadder(i, a) {
            let l = n.ZERO,
              s = i;
            for (; a > Ow;) a & u0 && (l = l.add(s)), s = s.double(), a >>= u0;
            return l;
          },
          precomputeWindow(i, a) {
            const {
                windows: l,
                windowSize: s
              } = r(a),
              o = [];
            let c = i,
              u = c;
            for (let f = 0; f < l; f++) {
              u = c, o.push(u);
              for (let d = 1; d < s; d++) u = u.add(c), o.push(u);
              c = u.double();
            }
            return o;
          },
          wNAF(i, a, l) {
            const {
              windows: s,
              windowSize: o
            } = r(i);
            let c = n.ZERO,
              u = n.BASE;
            const f = BigInt(2 ** i - 1),
              d = 2 ** i,
              p = BigInt(i);
            for (let v = 0; v < s; v++) {
              const h = v * o;
              let g = Number(l & f);
              l >>= p, g > o && (g -= d, l += u0);
              const b = h,
                m = h + Math.abs(g) - 1,
                _ = v % 2 !== 0,
                N = g < 0;
              g === 0 ? u = u.add(t(_, a[b])) : c = c.add(t(N, a[m]));
            }
            return {
              p: c,
              f: u
            };
          },
          wNAFCached(i, a, l, s) {
            const o = i._WINDOW_SIZE || 1;
            let c = a.get(i);
            return c || (c = this.precomputeWindow(i, o), o !== 1 && a.set(i, s(c))), this.wNAF(o, c, l);
          }
        };
      }
      function fp(n) {
        return ww(n.Fp), Dc(n, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        }), Object.freeze({
          ...cp(n.n, n.nBitLength),
          ...n,
          p: n.Fp.ORDER
        });
      } /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      function Rw(n) {
        const e = fp(n);
        Dc(e, {
          a: "field",
          b: "field"
        }, {
          allowedPrivateKeyLengths: "array",
          wrapPrivateKey: "boolean",
          isTorsionFree: "function",
          clearCofactor: "function",
          allowInfinityPoint: "boolean",
          fromBytes: "function",
          toBytes: "function"
        });
        const {
          endo: t,
          Fp: r,
          a: i
        } = e;
        if (t) {
          if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
          if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
        return Object.freeze({
          ...e
        });
      }
      const {
          bytesToNumberBE: Nw,
          hexToBytes: Sw
        } = pw,
        Oo = {
          Err: class extends Error {
            constructor(e = "") {
              super(e);
            }
          },
          _parseInt(n) {
            const {
              Err: e
            } = Oo;
            if (n.length < 2 || n[0] !== 2) throw new e("Invalid signature integer tag");
            const t = n[1],
              r = n.subarray(2, t + 2);
            if (!t || r.length !== t) throw new e("Invalid signature integer: wrong length");
            if (r[0] & 128) throw new e("Invalid signature integer: negative");
            if (r[0] === 0 && !(r[1] & 128)) throw new e("Invalid signature integer: unnecessary leading zero");
            return {
              d: Nw(r),
              l: n.subarray(t + 2)
            };
          },
          toSig(n) {
            const {
                Err: e
              } = Oo,
              t = typeof n == "string" ? Sw(n) : n;
            if (!(t instanceof Uint8Array)) throw new Error("ui8a expected");
            let r = t.length;
            if (r < 2 || t[0] != 48) throw new e("Invalid signature tag");
            if (t[1] !== r - 2) throw new e("Invalid signature: incorrect length");
            const {
                d: i,
                l: a
              } = Oo._parseInt(t.subarray(2)),
              {
                d: l,
                l: s
              } = Oo._parseInt(a);
            if (s.length) throw new e("Invalid signature: left bytes after parsing");
            return {
              r: i,
              s: l
            };
          },
          hexFromSig(n) {
            const e = c => Number.parseInt(c[0], 16) & 8 ? "00" + c : c,
              t = c => {
                const u = c.toString(16);
                return u.length & 1 ? `0${u}` : u;
              },
              r = e(t(n.s)),
              i = e(t(n.r)),
              a = r.length / 2,
              l = i.length / 2,
              s = t(a),
              o = t(l);
            return `30${t(l + a + 4)}02${o}${i}02${s}${r}`;
          }
        },
        si = BigInt(0),
        pr = BigInt(1);
      BigInt(2);
      const dp = BigInt(3);
      BigInt(4);
      function Tw(n) {
        const e = Rw(n),
          {
            Fp: t
          } = e,
          r = e.toBytes || ((v, h, g) => {
            const b = h.toAffine();
            return Tc(Uint8Array.from([4]), t.toBytes(b.x), t.toBytes(b.y));
          }),
          i = e.fromBytes || (v => {
            const h = v.subarray(1),
              g = t.fromBytes(h.subarray(0, t.BYTES)),
              b = t.fromBytes(h.subarray(t.BYTES, 2 * t.BYTES));
            return {
              x: g,
              y: b
            };
          });
        function a(v) {
          const {
              a: h,
              b: g
            } = e,
            b = t.sqr(v),
            m = t.mul(b, v);
          return t.add(t.add(m, t.mul(v, h)), g);
        }
        if (!t.eql(t.sqr(e.Gy), a(e.Gx))) throw new Error("bad generator point: equation left != right");
        function l(v) {
          return typeof v == "bigint" && si < v && v < e.n;
        }
        function s(v) {
          if (!l(v)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
        }
        function o(v) {
          const {
            allowedPrivateKeyLengths: h,
            nByteLength: g,
            wrapPrivateKey: b,
            n: m
          } = e;
          if (h && typeof v != "bigint") {
            if (v instanceof Uint8Array && (v = ga(v)), typeof v != "string" || !h.includes(v.length)) throw new Error("Invalid key");
            v = v.padStart(g * 2, "0");
          }
          let _;
          try {
            _ = typeof v == "bigint" ? v : Eo(Ar("private key", v, g));
          } catch {
            throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof v}`);
          }
          return b && (_ = Vn(_, m)), s(_), _;
        }
        const c = new Map();
        function u(v) {
          if (!(v instanceof f)) throw new Error("ProjectivePoint expected");
        }
        class f {
          constructor(h, g, b) {
            if (this.px = h, this.py = g, this.pz = b, h == null || !t.isValid(h)) throw new Error("x required");
            if (g == null || !t.isValid(g)) throw new Error("y required");
            if (b == null || !t.isValid(b)) throw new Error("z required");
          }
          static fromAffine(h) {
            const {
              x: g,
              y: b
            } = h || {};
            if (!h || !t.isValid(g) || !t.isValid(b)) throw new Error("invalid affine point");
            if (h instanceof f) throw new Error("projective point not allowed");
            const m = _ => t.eql(_, t.ZERO);
            return m(g) && m(b) ? f.ZERO : new f(g, b, t.ONE);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          static normalizeZ(h) {
            const g = t.invertBatch(h.map(b => b.pz));
            return h.map((b, m) => b.toAffine(g[m])).map(f.fromAffine);
          }
          static fromHex(h) {
            const g = f.fromAffine(i(Ar("pointHex", h)));
            return g.assertValidity(), g;
          }
          static fromPrivateKey(h) {
            return f.BASE.multiply(o(h));
          }
          _setWindowSize(h) {
            this._WINDOW_SIZE = h, c.delete(this);
          }
          assertValidity() {
            if (this.is0()) {
              if (e.allowInfinityPoint && !t.is0(this.py)) return;
              throw new Error("bad point: ZERO");
            }
            const {
              x: h,
              y: g
            } = this.toAffine();
            if (!t.isValid(h) || !t.isValid(g)) throw new Error("bad point: x or y not FE");
            const b = t.sqr(g),
              m = a(h);
            if (!t.eql(b, m)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
          }
          hasEvenY() {
            const {
              y: h
            } = this.toAffine();
            if (t.isOdd) return !t.isOdd(h);
            throw new Error("Field doesn't support isOdd");
          }
          equals(h) {
            u(h);
            const {
                px: g,
                py: b,
                pz: m
              } = this,
              {
                px: _,
                py: N,
                pz: O
              } = h,
              y = t.eql(t.mul(g, O), t.mul(_, m)),
              w = t.eql(t.mul(b, O), t.mul(N, m));
            return y && w;
          }
          negate() {
            return new f(this.px, t.neg(this.py), this.pz);
          }
          double() {
            const {
                a: h,
                b: g
              } = e,
              b = t.mul(g, dp),
              {
                px: m,
                py: _,
                pz: N
              } = this;
            let O = t.ZERO,
              y = t.ZERO,
              w = t.ZERO,
              A = t.mul(m, m),
              R = t.mul(_, _),
              T = t.mul(N, N),
              D = t.mul(m, _);
            return D = t.add(D, D), w = t.mul(m, N), w = t.add(w, w), O = t.mul(h, w), y = t.mul(b, T), y = t.add(O, y), O = t.sub(R, y), y = t.add(R, y), y = t.mul(O, y), O = t.mul(D, O), w = t.mul(b, w), T = t.mul(h, T), D = t.sub(A, T), D = t.mul(h, D), D = t.add(D, w), w = t.add(A, A), A = t.add(w, A), A = t.add(A, T), A = t.mul(A, D), y = t.add(y, A), T = t.mul(_, N), T = t.add(T, T), A = t.mul(T, D), O = t.sub(O, A), w = t.mul(T, R), w = t.add(w, w), w = t.add(w, w), new f(O, y, w);
          }
          add(h) {
            u(h);
            const {
                px: g,
                py: b,
                pz: m
              } = this,
              {
                px: _,
                py: N,
                pz: O
              } = h;
            let y = t.ZERO,
              w = t.ZERO,
              A = t.ZERO;
            const R = e.a,
              T = t.mul(e.b, dp);
            let D = t.mul(g, _),
              M = t.mul(b, N),
              q = t.mul(m, O),
              W = t.add(g, b),
              x = t.add(_, N);
            W = t.mul(W, x), x = t.add(D, M), W = t.sub(W, x), x = t.add(g, m);
            let C = t.add(_, O);
            return x = t.mul(x, C), C = t.add(D, q), x = t.sub(x, C), C = t.add(b, m), y = t.add(N, O), C = t.mul(C, y), y = t.add(M, q), C = t.sub(C, y), A = t.mul(R, x), y = t.mul(T, q), A = t.add(y, A), y = t.sub(M, A), A = t.add(M, A), w = t.mul(y, A), M = t.add(D, D), M = t.add(M, D), q = t.mul(R, q), x = t.mul(T, x), M = t.add(M, q), q = t.sub(D, q), q = t.mul(R, q), x = t.add(x, q), D = t.mul(M, x), w = t.add(w, D), D = t.mul(C, x), y = t.mul(W, y), y = t.sub(y, D), D = t.mul(W, M), A = t.mul(C, A), A = t.add(A, D), new f(y, w, A);
          }
          subtract(h) {
            return this.add(h.negate());
          }
          is0() {
            return this.equals(f.ZERO);
          }
          wNAF(h) {
            return p.wNAFCached(this, c, h, g => {
              const b = t.invertBatch(g.map(m => m.pz));
              return g.map((m, _) => m.toAffine(b[_])).map(f.fromAffine);
            });
          }
          multiplyUnsafe(h) {
            const g = f.ZERO;
            if (h === si) return g;
            if (s(h), h === pr) return this;
            const {
              endo: b
            } = e;
            if (!b) return p.unsafeLadder(this, h);
            let {
                k1neg: m,
                k1: _,
                k2neg: N,
                k2: O
              } = b.splitScalar(h),
              y = g,
              w = g,
              A = this;
            for (; _ > si || O > si;) _ & pr && (y = y.add(A)), O & pr && (w = w.add(A)), A = A.double(), _ >>= pr, O >>= pr;
            return m && (y = y.negate()), N && (w = w.negate()), w = new f(t.mul(w.px, b.beta), w.py, w.pz), y.add(w);
          }
          multiply(h) {
            s(h);
            let g = h,
              b,
              m;
            const {
              endo: _
            } = e;
            if (_) {
              const {
                k1neg: N,
                k1: O,
                k2neg: y,
                k2: w
              } = _.splitScalar(g);
              let {
                  p: A,
                  f: R
                } = this.wNAF(O),
                {
                  p: T,
                  f: D
                } = this.wNAF(w);
              A = p.constTimeNegate(N, A), T = p.constTimeNegate(y, T), T = new f(t.mul(T.px, _.beta), T.py, T.pz), b = A.add(T), m = R.add(D);
            } else {
              const {
                p: N,
                f: O
              } = this.wNAF(g);
              b = N, m = O;
            }
            return f.normalizeZ([b, m])[0];
          }
          multiplyAndAddUnsafe(h, g, b) {
            const m = f.BASE,
              _ = (O, y) => y === si || y === pr || !O.equals(m) ? O.multiplyUnsafe(y) : O.multiply(y),
              N = _(this, g).add(_(h, b));
            return N.is0() ? void 0 : N;
          }
          toAffine(h) {
            const {
                px: g,
                py: b,
                pz: m
              } = this,
              _ = this.is0();
            h == null && (h = _ ? t.ONE : t.inv(m));
            const N = t.mul(g, h),
              O = t.mul(b, h),
              y = t.mul(m, h);
            if (_) return {
              x: t.ZERO,
              y: t.ZERO
            };
            if (!t.eql(y, t.ONE)) throw new Error("invZ was invalid");
            return {
              x: N,
              y: O
            };
          }
          isTorsionFree() {
            const {
              h,
              isTorsionFree: g
            } = e;
            if (h === pr) return !0;
            if (g) return g(f, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
          }
          clearCofactor() {
            const {
              h,
              clearCofactor: g
            } = e;
            return h === pr ? this : g ? g(f, this) : this.multiplyUnsafe(e.h);
          }
          toRawBytes(h = !0) {
            return this.assertValidity(), r(f, this, h);
          }
          toHex(h = !0) {
            return ga(this.toRawBytes(h));
          }
        }
        f.BASE = new f(e.Gx, e.Gy, t.ONE), f.ZERO = new f(t.ZERO, t.ONE, t.ZERO);
        const d = e.nBitLength,
          p = Aw(f, e.endo ? Math.ceil(d / 2) : d);
        return {
          CURVE: e,
          ProjectivePoint: f,
          normPrivateKeyToScalar: o,
          weierstrassEquation: a,
          isWithinCurveOrder: l
        };
      }
      function Dw(n) {
        const e = fp(n);
        return Dc(e, {
          hash: "hash",
          hmac: "function",
          randomBytes: "function"
        }, {
          bits2int: "function",
          bits2int_modN: "function",
          lowS: "boolean"
        }), Object.freeze({
          lowS: !0,
          ...e
        });
      }
      function Pw(n) {
        const e = Dw(n),
          {
            Fp: t,
            n: r
          } = e,
          i = t.BYTES + 1,
          a = 2 * t.BYTES + 1;
        function l(x) {
          return si < x && x < t.ORDER;
        }
        function s(x) {
          return Vn(x, r);
        }
        function o(x) {
          return l0(x, r);
        }
        const {
            ProjectivePoint: c,
            normPrivateKeyToScalar: u,
            weierstrassEquation: f,
            isWithinCurveOrder: d
          } = Tw({
            ...e,
            toBytes(x, C, B) {
              const X = C.toAffine(),
                J = t.toBytes(X.x),
                V = Tc;
              return B ? V(Uint8Array.from([C.hasEvenY() ? 2 : 3]), J) : V(Uint8Array.from([4]), J, t.toBytes(X.y));
            },
            fromBytes(x) {
              const C = x.length,
                B = x[0],
                X = x.subarray(1);
              if (C === i && (B === 2 || B === 3)) {
                const J = Eo(X);
                if (!l(J)) throw new Error("Point is not on curve");
                const V = f(J);
                let $ = t.sqrt(V);
                const se = ($ & pr) === pr;
                return (B & 1) === 1 !== se && ($ = t.neg($)), {
                  x: J,
                  y: $
                };
              } else if (C === a && B === 4) {
                const J = t.fromBytes(X.subarray(0, t.BYTES)),
                  V = t.fromBytes(X.subarray(t.BYTES, 2 * t.BYTES));
                return {
                  x: J,
                  y: V
                };
              } else throw new Error(`Point of length ${C} was invalid. Expected ${i} compressed bytes or ${a} uncompressed bytes`);
            }
          }),
          p = x => ga(ya(x, e.nByteLength));
        function v(x) {
          const C = r >> pr;
          return x > C;
        }
        function h(x) {
          return v(x) ? s(-x) : x;
        }
        const g = (x, C, B) => Eo(x.slice(C, B));
        class b {
          constructor(C, B, X) {
            this.r = C, this.s = B, this.recovery = X, this.assertValidity();
          }
          static fromCompact(C) {
            const B = e.nByteLength;
            return C = Ar("compactSignature", C, B * 2), new b(g(C, 0, B), g(C, B, 2 * B));
          }
          static fromDER(C) {
            const {
              r: B,
              s: X
            } = Oo.toSig(Ar("DER", C));
            return new b(B, X);
          }
          assertValidity() {
            if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n");
          }
          addRecoveryBit(C) {
            return new b(this.r, this.s, C);
          }
          recoverPublicKey(C) {
            const {
                r: B,
                s: X,
                recovery: J
              } = this,
              V = w(Ar("msgHash", C));
            if (J == null || ![0, 1, 2, 3].includes(J)) throw new Error("recovery id invalid");
            const $ = J === 2 || J === 3 ? B + e.n : B;
            if ($ >= t.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const se = (J & 1) === 0 ? "02" : "03",
              ne = c.fromHex(se + p($)),
              oe = o($),
              ye = s(-V * oe),
              Te = s(X * oe),
              ae = c.BASE.multiplyAndAddUnsafe(ne, ye, Te);
            if (!ae) throw new Error("point at infinify");
            return ae.assertValidity(), ae;
          }
          hasHighS() {
            return v(this.s);
          }
          normalizeS() {
            return this.hasHighS() ? new b(this.r, s(-this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return va(this.toDERHex());
          }
          toDERHex() {
            return Oo.hexFromSig({
              r: this.r,
              s: this.s
            });
          }
          toCompactRawBytes() {
            return va(this.toCompactHex());
          }
          toCompactHex() {
            return p(this.r) + p(this.s);
          }
        }
        const m = {
          isValidPrivateKey(x) {
            try {
              return u(x), !0;
            } catch {
              return !1;
            }
          },
          normPrivateKeyToScalar: u,
          randomPrivateKey: () => {
            const x = up(e.n);
            return Cw(e.randomBytes(x), e.n);
          },
          precompute(x = 8, C = c.BASE) {
            return C._setWindowSize(x), C.multiply(BigInt(3)), C;
          }
        };
        function _(x, C = !0) {
          return c.fromPrivateKey(x).toRawBytes(C);
        }
        function N(x) {
          const C = x instanceof Uint8Array,
            B = typeof x == "string",
            X = (C || B) && x.length;
          return C ? X === i || X === a : B ? X === 2 * i || X === 2 * a : x instanceof c;
        }
        function O(x, C, B = !0) {
          if (N(x)) throw new Error("first arg must be private key");
          if (!N(C)) throw new Error("second arg must be public key");
          return c.fromHex(C).multiply(u(x)).toRawBytes(B);
        }
        const y = e.bits2int || function (x) {
            const C = Eo(x),
              B = x.length * 8 - e.nBitLength;
            return B > 0 ? C >> BigInt(B) : C;
          },
          w = e.bits2int_modN || function (x) {
            return s(y(x));
          },
          A = s0(e.nBitLength);
        function R(x) {
          if (typeof x != "bigint") throw new Error("bigint expected");
          if (!(si <= x && x < A)) throw new Error(`bigint expected < 2^${e.nBitLength}`);
          return ya(x, e.nByteLength);
        }
        function T(x, C, B = D) {
          if (["recovered", "canonical"].some(Z => Z in B)) throw new Error("sign() legacy options not supported");
          const {
            hash: X,
            randomBytes: J
          } = e;
          let {
            lowS: V,
            prehash: $,
            extraEntropy: se
          } = B;
          V == null && (V = !0), x = Ar("msgHash", x), $ && (x = Ar("prehashed msgHash", X(x)));
          const ne = w(x),
            oe = u(C),
            ye = [R(oe), R(ne)];
          if (se != null) {
            const Z = se === !0 ? J(t.BYTES) : se;
            ye.push(Ar("extraEntropy", Z));
          }
          const Te = Tc(...ye),
            ae = ne;
          function G(Z) {
            const S = y(Z);
            if (!d(S)) return;
            const ee = o(S),
              Ce = c.BASE.multiply(S).toAffine(),
              Oe = s(Ce.x);
            if (Oe === si) return;
            const Xe = s(ee * s(ae + Oe * oe));
            if (Xe === si) return;
            let Ve = (Ce.x === Oe ? 0 : 2) | Number(Ce.y & pr),
              at = Xe;
            return V && v(Xe) && (at = h(Xe), Ve ^= 1), new b(Oe, at, Ve);
          }
          return {
            seed: Te,
            k2sig: G
          };
        }
        const D = {
            lowS: e.lowS,
            prehash: !1
          },
          M = {
            lowS: e.lowS,
            prehash: !1
          };
        function q(x, C, B = D) {
          const {
              seed: X,
              k2sig: J
            } = T(x, C, B),
            V = e;
          return op(V.hash.outputLen, V.nByteLength, V.hmac)(X, J);
        }
        c.BASE._setWindowSize(8);
        function W(x, C, B, X = M) {
          var Ce;
          const J = x;
          if (C = Ar("msgHash", C), B = Ar("publicKey", B), "strict" in X) throw new Error("options.strict was renamed to lowS");
          const {
            lowS: V,
            prehash: $
          } = X;
          let se, ne;
          try {
            if (typeof J == "string" || J instanceof Uint8Array) try {
              se = b.fromDER(J);
            } catch (Oe) {
              if (!(Oe instanceof Oo.Err)) throw Oe;
              se = b.fromCompact(J);
            } else if (typeof J == "object" && typeof J.r == "bigint" && typeof J.s == "bigint") {
              const {
                r: Oe,
                s: Xe
              } = J;
              se = new b(Oe, Xe);
            } else throw new Error("PARSE");
            ne = c.fromHex(B);
          } catch (Oe) {
            if (Oe.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1;
          }
          if (V && se.hasHighS()) return !1;
          $ && (C = e.hash(C));
          const {
              r: oe,
              s: ye
            } = se,
            Te = w(C),
            ae = o(ye),
            G = s(Te * ae),
            Z = s(oe * ae),
            S = (Ce = c.BASE.multiplyAndAddUnsafe(ne, G, Z)) == null ? void 0 : Ce.toAffine();
          return S ? s(S.x) === oe : !1;
        }
        return {
          CURVE: e,
          getPublicKey: _,
          getSharedSecret: O,
          sign: q,
          verify: W,
          ProjectivePoint: c,
          Signature: b,
          utils: m
        };
      } /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      function Iw(n) {
        return {
          hash: n,
          hmac: (e, ...t) => kh(n, e, R1(...t)),
          randomBytes: N1
        };
      }
      function Bw(n, e) {
        const t = r => Pw({
          ...n,
          ...Iw(r)
        });
        return Object.freeze({
          ...t(e),
          create: t
        });
      } /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
      const hp = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        pp = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        kw = BigInt(1),
        f0 = BigInt(2),
        gp = (n, e) => (n + e / f0) / e;
      function Mw(n) {
        const e = hp,
          t = BigInt(3),
          r = BigInt(6),
          i = BigInt(11),
          a = BigInt(22),
          l = BigInt(23),
          s = BigInt(44),
          o = BigInt(88),
          c = n * n * n % e,
          u = c * c * n % e,
          f = hr(u, t, e) * u % e,
          d = hr(f, t, e) * u % e,
          p = hr(d, f0, e) * c % e,
          v = hr(p, i, e) * p % e,
          h = hr(v, a, e) * v % e,
          g = hr(h, s, e) * h % e,
          b = hr(g, o, e) * g % e,
          m = hr(b, s, e) * h % e,
          _ = hr(m, t, e) * u % e,
          N = hr(_, l, e) * v % e,
          O = hr(N, r, e) * c % e,
          y = hr(O, f0, e);
        if (!d0.eql(d0.sqr(y), n)) throw new Error("Cannot find square root");
        return y;
      }
      const d0 = Ew(hp, void 0, void 0, {
          sqrt: Mw
        }),
        Hi = Bw({
          a: BigInt(0),
          b: BigInt(7),
          Fp: d0,
          n: pp,
          Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
          Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
          h: BigInt(1),
          lowS: !0,
          endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: n => {
              const e = pp,
                t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                r = -kw * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                a = t,
                l = BigInt("0x100000000000000000000000000000000"),
                s = gp(a * n, e),
                o = gp(-r * n, e);
              let c = Vn(n - s * t - o * i, e),
                u = Vn(-s * r - o * a, e);
              const f = c > l,
                d = u > l;
              if (f && (c = e - c), d && (u = e - u), c > l || u > l) throw new Error("splitScalar: Endomorphism failed, k=" + n);
              return {
                k1neg: f,
                k1: c,
                k2neg: d,
                k2: u
              };
            }
          }
        }, Kh);
      BigInt(0), Hi.ProjectivePoint;
      const Pc = "0x0000000000000000000000000000000000000000",
        vp = "0x0000000000000000000000000000000000000000000000000000000000000000",
        yp = BigInt(0),
        mp = BigInt(1),
        bp = BigInt(2),
        wp = BigInt(27),
        xp = BigInt(28),
        zl = BigInt(35),
        ma = {};
      function _p(n) {
        return ri(wn(n), 32);
      }
      const kr = class kr {
        constructor(e, t, r, i) {
          de(this, Wa);
          de(this, Jr);
          de(this, Xa);
          de(this, qs);
          Oc(e, ma, "Signature"), z(this, Wa, t), z(this, Jr, r), z(this, Xa, i), z(this, qs, null);
        }
        get r() {
          return k(this, Wa);
        }
        set r(e) {
          re(aa(e) === 32, "invalid r", "value", e), z(this, Wa, Se(e));
        }
        get s() {
          return re(parseInt(k(this, Jr).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", k(this, Jr)), k(this, Jr);
        }
        set s(e) {
          re(aa(e) === 32, "invalid s", "value", e), z(this, Jr, Se(e));
        }
        get _s() {
          return k(this, Jr);
        }
        isValid() {
          return parseInt(k(this, Jr).substring(0, 3)) < 8;
        }
        get v() {
          return k(this, Xa);
        }
        set v(e) {
          const t = ct(e, "value");
          re(t === 27 || t === 28, "invalid v", "v", e), z(this, Xa, t);
        }
        get networkV() {
          return k(this, qs);
        }
        get legacyChainId() {
          const e = this.networkV;
          return e == null ? null : kr.getChainId(e);
        }
        get yParity() {
          return this.v === 27 ? 0 : 1;
        }
        get yParityAndS() {
          const e = ft(this.s);
          return this.yParity && (e[0] |= 128), Se(e);
        }
        get compactSerialized() {
          return sn([this.r, this.yParityAndS]);
        }
        get serialized() {
          return sn([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`;
        }
        clone() {
          const e = new kr(ma, this.r, this._s, this.v);
          return this.networkV && z(e, qs, this.networkV), e;
        }
        toJSON() {
          const e = this.networkV;
          return {
            _type: "signature",
            networkV: e != null ? e.toString() : null,
            r: this.r,
            s: this._s,
            v: this.v
          };
        }
        static getChainId(e) {
          const t = Le(e, "v");
          return t == wp || t == xp ? yp : (re(t >= zl, "invalid EIP-155 v", "v", e), (t - zl) / bp);
        }
        static getChainIdV(e, t) {
          return Le(e) * bp + BigInt(35 + t - 27);
        }
        static getNormalizedV(e) {
          const t = Le(e);
          return t === yp || t === wp ? 27 : t === mp || t === xp ? 28 : (re(t >= zl, "invalid v", "v", e), t & mp ? 27 : 28);
        }
        static from(e) {
          function t(c, u) {
            re(c, u, "signature", e);
          }
          if (e == null) return new kr(ma, vp, vp, 27);
          if (typeof e == "string") {
            const c = ft(e, "signature");
            if (c.length === 64) {
              const u = Se(c.slice(0, 32)),
                f = c.slice(32, 64),
                d = f[0] & 128 ? 28 : 27;
              return f[0] &= 127, new kr(ma, u, Se(f), d);
            }
            if (c.length === 65) {
              const u = Se(c.slice(0, 32)),
                f = Se(c.slice(32, 64)),
                d = kr.getNormalizedV(c[64]);
              return new kr(ma, u, f, d);
            }
            t(!1, "invalid raw signature length");
          }
          if (e instanceof kr) return e.clone();
          const r = e.r;
          t(r != null, "missing r");
          const i = _p(r),
            a = function (c, u) {
              if (c != null) return _p(c);
              if (u != null) {
                t(Xt(u, 32), "invalid yParityAndS");
                const f = ft(u);
                return f[0] &= 127, Se(f);
              }
              t(!1, "missing s");
            }(e.s, e.yParityAndS),
            {
              networkV: l,
              v: s
            } = function (c, u, f) {
              if (c != null) {
                const d = Le(c);
                return {
                  networkV: d >= zl ? d : void 0,
                  v: kr.getNormalizedV(d)
                };
              }
              if (u != null) return t(Xt(u, 32), "invalid yParityAndS"), {
                v: ft(u)[0] & 128 ? 28 : 27
              };
              if (f != null) {
                switch (ct(f, "sig.yParity")) {
                  case 0:
                    return {
                      v: 27
                    };
                  case 1:
                    return {
                      v: 28
                    };
                }
                t(!1, "invalid yParity");
              }
              t(!1, "missing v");
            }(e.v, e.yParityAndS, e.yParity),
            o = new kr(ma, i, a, s);
          return l && z(o, qs, l), t(e.yParity == null || ct(e.yParity, "sig.yParity") === o.yParity, "yParity mismatch"), t(e.yParityAndS == null || e.yParityAndS === o.yParityAndS, "yParityAndS mismatch"), o;
        }
      };
      Wa = new WeakMap(), Jr = new WeakMap(), Xa = new WeakMap(), qs = new WeakMap();
      let zn = kr;
      const Js = class Js {
        constructor(e) {
          de(this, _i);
          re(aa(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), z(this, _i, Se(e));
        }
        get privateKey() {
          return k(this, _i);
        }
        get publicKey() {
          return Js.computePublicKey(k(this, _i));
        }
        get compressedPublicKey() {
          return Js.computePublicKey(k(this, _i), !0);
        }
        sign(e) {
          re(aa(e) === 32, "invalid digest length", "digest", e);
          const t = Hi.sign(Fn(e), Fn(k(this, _i)), {
            lowS: !0
          });
          return zn.from({
            r: Ii(t.r, 32),
            s: Ii(t.s, 32),
            v: t.recovery ? 28 : 27
          });
        }
        computeSharedSecret(e) {
          const t = Js.computePublicKey(e);
          return Se(Hi.getSharedSecret(Fn(k(this, _i)), ft(t), !1));
        }
        static computePublicKey(e, t) {
          let r = ft(e, "key");
          if (r.length === 32) {
            const a = Hi.getPublicKey(r, !!t);
            return Se(a);
          }
          if (r.length === 64) {
            const a = new Uint8Array(65);
            a[0] = 4, a.set(r, 1), r = a;
          }
          const i = Hi.ProjectivePoint.fromHex(r);
          return Se(i.toRawBytes(t));
        }
        static recoverPublicKey(e, t) {
          re(aa(e) === 32, "invalid digest length", "digest", e);
          const r = zn.from(t);
          let i = Hi.Signature.fromCompact(Fn(sn([r.r, r.s])));
          i = i.addRecoveryBit(r.yParity);
          const a = i.recoverPublicKey(Fn(e));
          return re(a != null, "invalid signature for digest", "signature", t), "0x" + a.toHex(!1);
        }
        static addPoints(e, t, r) {
          const i = Hi.ProjectivePoint.fromHex(Js.computePublicKey(e).substring(2)),
            a = Hi.ProjectivePoint.fromHex(Js.computePublicKey(t).substring(2));
          return "0x" + i.add(a).toHex(!!r);
        }
      };
      _i = new WeakMap();
      let Ic = Js;
      const Kw = BigInt(0),
        Lw = BigInt(36);
      function Ep(n) {
        n = n.toLowerCase();
        const e = n.substring(2).split(""),
          t = new Uint8Array(40);
        for (let i = 0; i < 40; i++) t[i] = e[i].charCodeAt(0);
        const r = ft(gn(t));
        for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
        return "0x" + e.join("");
      }
      const h0 = {};
      for (let n = 0; n < 10; n++) h0[String(n)] = String(n);
      for (let n = 0; n < 26; n++) h0[String.fromCharCode(65 + n)] = String(10 + n);
      const Cp = 15;
      function Uw(n) {
        n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
        let e = n.split("").map(r => h0[r]).join("");
        for (; e.length >= Cp;) {
          let r = e.substring(0, Cp);
          e = parseInt(r, 10) % 97 + e.substring(r.length);
        }
        let t = String(98 - parseInt(e, 10) % 97);
        for (; t.length < 2;) t = "0" + t;
        return t;
      }
      const Fw = function () {
        const n = {};
        for (let e = 0; e < 36; e++) {
          const t = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
          n[t] = BigInt(e);
        }
        return n;
      }();
      function Hw(n) {
        n = n.toLowerCase();
        let e = Kw;
        for (let t = 0; t < n.length; t++) e = e * Lw + Fw[n[t]];
        return e;
      }
      function Mt(n) {
        if (re(typeof n == "string", "invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
          n.startsWith("0x") || (n = "0x" + n);
          const e = Ep(n);
          return re(!n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === n, "bad address checksum", "address", n), e;
        }
        if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          re(n.substring(2, 4) === Uw(n), "bad icap checksum", "address", n);
          let e = Hw(n.substring(4)).toString(16);
          for (; e.length < 40;) e = "0" + e;
          return Ep("0x" + e);
        }
        re(!1, "invalid address", "address", n);
      }
      function jw(n) {
        const e = Mt(n.from);
        let r = Le(n.nonce, "tx.nonce").toString(16);
        return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, Mt(an(gn(Mi([e, r])), 12));
      }
      function Op(n) {
        return n && typeof n.getAddress == "function";
      }
      async function p0(n, e) {
        const t = await e;
        return (t == null || t === "0x0000000000000000000000000000000000000000") && (be(typeof n != "string", "unconfigured name", "UNCONFIGURED_NAME", {
          value: n
        }), re(!1, "invalid AddressLike value; did not resolve to a value address", "target", n)), Mt(t);
      }
      function jn(n, e) {
        if (typeof n == "string") return n.match(/^0x[0-9a-f]{40}$/i) ? Mt(n) : (be(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
          operation: "resolveName"
        }), p0(n, e.resolveName(n)));
        if (Op(n)) return p0(n, n.getAddress());
        if (n && typeof n.then == "function") return p0(n, n);
        re(!1, "unsupported addressable value", "target", n);
      }
      const ai = {};
      function Ue(n, e) {
        let t = !1;
        return e < 0 && (t = !0, e *= -1), new Bn(ai, `${t ? "" : "u"}int${e}`, n, {
          signed: t,
          width: e
        });
      }
      function Pt(n, e) {
        return new Bn(ai, `bytes${e || ""}`, n, {
          size: e
        });
      }
      const Ap = Symbol.for("_ethers_typed"),
        Ei = class Ei {
          constructor(e, t, r, i) {
            ce(this, "type");
            ce(this, "value");
            de(this, Gs);
            ce(this, "_typedSymbol");
            i == null && (i = null), Oc(ai, e, "Typed"), Ge(this, {
              _typedSymbol: Ap,
              type: t,
              value: r
            }), z(this, Gs, i), this.format();
          }
          format() {
            if (this.type === "array") throw new Error("");
            if (this.type === "dynamicArray") throw new Error("");
            return this.type === "tuple" ? `tuple(${this.value.map(e => e.format()).join(",")})` : this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return this.type === "string";
          }
          get tupleName() {
            if (this.type !== "tuple") throw TypeError("not a tuple");
            return k(this, Gs);
          }
          get arrayLength() {
            if (this.type !== "array") throw TypeError("not an array");
            return k(this, Gs) === !0 ? -1 : k(this, Gs) === !1 ? this.value.length : null;
          }
          static from(e, t) {
            return new Ei(ai, e, t);
          }
          static uint8(e) {
            return Ue(e, 8);
          }
          static uint16(e) {
            return Ue(e, 16);
          }
          static uint24(e) {
            return Ue(e, 24);
          }
          static uint32(e) {
            return Ue(e, 32);
          }
          static uint40(e) {
            return Ue(e, 40);
          }
          static uint48(e) {
            return Ue(e, 48);
          }
          static uint56(e) {
            return Ue(e, 56);
          }
          static uint64(e) {
            return Ue(e, 64);
          }
          static uint72(e) {
            return Ue(e, 72);
          }
          static uint80(e) {
            return Ue(e, 80);
          }
          static uint88(e) {
            return Ue(e, 88);
          }
          static uint96(e) {
            return Ue(e, 96);
          }
          static uint104(e) {
            return Ue(e, 104);
          }
          static uint112(e) {
            return Ue(e, 112);
          }
          static uint120(e) {
            return Ue(e, 120);
          }
          static uint128(e) {
            return Ue(e, 128);
          }
          static uint136(e) {
            return Ue(e, 136);
          }
          static uint144(e) {
            return Ue(e, 144);
          }
          static uint152(e) {
            return Ue(e, 152);
          }
          static uint160(e) {
            return Ue(e, 160);
          }
          static uint168(e) {
            return Ue(e, 168);
          }
          static uint176(e) {
            return Ue(e, 176);
          }
          static uint184(e) {
            return Ue(e, 184);
          }
          static uint192(e) {
            return Ue(e, 192);
          }
          static uint200(e) {
            return Ue(e, 200);
          }
          static uint208(e) {
            return Ue(e, 208);
          }
          static uint216(e) {
            return Ue(e, 216);
          }
          static uint224(e) {
            return Ue(e, 224);
          }
          static uint232(e) {
            return Ue(e, 232);
          }
          static uint240(e) {
            return Ue(e, 240);
          }
          static uint248(e) {
            return Ue(e, 248);
          }
          static uint256(e) {
            return Ue(e, 256);
          }
          static uint(e) {
            return Ue(e, 256);
          }
          static int8(e) {
            return Ue(e, -8);
          }
          static int16(e) {
            return Ue(e, -16);
          }
          static int24(e) {
            return Ue(e, -24);
          }
          static int32(e) {
            return Ue(e, -32);
          }
          static int40(e) {
            return Ue(e, -40);
          }
          static int48(e) {
            return Ue(e, -48);
          }
          static int56(e) {
            return Ue(e, -56);
          }
          static int64(e) {
            return Ue(e, -64);
          }
          static int72(e) {
            return Ue(e, -72);
          }
          static int80(e) {
            return Ue(e, -80);
          }
          static int88(e) {
            return Ue(e, -88);
          }
          static int96(e) {
            return Ue(e, -96);
          }
          static int104(e) {
            return Ue(e, -104);
          }
          static int112(e) {
            return Ue(e, -112);
          }
          static int120(e) {
            return Ue(e, -120);
          }
          static int128(e) {
            return Ue(e, -128);
          }
          static int136(e) {
            return Ue(e, -136);
          }
          static int144(e) {
            return Ue(e, -144);
          }
          static int152(e) {
            return Ue(e, -152);
          }
          static int160(e) {
            return Ue(e, -160);
          }
          static int168(e) {
            return Ue(e, -168);
          }
          static int176(e) {
            return Ue(e, -176);
          }
          static int184(e) {
            return Ue(e, -184);
          }
          static int192(e) {
            return Ue(e, -192);
          }
          static int200(e) {
            return Ue(e, -200);
          }
          static int208(e) {
            return Ue(e, -208);
          }
          static int216(e) {
            return Ue(e, -216);
          }
          static int224(e) {
            return Ue(e, -224);
          }
          static int232(e) {
            return Ue(e, -232);
          }
          static int240(e) {
            return Ue(e, -240);
          }
          static int248(e) {
            return Ue(e, -248);
          }
          static int256(e) {
            return Ue(e, -256);
          }
          static int(e) {
            return Ue(e, -256);
          }
          static bytes1(e) {
            return Pt(e, 1);
          }
          static bytes2(e) {
            return Pt(e, 2);
          }
          static bytes3(e) {
            return Pt(e, 3);
          }
          static bytes4(e) {
            return Pt(e, 4);
          }
          static bytes5(e) {
            return Pt(e, 5);
          }
          static bytes6(e) {
            return Pt(e, 6);
          }
          static bytes7(e) {
            return Pt(e, 7);
          }
          static bytes8(e) {
            return Pt(e, 8);
          }
          static bytes9(e) {
            return Pt(e, 9);
          }
          static bytes10(e) {
            return Pt(e, 10);
          }
          static bytes11(e) {
            return Pt(e, 11);
          }
          static bytes12(e) {
            return Pt(e, 12);
          }
          static bytes13(e) {
            return Pt(e, 13);
          }
          static bytes14(e) {
            return Pt(e, 14);
          }
          static bytes15(e) {
            return Pt(e, 15);
          }
          static bytes16(e) {
            return Pt(e, 16);
          }
          static bytes17(e) {
            return Pt(e, 17);
          }
          static bytes18(e) {
            return Pt(e, 18);
          }
          static bytes19(e) {
            return Pt(e, 19);
          }
          static bytes20(e) {
            return Pt(e, 20);
          }
          static bytes21(e) {
            return Pt(e, 21);
          }
          static bytes22(e) {
            return Pt(e, 22);
          }
          static bytes23(e) {
            return Pt(e, 23);
          }
          static bytes24(e) {
            return Pt(e, 24);
          }
          static bytes25(e) {
            return Pt(e, 25);
          }
          static bytes26(e) {
            return Pt(e, 26);
          }
          static bytes27(e) {
            return Pt(e, 27);
          }
          static bytes28(e) {
            return Pt(e, 28);
          }
          static bytes29(e) {
            return Pt(e, 29);
          }
          static bytes30(e) {
            return Pt(e, 30);
          }
          static bytes31(e) {
            return Pt(e, 31);
          }
          static bytes32(e) {
            return Pt(e, 32);
          }
          static address(e) {
            return new Ei(ai, "address", e);
          }
          static bool(e) {
            return new Ei(ai, "bool", !!e);
          }
          static bytes(e) {
            return new Ei(ai, "bytes", e);
          }
          static string(e) {
            return new Ei(ai, "string", e);
          }
          static array(e, t) {
            throw new Error("not implemented yet");
          }
          static tuple(e, t) {
            throw new Error("not implemented yet");
          }
          static overrides(e) {
            return new Ei(ai, "overrides", Object.assign({}, e));
          }
          static isTyped(e) {
            return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === Ap;
          }
          static dereference(e, t) {
            if (Ei.isTyped(e)) {
              if (e.type !== t) throw new Error(`invalid type: expecetd ${t}, got ${e.type}`);
              return e.value;
            }
            return e;
          }
        };
      Gs = new WeakMap();
      let Bn = Ei;
      class Ww extends oi {
        constructor(e) {
          super("address", "address", e, !1);
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }
        encode(e, t) {
          let r = Bn.dereference(t, "string");
          try {
            r = Mt(r);
          } catch (i) {
            return this._throwError(i.message, t);
          }
          return e.writeValue(r);
        }
        decode(e) {
          return Mt(Ii(e.readValue(), 20));
        }
      }
      class Xw extends oi {
        constructor(t) {
          super(t.name, t.type, "_", t.dynamic);
          ce(this, "coder");
          this.coder = t;
        }
        defaultValue() {
          return this.coder.defaultValue();
        }
        encode(t, r) {
          return this.coder.encode(t, r);
        }
        decode(t) {
          return this.coder.decode(t);
        }
      }
      function Rp(n, e, t) {
        let r = [];
        if (Array.isArray(t)) r = t;else if (t && typeof t == "object") {
          let o = {};
          r = e.map(c => {
            const u = c.localName;
            return be(u, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
              argument: "values",
              info: {
                coder: c
              },
              value: t
            }), be(!o[u], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
              argument: "values",
              info: {
                coder: c
              },
              value: t
            }), o[u] = !0, t[u];
          });
        } else re(!1, "invalid tuple value", "tuple", t);
        re(e.length === r.length, "types/value length mismatch", "tuple", t);
        let i = new Vf(),
          a = new Vf(),
          l = [];
        e.forEach((o, c) => {
          let u = r[c];
          if (o.dynamic) {
            let f = a.length;
            o.encode(a, u);
            let d = i.writeUpdatableValue();
            l.push(p => {
              d(p + f);
            });
          } else o.encode(i, u);
        }), l.forEach(o => {
          o(i.length);
        });
        let s = n.appendWriter(i);
        return s += n.appendWriter(a), s;
      }
      function Np(n, e) {
        let t = [],
          r = [],
          i = n.subReader(0);
        return e.forEach(a => {
          let l = null;
          if (a.dynamic) {
            let s = n.readIndex(),
              o = i.subReader(s);
            try {
              l = a.decode(o);
            } catch (c) {
              if (Nn(c, "BUFFER_OVERRUN")) throw c;
              l = c, l.baseType = a.name, l.name = a.localName, l.type = a.type;
            }
          } else try {
            l = a.decode(n);
          } catch (s) {
            if (Nn(s, "BUFFER_OVERRUN")) throw s;
            l = s, l.baseType = a.name, l.name = a.localName, l.type = a.type;
          }
          if (l == null) throw new Error("investigate");
          t.push(l), r.push(a.localName || null);
        }), da.fromItems(t, r);
      }
      class qw extends oi {
        constructor(t, r, i) {
          const a = t.type + "[" + (r >= 0 ? r : "") + "]",
            l = r === -1 || t.dynamic;
          super("array", a, i, l);
          ce(this, "coder");
          ce(this, "length");
          Ge(this, {
            coder: t,
            length: r
          });
        }
        defaultValue() {
          const t = this.coder.defaultValue(),
            r = [];
          for (let i = 0; i < this.length; i++) r.push(t);
          return r;
        }
        encode(t, r) {
          const i = Bn.dereference(r, "array");
          Array.isArray(i) || this._throwError("expected array value", i);
          let a = this.length;
          a === -1 && (a = i.length, t.writeValue(i.length)), ah(i.length, a, "coder array" + (this.localName ? " " + this.localName : ""));
          let l = [];
          for (let s = 0; s < i.length; s++) l.push(this.coder);
          return Rp(t, l, i);
        }
        decode(t) {
          let r = this.length;
          r === -1 && (r = t.readIndex(), be(r * Hn <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: t.bytes,
            offset: r * Hn,
            length: t.dataLength
          }));
          let i = [];
          for (let a = 0; a < r; a++) i.push(new Xw(this.coder));
          return Np(t, i);
        }
      }
      class Jw extends oi {
        constructor(e) {
          super("bool", "bool", e, !1);
        }
        defaultValue() {
          return !1;
        }
        encode(e, t) {
          const r = Bn.dereference(t, "bool");
          return e.writeValue(r ? 1 : 0);
        }
        decode(e) {
          return !!e.readValue();
        }
      }
      class Sp extends oi {
        constructor(e, t) {
          super(e, e, t, !0);
        }
        defaultValue() {
          return "0x";
        }
        encode(e, t) {
          t = Fn(t);
          let r = e.writeValue(t.length);
          return r += e.writeBytes(t), r;
        }
        decode(e) {
          return e.readBytes(e.readIndex(), !0);
        }
      }
      class Gw extends Sp {
        constructor(e) {
          super("bytes", e);
        }
        decode(e) {
          return Se(super.decode(e));
        }
      }
      class Vw extends oi {
        constructor(t, r) {
          let i = "bytes" + String(t);
          super(i, i, r, !1);
          ce(this, "size");
          Ge(this, {
            size: t
          }, {
            size: "number"
          });
        }
        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
        }
        encode(t, r) {
          let i = Fn(Bn.dereference(r, this.type));
          return i.length !== this.size && this._throwError("incorrect data length", r), t.writeBytes(i);
        }
        decode(t) {
          return Se(t.readBytes(this.size));
        }
      }
      const zw = new Uint8Array([]);
      class $w extends oi {
        constructor(e) {
          super("null", "", e, !1);
        }
        defaultValue() {
          return null;
        }
        encode(e, t) {
          return t != null && this._throwError("not null", t), e.writeBytes(zw);
        }
        decode(e) {
          return e.readBytes(0), null;
        }
      }
      const Qw = BigInt(0),
        Yw = BigInt(1),
        Zw = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      class ex extends oi {
        constructor(t, r, i) {
          const a = (r ? "int" : "uint") + t * 8;
          super(a, a, i, !1);
          ce(this, "size");
          ce(this, "signed");
          Ge(this, {
            size: t,
            signed: r
          }, {
            size: "number",
            signed: "boolean"
          });
        }
        defaultValue() {
          return 0;
        }
        encode(t, r) {
          let i = Le(Bn.dereference(r, this.type)),
            a = wo(Zw, Hn * 8);
          if (this.signed) {
            let l = wo(a, this.size * 8 - 1);
            (i > l || i < -(l + Yw)) && this._throwError("value out-of-bounds", r), i = fh(i, 8 * Hn);
          } else (i < Qw || i > wo(a, this.size * 8)) && this._throwError("value out-of-bounds", r);
          return t.writeValue(i);
        }
        decode(t) {
          let r = wo(t.readValue(), this.size * 8);
          return this.signed && (r = Ml(r, this.size * 8)), r;
        }
      }
      class tx extends Sp {
        constructor(e) {
          super("string", e);
        }
        defaultValue() {
          return "";
        }
        encode(e, t) {
          return super.encode(e, ii(Bn.dereference(t, "string")));
        }
        decode(e) {
          return Ul(super.decode(e));
        }
      }
      class $l extends oi {
        constructor(t, r) {
          let i = !1;
          const a = [];
          t.forEach(s => {
            s.dynamic && (i = !0), a.push(s.type);
          });
          const l = "tuple(" + a.join(",") + ")";
          super("tuple", l, r, i);
          ce(this, "coders");
          Ge(this, {
            coders: Object.freeze(t.slice())
          });
        }
        defaultValue() {
          const t = [];
          this.coders.forEach(i => {
            t.push(i.defaultValue());
          });
          const r = this.coders.reduce((i, a) => {
            const l = a.localName;
            return l && (i[l] || (i[l] = 0), i[l]++), i;
          }, {});
          return this.coders.forEach((i, a) => {
            let l = i.localName;
            !l || r[l] !== 1 || (l === "length" && (l = "_length"), t[l] == null && (t[l] = t[a]));
          }), Object.freeze(t);
        }
        encode(t, r) {
          const i = Bn.dereference(r, "tuple");
          return Rp(t, this.coders, i);
        }
        decode(t) {
          return Np(t, this.coders);
        }
      }
      function g0(n, e) {
        return {
          address: Mt(n),
          storageKeys: e.map((t, r) => (re(Xt(t, 32), "invalid slot", `storageKeys[${r}]`, t), t.toLowerCase()))
        };
      }
      function Ao(n) {
        if (Array.isArray(n)) return n.map((t, r) => Array.isArray(t) ? (re(t.length === 2, "invalid slot set", `value[${r}]`, t), g0(t[0], t[1])) : (re(t != null && typeof t == "object", "invalid address-slot set", "value", n), g0(t.address, t.storageKeys)));
        re(n != null && typeof n == "object", "invalid access list", "value", n);
        const e = Object.keys(n).map(t => {
          const r = n[t].reduce((i, a) => (i[a] = !0, i), {});
          return g0(t, Object.keys(r).sort());
        });
        return e.sort((t, r) => t.address.localeCompare(r.address)), e;
      }
      function Tp(n) {
        return {
          address: Mt(n.address),
          nonce: Le(n.nonce != null ? n.nonce : 0),
          chainId: Le(n.chainId != null ? n.chainId : 0),
          signature: zn.from(n.signature)
        };
      }
      function nx(n) {
        let e;
        return typeof n == "string" ? e = Ic.computePublicKey(n, !1) : e = n.publicKey, Mt(gn("0x" + e.substring(4)).substring(26));
      }
      function rx(n, e) {
        return nx(Ic.recoverPublicKey(n, e));
      }
      const _n = BigInt(0),
        ix = BigInt(2),
        ox = BigInt(27),
        sx = BigInt(28),
        ax = BigInt(35),
        cx = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
        v0 = 4096 * 32;
      function lx(n) {
        return {
          blobToKzgCommitment: r => {
            if ("computeBlobProof" in n) {
              if ("blobToKzgCommitment" in n && typeof n.blobToKzgCommitment == "function") return ft(n.blobToKzgCommitment(Se(r)));
            } else if ("blobToKzgCommitment" in n && typeof n.blobToKzgCommitment == "function") return ft(n.blobToKzgCommitment(r));
            if ("blobToKZGCommitment" in n && typeof n.blobToKZGCommitment == "function") return ft(n.blobToKZGCommitment(Se(r)));
            re(!1, "unsupported KZG library", "kzg", n);
          },
          computeBlobKzgProof: (r, i) => {
            if ("computeBlobProof" in n && typeof n.computeBlobProof == "function") return ft(n.computeBlobProof(Se(r), Se(i)));
            if ("computeBlobKzgProof" in n && typeof n.computeBlobKzgProof == "function") return n.computeBlobKzgProof(r, i);
            if ("computeBlobKZGProof" in n && typeof n.computeBlobKZGProof == "function") return ft(n.computeBlobKZGProof(Se(r), Se(i)));
            re(!1, "unsupported KZG library", "kzg", n);
          }
        };
      }
      function Dp(n, e) {
        let t = n.toString(16);
        for (; t.length < 2;) t = "0" + t;
        return t += pa(e).substring(4), "0x" + t;
      }
      function ba(n) {
        return n === "0x" ? null : Mt(n);
      }
      function Ql(n, e) {
        try {
          return Ao(n);
        } catch (t) {
          re(!1, t.message, e, n);
        }
      }
      function ux(n, e) {
        try {
          if (!Array.isArray(n)) throw new Error("authorizationList: invalid array");
          const t = [];
          for (let r = 0; r < n.length; r++) {
            const i = n[r];
            if (!Array.isArray(i)) throw new Error(`authorization[${r}]: invalid array`);
            if (i.length !== 6) throw new Error(`authorization[${r}]: wrong length`);
            if (!i[1]) throw new Error(`authorization[${r}]: null address`);
            t.push({
              address: ba(i[1]),
              nonce: Ut(i[2], "nonce"),
              chainId: Ut(i[0], "chainId"),
              signature: zn.from({
                yParity: Ro(i[3], "yParity"),
                r: ri(i[4], 32),
                s: ri(i[5], 32)
              })
            });
          }
          return t;
        } catch (t) {
          re(!1, t.message, e, n);
        }
      }
      function Ro(n, e) {
        return n === "0x" ? 0 : ct(n, e);
      }
      function Ut(n, e) {
        if (n === "0x") return _n;
        const t = Le(n, e);
        return re(t <= cx, "value exceeds uint size", e, t), t;
      }
      function wt(n, e) {
        const t = Le(n, "value"),
          r = wn(t);
        return re(r.length <= 32, "value too large", `tx.${e}`, t), r;
      }
      function Yl(n) {
        return Ao(n).map(e => [e.address, e.storageKeys]);
      }
      function fx(n) {
        return n.map(e => [wt(e.chainId, "chainId"), e.address, wt(e.nonce, "nonce"), wt(e.signature.yParity, "yParity"), wn(e.signature.r), wn(e.signature.s)]);
      }
      function dx(n, e) {
        re(Array.isArray(n), `invalid ${e}`, "value", n);
        for (let t = 0; t < n.length; t++) re(Xt(n[t], 32), "invalid ${ param } hash", `value[${t}]`, n[t]);
        return n;
      }
      function hx(n) {
        const e = Rc(n);
        re(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", n);
        const t = {
          type: 0,
          nonce: Ro(e[0], "nonce"),
          gasPrice: Ut(e[1], "gasPrice"),
          gasLimit: Ut(e[2], "gasLimit"),
          to: ba(e[3]),
          value: Ut(e[4], "value"),
          data: Se(e[5]),
          chainId: _n
        };
        if (e.length === 6) return t;
        const r = Ut(e[6], "v"),
          i = Ut(e[7], "r"),
          a = Ut(e[8], "s");
        if (i === _n && a === _n) t.chainId = r;else {
          let l = (r - ax) / ix;
          l < _n && (l = _n), t.chainId = l, re(l !== _n || r === ox || r === sx, "non-canonical legacy v", "v", e[6]), t.signature = zn.from({
            r: ri(e[7], 32),
            s: ri(e[8], 32),
            v: r
          });
        }
        return t;
      }
      function px(n, e) {
        const t = [wt(n.nonce, "nonce"), wt(n.gasPrice || 0, "gasPrice"), wt(n.gasLimit, "gasLimit"), n.to || "0x", wt(n.value, "value"), n.data];
        let r = _n;
        if (n.chainId != _n) r = Le(n.chainId, "tx.chainId"), re(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);else if (n.signature) {
          const a = n.signature.legacyChainId;
          a != null && (r = a);
        }
        if (!e) return r !== _n && (t.push(wn(r)), t.push("0x"), t.push("0x")), Mi(t);
        let i = BigInt(27 + e.yParity);
        return r !== _n ? i = zn.getChainIdV(r, e.v) : BigInt(e.v) !== i && re(!1, "tx.chainId/sig.v mismatch", "sig", e), t.push(wn(i)), t.push(wn(e.r)), t.push(wn(e.s)), Mi(t);
      }
      function Zl(n, e) {
        let t;
        try {
          if (t = Ro(e[0], "yParity"), t !== 0 && t !== 1) throw new Error("bad yParity");
        } catch {
          re(!1, "invalid yParity", "yParity", e[0]);
        }
        const r = ri(e[1], 32),
          i = ri(e[2], 32),
          a = zn.from({
            r,
            s: i,
            yParity: t
          });
        n.signature = a;
      }
      function gx(n) {
        const e = Rc(ft(n).slice(1));
        re(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Se(n));
        const t = {
          type: 2,
          chainId: Ut(e[0], "chainId"),
          nonce: Ro(e[1], "nonce"),
          maxPriorityFeePerGas: Ut(e[2], "maxPriorityFeePerGas"),
          maxFeePerGas: Ut(e[3], "maxFeePerGas"),
          gasPrice: null,
          gasLimit: Ut(e[4], "gasLimit"),
          to: ba(e[5]),
          value: Ut(e[6], "value"),
          data: Se(e[7]),
          accessList: Ql(e[8], "accessList")
        };
        return e.length === 9 || Zl(t, e.slice(9)), t;
      }
      function vx(n, e) {
        const t = [wt(n.chainId, "chainId"), wt(n.nonce, "nonce"), wt(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), wt(n.maxFeePerGas || 0, "maxFeePerGas"), wt(n.gasLimit, "gasLimit"), n.to || "0x", wt(n.value, "value"), n.data, Yl(n.accessList || [])];
        return e && (t.push(wt(e.yParity, "yParity")), t.push(wn(e.r)), t.push(wn(e.s))), sn(["0x02", Mi(t)]);
      }
      function yx(n) {
        const e = Rc(ft(n).slice(1));
        re(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Se(n));
        const t = {
          type: 1,
          chainId: Ut(e[0], "chainId"),
          nonce: Ro(e[1], "nonce"),
          gasPrice: Ut(e[2], "gasPrice"),
          gasLimit: Ut(e[3], "gasLimit"),
          to: ba(e[4]),
          value: Ut(e[5], "value"),
          data: Se(e[6]),
          accessList: Ql(e[7], "accessList")
        };
        return e.length === 8 || Zl(t, e.slice(8)), t;
      }
      function mx(n, e) {
        const t = [wt(n.chainId, "chainId"), wt(n.nonce, "nonce"), wt(n.gasPrice || 0, "gasPrice"), wt(n.gasLimit, "gasLimit"), n.to || "0x", wt(n.value, "value"), n.data, Yl(n.accessList || [])];
        return e && (t.push(wt(e.yParity, "recoveryParam")), t.push(wn(e.r)), t.push(wn(e.s))), sn(["0x01", Mi(t)]);
      }
      function bx(n) {
        let e = Rc(ft(n).slice(1)),
          t = "3",
          r = null;
        if (e.length === 4 && Array.isArray(e[0])) {
          t = "3 (network format)";
          const a = e[1],
            l = e[2],
            s = e[3];
          re(Array.isArray(a), "invalid network format: blobs not an array", "fields[1]", a), re(Array.isArray(l), "invalid network format: commitments not an array", "fields[2]", l), re(Array.isArray(s), "invalid network format: proofs not an array", "fields[3]", s), re(a.length === l.length, "invalid network format: blobs/commitments length mismatch", "fields", e), re(a.length === s.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
          for (let o = 0; o < e[1].length; o++) r.push({
            data: a[o],
            commitment: l[o],
            proof: s[o]
          });
          e = e[0];
        }
        re(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${t}`, "data", Se(n));
        const i = {
          type: 3,
          chainId: Ut(e[0], "chainId"),
          nonce: Ro(e[1], "nonce"),
          maxPriorityFeePerGas: Ut(e[2], "maxPriorityFeePerGas"),
          maxFeePerGas: Ut(e[3], "maxFeePerGas"),
          gasPrice: null,
          gasLimit: Ut(e[4], "gasLimit"),
          to: ba(e[5]),
          value: Ut(e[6], "value"),
          data: Se(e[7]),
          accessList: Ql(e[8], "accessList"),
          maxFeePerBlobGas: Ut(e[9], "maxFeePerBlobGas"),
          blobVersionedHashes: e[10]
        };
        r && (i.blobs = r), re(i.to != null, `invalid address for transaction type: ${t}`, "data", n), re(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", n);
        for (let a = 0; a < i.blobVersionedHashes.length; a++) re(Xt(i.blobVersionedHashes[a], 32), `invalid blobVersionedHash at index ${a}: must be length 32`, "data", n);
        return e.length === 11 || Zl(i, e.slice(11)), i;
      }
      function wx(n, e, t) {
        const r = [wt(n.chainId, "chainId"), wt(n.nonce, "nonce"), wt(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), wt(n.maxFeePerGas || 0, "maxFeePerGas"), wt(n.gasLimit, "gasLimit"), n.to || Pc, wt(n.value, "value"), n.data, Yl(n.accessList || []), wt(n.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), dx(n.blobVersionedHashes || [], "blobVersionedHashes")];
        return e && (r.push(wt(e.yParity, "yParity")), r.push(wn(e.r)), r.push(wn(e.s)), t) ? sn(["0x03", Mi([r, t.map(i => i.data), t.map(i => i.commitment), t.map(i => i.proof)])]) : sn(["0x03", Mi(r)]);
      }
      function xx(n) {
        const e = Rc(ft(n).slice(1));
        re(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", Se(n));
        const t = {
          type: 4,
          chainId: Ut(e[0], "chainId"),
          nonce: Ro(e[1], "nonce"),
          maxPriorityFeePerGas: Ut(e[2], "maxPriorityFeePerGas"),
          maxFeePerGas: Ut(e[3], "maxFeePerGas"),
          gasPrice: null,
          gasLimit: Ut(e[4], "gasLimit"),
          to: ba(e[5]),
          value: Ut(e[6], "value"),
          data: Se(e[7]),
          accessList: Ql(e[8], "accessList"),
          authorizationList: ux(e[9], "authorizationList")
        };
        return e.length === 10 || Zl(t, e.slice(10)), t;
      }
      function _x(n, e) {
        const t = [wt(n.chainId, "chainId"), wt(n.nonce, "nonce"), wt(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), wt(n.maxFeePerGas || 0, "maxFeePerGas"), wt(n.gasLimit, "gasLimit"), n.to || "0x", wt(n.value, "value"), n.data, Yl(n.accessList || []), fx(n.authorizationList || [])];
        return e && (t.push(wt(e.yParity, "yParity")), t.push(wn(e.r)), t.push(wn(e.s))), sn(["0x04", Mi(t)]);
      }
      const Vr = class Vr {
        constructor() {
          de(this, rc);
          de(this, Mr);
          de(this, qa);
          de(this, Ja);
          de(this, Ga);
          de(this, Va);
          de(this, za);
          de(this, $a);
          de(this, Qa);
          de(this, Ya);
          de(this, Za);
          de(this, ec);
          de(this, tc);
          de(this, Vs);
          de(this, io);
          de(this, Gr);
          de(this, oo);
          de(this, nc);
          z(this, Mr, null), z(this, qa, null), z(this, Ga, 0), z(this, Va, _n), z(this, za, null), z(this, $a, null), z(this, Qa, null), z(this, Ja, "0x"), z(this, Ya, _n), z(this, Za, _n), z(this, ec, null), z(this, tc, null), z(this, Vs, null), z(this, io, null), z(this, Gr, null), z(this, oo, null), z(this, nc, null);
        }
        get type() {
          return k(this, Mr);
        }
        set type(e) {
          switch (e) {
            case null:
              z(this, Mr, null);
              break;
            case 0:
            case "legacy":
              z(this, Mr, 0);
              break;
            case 1:
            case "berlin":
            case "eip-2930":
              z(this, Mr, 1);
              break;
            case 2:
            case "london":
            case "eip-1559":
              z(this, Mr, 2);
              break;
            case 3:
            case "cancun":
            case "eip-4844":
              z(this, Mr, 3);
              break;
            case 4:
            case "pectra":
            case "eip-7702":
              z(this, Mr, 4);
              break;
            default:
              re(!1, "unsupported transaction type", "type", e);
          }
        }
        get typeName() {
          switch (this.type) {
            case 0:
              return "legacy";
            case 1:
              return "eip-2930";
            case 2:
              return "eip-1559";
            case 3:
              return "eip-4844";
            case 4:
              return "eip-7702";
          }
          return null;
        }
        get to() {
          const e = k(this, qa);
          return e == null && this.type === 3 ? Pc : e;
        }
        set to(e) {
          z(this, qa, e == null ? null : Mt(e));
        }
        get nonce() {
          return k(this, Ga);
        }
        set nonce(e) {
          z(this, Ga, ct(e, "value"));
        }
        get gasLimit() {
          return k(this, Va);
        }
        set gasLimit(e) {
          z(this, Va, Le(e));
        }
        get gasPrice() {
          const e = k(this, za);
          return e == null && (this.type === 0 || this.type === 1) ? _n : e;
        }
        set gasPrice(e) {
          z(this, za, e == null ? null : Le(e, "gasPrice"));
        }
        get maxPriorityFeePerGas() {
          const e = k(this, $a);
          return e == null ? this.type === 2 || this.type === 3 ? _n : null : e;
        }
        set maxPriorityFeePerGas(e) {
          z(this, $a, e == null ? null : Le(e, "maxPriorityFeePerGas"));
        }
        get maxFeePerGas() {
          const e = k(this, Qa);
          return e == null ? this.type === 2 || this.type === 3 ? _n : null : e;
        }
        set maxFeePerGas(e) {
          z(this, Qa, e == null ? null : Le(e, "maxFeePerGas"));
        }
        get data() {
          return k(this, Ja);
        }
        set data(e) {
          z(this, Ja, Se(e));
        }
        get value() {
          return k(this, Ya);
        }
        set value(e) {
          z(this, Ya, Le(e, "value"));
        }
        get chainId() {
          return k(this, Za);
        }
        set chainId(e) {
          z(this, Za, Le(e));
        }
        get signature() {
          return k(this, ec) || null;
        }
        set signature(e) {
          z(this, ec, e == null ? null : zn.from(e));
        }
        get accessList() {
          const e = k(this, tc) || null;
          return e == null ? this.type === 1 || this.type === 2 || this.type === 3 ? [] : null : e;
        }
        set accessList(e) {
          z(this, tc, e == null ? null : Ao(e));
        }
        get authorizationList() {
          const e = k(this, nc) || null;
          return e == null && this.type === 4 ? [] : e;
        }
        set authorizationList(e) {
          z(this, nc, e == null ? null : e.map(t => Tp(t)));
        }
        get maxFeePerBlobGas() {
          const e = k(this, Vs);
          return e == null && this.type === 3 ? _n : e;
        }
        set maxFeePerBlobGas(e) {
          z(this, Vs, e == null ? null : Le(e, "maxFeePerBlobGas"));
        }
        get blobVersionedHashes() {
          let e = k(this, io);
          return e == null && this.type === 3 ? [] : e;
        }
        set blobVersionedHashes(e) {
          if (e != null) {
            re(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
            for (let t = 0; t < e.length; t++) re(Xt(e[t], 32), "invalid blobVersionedHash", `value[${t}]`, e[t]);
          }
          z(this, io, e);
        }
        get blobs() {
          return k(this, oo) == null ? null : k(this, oo).map(e => Object.assign({}, e));
        }
        set blobs(e) {
          if (e == null) {
            z(this, oo, null);
            return;
          }
          const t = [],
            r = [];
          for (let i = 0; i < e.length; i++) {
            const a = e[i];
            if (Wf(a)) {
              be(k(this, Gr), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                operation: "set blobs()"
              });
              let l = ft(a);
              if (re(l.length <= v0, "blob is too large", `blobs[${i}]`, a), l.length !== v0) {
                const c = new Uint8Array(v0);
                c.set(l), l = c;
              }
              const s = k(this, Gr).blobToKzgCommitment(l),
                o = Se(k(this, Gr).computeBlobKzgProof(l, s));
              t.push({
                data: Se(l),
                commitment: Se(s),
                proof: o
              }), r.push(Dp(1, s));
            } else {
              const l = Se(a.commitment);
              t.push({
                data: Se(a.data),
                commitment: l,
                proof: Se(a.proof)
              }), r.push(Dp(1, l));
            }
          }
          z(this, oo, t), z(this, io, r);
        }
        get kzg() {
          return k(this, Gr);
        }
        set kzg(e) {
          e == null ? z(this, Gr, null) : z(this, Gr, lx(e));
        }
        get hash() {
          return this.signature == null ? null : gn(_e(this, rc, Mf).call(this, !0, !1));
        }
        get unsignedHash() {
          return gn(this.unsignedSerialized);
        }
        get from() {
          return this.signature == null ? null : rx(this.unsignedHash, this.signature);
        }
        get fromPublicKey() {
          return this.signature == null ? null : Ic.recoverPublicKey(this.unsignedHash, this.signature);
        }
        isSigned() {
          return this.signature != null;
        }
        get serialized() {
          return _e(this, rc, Mf).call(this, !0, !0);
        }
        get unsignedSerialized() {
          return _e(this, rc, Mf).call(this, !1, !1);
        }
        inferType() {
          const e = this.inferTypes();
          return e.indexOf(2) >= 0 ? 2 : e.pop();
        }
        inferTypes() {
          const e = this.gasPrice != null,
            t = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null,
            r = this.accessList != null,
            i = k(this, Vs) != null || k(this, io);
          this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && be(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
          }), be(!t || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
          }), be(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
          });
          const a = [];
          return this.type != null ? a.push(this.type) : this.authorizationList && this.authorizationList.length ? a.push(4) : t ? a.push(2) : e ? (a.push(1), r || a.push(0)) : r ? (a.push(1), a.push(2)) : (i && this.to || (a.push(0), a.push(1), a.push(2)), a.push(3)), a.sort(), a;
        }
        isLegacy() {
          return this.type === 0;
        }
        isBerlin() {
          return this.type === 1;
        }
        isLondon() {
          return this.type === 2;
        }
        isCancun() {
          return this.type === 3;
        }
        clone() {
          return Vr.from(this);
        }
        toJSON() {
          const e = t => t == null ? null : t.toString();
          return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
          };
        }
        static from(e) {
          if (e == null) return new Vr();
          if (typeof e == "string") {
            const r = ft(e);
            if (r[0] >= 127) return Vr.from(hx(r));
            switch (r[0]) {
              case 1:
                return Vr.from(yx(r));
              case 2:
                return Vr.from(gx(r));
              case 3:
                return Vr.from(bx(r));
              case 4:
                return Vr.from(xx(r));
            }
            be(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
              operation: "from"
            });
          }
          const t = new Vr();
          return e.type != null && (t.type = e.type), e.to != null && (t.to = e.to), e.nonce != null && (t.nonce = e.nonce), e.gasLimit != null && (t.gasLimit = e.gasLimit), e.gasPrice != null && (t.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (t.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (t.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (t.data = e.data), e.value != null && (t.value = e.value), e.chainId != null && (t.chainId = e.chainId), e.signature != null && (t.signature = zn.from(e.signature)), e.accessList != null && (t.accessList = e.accessList), e.authorizationList != null && (t.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (t.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (t.kzg = e.kzg), e.blobs != null && (t.blobs = e.blobs), e.hash != null && (re(t.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), re(t.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (re(t.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), re(t.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), t;
        }
      };
      Mr = new WeakMap(), qa = new WeakMap(), Ja = new WeakMap(), Ga = new WeakMap(), Va = new WeakMap(), za = new WeakMap(), $a = new WeakMap(), Qa = new WeakMap(), Ya = new WeakMap(), Za = new WeakMap(), ec = new WeakMap(), tc = new WeakMap(), Vs = new WeakMap(), io = new WeakMap(), Gr = new WeakMap(), oo = new WeakMap(), nc = new WeakMap(), rc = new WeakSet(), Mf = function (e, t) {
        be(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
          operation: ".serialized"
        });
        const r = e ? this.signature : null;
        switch (this.inferType()) {
          case 0:
            return px(this, r);
          case 1:
            return mx(this, r);
          case 2:
            return vx(this, r);
          case 3:
            return wx(this, r, t ? this.blobs : null);
          case 4:
            return _x(this, r);
        }
        be(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
          operation: ".serialized"
        });
      };
      let eu = Vr;
      function No(n) {
        return gn(ii(n));
      }
      var Ex = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
      const Pp = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]),
        Ip = 4;
      function Cx(n) {
        let e = 0;
        function t() {
          return n[e++] << 8 | n[e++];
        }
        let r = t(),
          i = 1,
          a = [0, 1];
        for (let O = 1; O < r; O++) a.push(i += t());
        let l = t(),
          s = e;
        e += l;
        let o = 0,
          c = 0;
        function u() {
          return o == 0 && (c = c << 8 | n[e++], o = 8), c >> --o & 1;
        }
        const f = 31,
          d = 2 ** f,
          p = d >>> 1,
          v = p >> 1,
          h = d - 1;
        let g = 0;
        for (let O = 0; O < f; O++) g = g << 1 | u();
        let b = [],
          m = 0,
          _ = d;
        for (;;) {
          let O = Math.floor(((g - m + 1) * i - 1) / _),
            y = 0,
            w = r;
          for (; w - y > 1;) {
            let T = y + w >>> 1;
            O < a[T] ? w = T : y = T;
          }
          if (y == 0) break;
          b.push(y);
          let A = m + Math.floor(_ * a[y] / i),
            R = m + Math.floor(_ * a[y + 1] / i) - 1;
          for (; ((A ^ R) & p) == 0;) g = g << 1 & h | u(), A = A << 1 & h, R = R << 1 & h | 1;
          for (; A & ~R & v;) g = g & p | g << 1 & h >>> 1 | u(), A = A << 1 ^ p, R = (R ^ p) << 1 | p | 1;
          m = A, _ = 1 + R - A;
        }
        let N = r - 4;
        return b.map(O => {
          switch (O - N) {
            case 3:
              return N + 65792 + (n[s++] << 16 | n[s++] << 8 | n[s++]);
            case 2:
              return N + 256 + (n[s++] << 8 | n[s++]);
            case 1:
              return N + n[s++];
            default:
              return O - 1;
          }
        });
      }
      function Ox(n) {
        let e = 0;
        return () => n[e++];
      }
      function Bp(n) {
        return Ox(Cx(Ax(n)));
      }
      function Ax(n) {
        let e = [];
        [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, a) => e[i.charCodeAt(0)] = a);
        let t = n.length,
          r = new Uint8Array(6 * t >> 3);
        for (let i = 0, a = 0, l = 0, s = 0; i < t; i++) s = s << 6 | e[n.charCodeAt(i)], l += 6, l >= 8 && (r[a++] = s >> (l -= 8));
        return r;
      }
      function Rx(n) {
        return n & 1 ? ~n >> 1 : n >> 1;
      }
      function Nx(n, e) {
        let t = Array(n);
        for (let r = 0, i = 0; r < n; r++) t[r] = i += Rx(e());
        return t;
      }
      function Bc(n, e = 0) {
        let t = [];
        for (;;) {
          let r = n(),
            i = n();
          if (!i) break;
          e += r;
          for (let a = 0; a < i; a++) t.push(e + a);
          e += i + 1;
        }
        return t;
      }
      function kp(n) {
        return kc(() => {
          let e = Bc(n);
          if (e.length) return e;
        });
      }
      function Mp(n) {
        let e = [];
        for (;;) {
          let t = n();
          if (t == 0) break;
          e.push(Sx(t, n));
        }
        for (;;) {
          let t = n() - 1;
          if (t < 0) break;
          e.push(Tx(t, n));
        }
        return e.flat();
      }
      function kc(n) {
        let e = [];
        for (;;) {
          let t = n(e.length);
          if (!t) break;
          e.push(t);
        }
        return e;
      }
      function Kp(n, e, t) {
        let r = Array(n).fill().map(() => []);
        for (let i = 0; i < e; i++) Nx(n, t).forEach((a, l) => r[l].push(a));
        return r;
      }
      function Sx(n, e) {
        let t = 1 + e(),
          r = e(),
          i = kc(e);
        return Kp(i.length, 1 + n, e).flatMap((l, s) => {
          let [o, ...c] = l;
          return Array(i[s]).fill().map((u, f) => {
            let d = f * r;
            return [o + f * t, c.map(p => p + d)];
          });
        });
      }
      function Tx(n, e) {
        let t = 1 + e();
        return Kp(t, 1 + n, e).map(i => [i[0], i.slice(1)]);
      }
      function Dx(n) {
        let e = [],
          t = Bc(n);
        return i(r([]), []), e;
        function r(a) {
          let l = n(),
            s = kc(() => {
              let o = Bc(n).map(c => t[c]);
              if (o.length) return r(o);
            });
          return {
            S: l,
            B: s,
            Q: a
          };
        }
        function i({
          S: a,
          B: l
        }, s, o) {
          if (!(a & 4 && o === s[s.length - 1])) {
            a & 2 && (o = s[s.length - 1]), a & 1 && e.push(s);
            for (let c of l) for (let u of c.Q) i(c, [...s, u], o);
          }
        }
      }
      function Px(n) {
        return n.toString(16).toUpperCase().padStart(2, "0");
      }
      function Lp(n) {
        return `{${Px(n)}}`;
      }
      function Ix(n) {
        let e = [];
        for (let t = 0, r = n.length; t < r;) {
          let i = n.codePointAt(t);
          t += i < 65536 ? 1 : 2, e.push(i);
        }
        return e;
      }
      function wa(n) {
        let t = n.length;
        if (t < 4096) return String.fromCodePoint(...n);
        let r = [];
        for (let i = 0; i < t;) r.push(String.fromCodePoint(...n.slice(i, i += 4096)));
        return r.join("");
      }
      function Bx(n, e) {
        let t = n.length,
          r = t - e.length;
        for (let i = 0; r == 0 && i < t; i++) r = n[i] - e[i];
        return r;
      }
      var kx = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
      const Mc = 44032,
        tu = 4352,
        nu = 4449,
        ru = 4519,
        Up = 19,
        Fp = 21,
        xa = 28,
        iu = Fp * xa,
        Mx = Up * iu,
        Kx = Mc + Mx,
        Lx = tu + Up,
        Ux = nu + Fp,
        Fx = ru + xa;
      function Kc(n) {
        return n >> 24 & 255;
      }
      function Hp(n) {
        return n & 16777215;
      }
      let y0, jp, m0, ou;
      function Hx() {
        let n = Bp(kx);
        y0 = new Map(kp(n).flatMap((e, t) => e.map(r => [r, t + 1 << 24]))), jp = new Set(Bc(n)), m0 = new Map(), ou = new Map();
        for (let [e, t] of Mp(n)) {
          if (!jp.has(e) && t.length == 2) {
            let [r, i] = t,
              a = ou.get(r);
            a || (a = new Map(), ou.set(r, a)), a.set(i, e);
          }
          m0.set(e, t.reverse());
        }
      }
      function Wp(n) {
        return n >= Mc && n < Kx;
      }
      function jx(n, e) {
        if (n >= tu && n < Lx && e >= nu && e < Ux) return Mc + (n - tu) * iu + (e - nu) * xa;
        if (Wp(n) && e > ru && e < Fx && (n - Mc) % xa == 0) return n + (e - ru);
        {
          let t = ou.get(n);
          return t && (t = t.get(e), t) ? t : -1;
        }
      }
      function Xp(n) {
        y0 || Hx();
        let e = [],
          t = [],
          r = !1;
        function i(a) {
          let l = y0.get(a);
          l && (r = !0, a |= l), e.push(a);
        }
        for (let a of n) for (;;) {
          if (a < 128) e.push(a);else if (Wp(a)) {
            let l = a - Mc,
              s = l / iu | 0,
              o = l % iu / xa | 0,
              c = l % xa;
            i(tu + s), i(nu + o), c > 0 && i(ru + c);
          } else {
            let l = m0.get(a);
            l ? t.push(...l) : i(a);
          }
          if (!t.length) break;
          a = t.pop();
        }
        if (r && e.length > 1) {
          let a = Kc(e[0]);
          for (let l = 1; l < e.length; l++) {
            let s = Kc(e[l]);
            if (s == 0 || a <= s) {
              a = s;
              continue;
            }
            let o = l - 1;
            for (;;) {
              let c = e[o + 1];
              if (e[o + 1] = e[o], e[o] = c, !o || (a = Kc(e[--o]), a <= s)) break;
            }
            a = Kc(e[l]);
          }
        }
        return e;
      }
      function Wx(n) {
        let e = [],
          t = [],
          r = -1,
          i = 0;
        for (let a of n) {
          let l = Kc(a),
            s = Hp(a);
          if (r == -1) l == 0 ? r = s : e.push(s);else if (i > 0 && i >= l) l == 0 ? (e.push(r, ...t), t.length = 0, r = s) : t.push(s), i = l;else {
            let o = jx(r, s);
            o >= 0 ? r = o : i == 0 && l == 0 ? (e.push(r), r = s) : (t.push(s), i = l);
          }
        }
        return r >= 0 && e.push(r, ...t), e;
      }
      function qp(n) {
        return Xp(n).map(Hp);
      }
      function Xx(n) {
        return Wx(Xp(n));
      }
      const Jp = 45,
        Gp = ".",
        Vp = 65039,
        zp = 1,
        su = n => Array.from(n);
      function Lc(n, e) {
        return n.P.has(e) || n.Q.has(e);
      }
      class qx extends Array {
        get is_emoji() {
          return !0;
        }
      }
      let b0, $p, So, w0, Qp, _a, x0, Ea, To, Yp, _0;
      function E0() {
        if (b0) return;
        let n = Bp(Ex);
        const e = () => Bc(n),
          t = () => new Set(e()),
          r = (u, f) => f.forEach(d => u.add(d));
        b0 = new Map(Mp(n)), $p = t(), So = e(), w0 = new Set(e().map(u => So[u])), So = new Set(So), Qp = t(), t();
        let i = kp(n),
          a = n();
        const l = () => {
          let u = new Set();
          return e().forEach(f => r(u, i[f])), r(u, e()), u;
        };
        _a = kc(u => {
          let f = kc(n).map(d => d + 96);
          if (f.length) {
            let d = u >= a;
            f[0] -= 32, f = wa(f), d && (f = `Restricted[${f}]`);
            let p = l(),
              v = l(),
              h = !n();
            return {
              N: f,
              P: p,
              Q: v,
              M: h,
              R: d
            };
          }
        }), x0 = t(), Ea = new Map();
        let s = e().concat(su(x0)).sort((u, f) => u - f);
        s.forEach((u, f) => {
          let d = n(),
            p = s[f] = d ? s[f - d] : {
              V: [],
              M: new Map()
            };
          p.V.push(u), x0.has(u) || Ea.set(u, p);
        });
        for (let {
          V: u,
          M: f
        } of new Set(Ea.values())) {
          let d = [];
          for (let v of u) {
            let h = _a.filter(b => Lc(b, v)),
              g = d.find(({
                G: b
              }) => h.some(m => b.has(m)));
            g || (g = {
              G: new Set(),
              V: []
            }, d.push(g)), g.V.push(v), r(g.G, h);
          }
          let p = d.flatMap(v => su(v.G));
          for (let {
            G: v,
            V: h
          } of d) {
            let g = new Set(p.filter(b => !v.has(b)));
            for (let b of h) f.set(b, g);
          }
        }
        To = new Set();
        let o = new Set();
        const c = u => To.has(u) ? o.add(u) : To.add(u);
        for (let u of _a) {
          for (let f of u.P) c(f);
          for (let f of u.Q) c(f);
        }
        for (let u of To) !Ea.has(u) && !o.has(u) && Ea.set(u, zp);
        r(To, qp(To)), Yp = Dx(n).map(u => qx.from(u)).sort(Bx), _0 = new Map();
        for (let u of Yp) {
          let f = [_0];
          for (let d of u) {
            let p = f.map(v => {
              let h = v.get(d);
              return h || (h = new Map(), v.set(d, h)), h;
            });
            d === Vp ? f.push(...p) : f = p;
          }
          for (let d of f) d.V = u;
        }
      }
      function C0(n) {
        return (Zp(n) ? "" : `${O0(au([n]))} `) + Lp(n);
      }
      function O0(n) {
        return `"${n}"‎`;
      }
      function Jx(n) {
        if (n.length >= 4 && n[2] == Jp && n[3] == Jp) throw new Error(`invalid label extension: "${wa(n.slice(0, 4))}"`);
      }
      function Gx(n) {
        for (let t = n.lastIndexOf(95); t > 0;) if (n[--t] !== 95) throw new Error("underscore allowed only at start");
      }
      function Vx(n) {
        let e = n[0],
          t = Pp.get(e);
        if (t) throw Uc(`leading ${t}`);
        let r = n.length,
          i = -1;
        for (let a = 1; a < r; a++) {
          e = n[a];
          let l = Pp.get(e);
          if (l) {
            if (i == a) throw Uc(`${t} + ${l}`);
            i = a + 1, t = l;
          }
        }
        if (i == r) throw Uc(`trailing ${t}`);
      }
      function au(n, e = 1 / 0, t = Lp) {
        let r = [];
        zx(n[0]) && r.push("◌"), n.length > e && (e >>= 1, n = [...n.slice(0, e), 8230, ...n.slice(-e)]);
        let i = 0,
          a = n.length;
        for (let l = 0; l < a; l++) {
          let s = n[l];
          Zp(s) && (r.push(wa(n.slice(i, l))), r.push(t(s)), i = l + 1);
        }
        return r.push(wa(n.slice(i, a))), r.join("");
      }
      function zx(n) {
        return E0(), So.has(n);
      }
      function Zp(n) {
        return E0(), Qp.has(n);
      }
      function $x(n) {
        return e_(Qx(n, Xx, r_));
      }
      function Qx(n, e, t) {
        if (!n) return [];
        E0();
        let r = 0;
        return n.split(Gp).map(i => {
          let a = Ix(i),
            l = {
              input: a,
              offset: r
            };
          r += a.length + 1;
          try {
            let s = l.tokens = n_(a, e, t),
              o = s.length,
              c;
            if (!o) throw new Error("empty label");
            let u = l.output = s.flat();
            if (Gx(u), !(l.emoji = o > 1 || s[0].is_emoji) && u.every(d => d < 128)) Jx(u), c = "ASCII";else {
              let d = s.flatMap(p => p.is_emoji ? [] : p);
              if (!d.length) c = "Emoji";else {
                if (So.has(u[0])) throw Uc("leading combining mark");
                for (let h = 1; h < o; h++) {
                  let g = s[h];
                  if (!g.is_emoji && So.has(g[0])) throw Uc(`emoji + combining mark: "${wa(s[h - 1])} + ${au([g[0]])}"`);
                }
                Vx(u);
                let p = su(new Set(d)),
                  [v] = Zx(p);
                t_(v, d), Yx(v, p), c = v.N;
              }
            }
            l.type = c;
          } catch (s) {
            l.error = s;
          }
          return l;
        });
      }
      function Yx(n, e) {
        let t,
          r = [];
        for (let i of e) {
          let a = Ea.get(i);
          if (a === zp) return;
          if (a) {
            let l = a.M.get(i);
            if (t = t ? t.filter(s => l.has(s)) : su(l), !t.length) return;
          } else r.push(i);
        }
        if (t) {
          for (let i of t) if (r.every(a => Lc(i, a))) throw new Error(`whole-script confusable: ${n.N}/${i.N}`);
        }
      }
      function Zx(n) {
        let e = _a;
        for (let t of n) {
          let r = e.filter(i => Lc(i, t));
          if (!r.length) throw _a.some(i => Lc(i, t)) ? tg(e[0], t) : eg(t);
          if (e = r, r.length == 1) break;
        }
        return e;
      }
      function e_(n) {
        return n.map(({
          input: e,
          error: t,
          output: r
        }) => {
          if (t) {
            let i = t.message;
            throw new Error(n.length == 1 ? i : `Invalid label ${O0(au(e, 63))}: ${i}`);
          }
          return wa(r);
        }).join(Gp);
      }
      function eg(n) {
        return new Error(`disallowed character: ${C0(n)}`);
      }
      function tg(n, e) {
        let t = C0(e),
          r = _a.find(i => i.P.has(e));
        return r && (t = `${r.N} ${t}`), new Error(`illegal mixture: ${n.N} + ${t}`);
      }
      function Uc(n) {
        return new Error(`illegal placement: ${n}`);
      }
      function t_(n, e) {
        for (let t of e) if (!Lc(n, t)) throw tg(n, t);
        if (n.M) {
          let t = qp(e);
          for (let r = 1, i = t.length; r < i; r++) if (w0.has(t[r])) {
            let a = r + 1;
            for (let l; a < i && w0.has(l = t[a]); a++) for (let s = r; s < a; s++) if (t[s] == l) throw new Error(`duplicate non-spacing marks: ${C0(l)}`);
            if (a - r > Ip) throw new Error(`excessive non-spacing marks: ${O0(au(t.slice(r - 1, a)))} (${a - r}/${Ip})`);
            r = a;
          }
        }
      }
      function n_(n, e, t) {
        let r = [],
          i = [];
        for (n = n.slice().reverse(); n.length;) {
          let a = i_(n);
          if (a) i.length && (r.push(e(i)), i = []), r.push(t(a));else {
            let l = n.pop();
            if (To.has(l)) i.push(l);else {
              let s = b0.get(l);
              if (s) i.push(...s);else if (!$p.has(l)) throw eg(l);
            }
          }
        }
        return i.length && r.push(e(i)), r;
      }
      function r_(n) {
        return n.filter(e => e != Vp);
      }
      function i_(n, e) {
        let t = _0,
          r,
          i = n.length;
        for (; i && (t = t.get(n[--i]), !!t);) {
          let {
            V: a
          } = t;
          a && (r = a, n.length = i);
        }
        return r;
      }
      const ng = new Uint8Array(32);
      ng.fill(0);
      function rg(n) {
        return re(n.length !== 0, "invalid ENS name; empty component", "comp", n), n;
      }
      function ig(n) {
        const e = ii(o_(n)),
          t = [];
        if (n.length === 0) return t;
        let r = 0;
        for (let i = 0; i < e.length; i++) e[i] === 46 && (t.push(rg(e.slice(r, i))), r = i + 1);
        return re(r < e.length, "invalid ENS name; empty component", "name", n), t.push(rg(e.slice(r))), t;
      }
      function o_(n) {
        try {
          if (n.length === 0) throw new Error("empty label");
          return $x(n);
        } catch (e) {
          re(!1, `invalid ENS name (${e.message})`, "name", n);
        }
      }
      function A0(n) {
        re(typeof n == "string", "invalid ENS name; not a string", "name", n), re(n.length, "invalid ENS name (empty label)", "name", n);
        let e = ng;
        const t = ig(n);
        for (; t.length;) e = gn(sn([e, gn(t.pop())]));
        return Se(e);
      }
      function s_(n, e) {
        const t = e;
        return re(t <= 255, "DNS encoded label cannot exceed 255", "length", t), Se(sn(ig(n).map(r => {
          re(r.length <= t, `label ${JSON.stringify(n)} exceeds ${t} bytes`, "name", n);
          const i = new Uint8Array(r.length + 1);
          return i.set(r, 1), i[0] = i.length - 1, i;
        }))) + "00";
      }
      const og = new Uint8Array(32);
      og.fill(0);
      const a_ = BigInt(-1),
        sg = BigInt(0),
        ag = BigInt(1),
        c_ = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      function l_(n) {
        const e = ft(n),
          t = e.length % 32;
        return t ? sn([e, og.slice(t)]) : Se(e);
      }
      const u_ = Ii(ag, 32),
        f_ = Ii(sg, 32),
        cg = {
          name: "string",
          version: "string",
          chainId: "uint256",
          verifyingContract: "address",
          salt: "bytes32"
        },
        R0 = ["name", "version", "chainId", "verifyingContract", "salt"];
      function lg(n) {
        return function (e) {
          return re(typeof e == "string", `invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
        };
      }
      const d_ = {
        name: lg("name"),
        version: lg("version"),
        chainId: function (n) {
          const e = Le(n, "domain.chainId");
          return re(e >= 0, "invalid chain ID", "domain.chainId", n), Number.isSafeInteger(e) ? Number(e) : Cr(e);
        },
        verifyingContract: function (n) {
          try {
            return Mt(n).toLowerCase();
          } catch {}
          re(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", n);
        },
        salt: function (n) {
          const e = ft(n, "domain.salt");
          return re(e.length === 32, 'invalid domain value "salt"', "domain.salt", n), Se(e);
        }
      };
      function N0(n) {
        {
          const e = n.match(/^(u?)int(\d+)$/);
          if (e) {
            const t = e[1] === "",
              r = parseInt(e[2]);
            re(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", n);
            const i = wo(c_, t ? r - 1 : r),
              a = t ? (i + ag) * a_ : sg;
            return function (l) {
              const s = Le(l, "value");
              return re(s >= a && s <= i, `value out-of-bounds for ${n}`, "value", s), Ii(t ? fh(s, 256) : s, 32);
            };
          }
        }
        {
          const e = n.match(/^bytes(\d+)$/);
          if (e) {
            const t = parseInt(e[1]);
            return re(t !== 0 && t <= 32 && e[1] === String(t), "invalid bytes width", "type", n), function (r) {
              const i = ft(r);
              return re(i.length === t, `invalid length for ${n}`, "value", r), l_(r);
            };
          }
        }
        switch (n) {
          case "address":
            return function (e) {
              return ri(Mt(e), 32);
            };
          case "bool":
            return function (e) {
              return e ? u_ : f_;
            };
          case "bytes":
            return function (e) {
              return gn(e);
            };
          case "string":
            return function (e) {
              return No(e);
            };
        }
        return null;
      }
      function ug(n, e) {
        return `${n}(${e.map(({
          name: t,
          type: r
        }) => r + " " + t).join(",")})`;
      }
      function cu(n) {
        const e = n.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
        return e ? {
          base: e[1],
          index: e[2] + e[4],
          array: {
            base: e[1],
            prefix: e[1] + e[2],
            count: e[5] ? parseInt(e[5]) : -1
          }
        } : {
          base: n
        };
      }
      const yr = class yr {
        constructor(e) {
          de(this, Of);
          ce(this, "primaryType");
          de(this, xl);
          de(this, Ci);
          de(this, ic);
          z(this, Ci, new Map()), z(this, ic, new Map());
          const t = new Map(),
            r = new Map(),
            i = new Map(),
            a = {};
          Object.keys(e).forEach(o => {
            a[o] = e[o].map(({
              name: c,
              type: u
            }) => {
              let {
                base: f,
                index: d
              } = cu(u);
              return f === "int" && !e.int && (f = "int256"), f === "uint" && !e.uint && (f = "uint256"), {
                name: c,
                type: f + (d || "")
              };
            }), t.set(o, new Set()), r.set(o, []), i.set(o, new Set());
          }), z(this, xl, JSON.stringify(a));
          for (const o in a) {
            const c = new Set();
            for (const u of a[o]) {
              re(!c.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(o)}`, "types", e), c.add(u.name);
              const f = cu(u.type).base;
              re(f !== o, `circular type reference to ${JSON.stringify(f)}`, "types", e), !N0(f) && (re(r.has(f), `unknown type ${JSON.stringify(f)}`, "types", e), r.get(f).push(o), t.get(o).add(f));
            }
          }
          const l = Array.from(r.keys()).filter(o => r.get(o).length === 0);
          re(l.length !== 0, "missing primary type", "types", e), re(l.length === 1, `ambiguous primary types or unused types: ${l.map(o => JSON.stringify(o)).join(", ")}`, "types", e), Ge(this, {
            primaryType: l[0]
          });
          function s(o, c) {
            re(!c.has(o), `circular type reference to ${JSON.stringify(o)}`, "types", e), c.add(o);
            for (const u of t.get(o)) if (r.has(u)) {
              s(u, c);
              for (const f of c) i.get(f).add(u);
            }
            c.delete(o);
          }
          s(this.primaryType, new Set());
          for (const [o, c] of i) {
            const u = Array.from(c);
            u.sort(), k(this, Ci).set(o, ug(o, a[o]) + u.map(f => ug(f, a[f])).join(""));
          }
        }
        get types() {
          return JSON.parse(k(this, xl));
        }
        getEncoder(e) {
          let t = k(this, ic).get(e);
          return t || (t = _e(this, Of, zb).call(this, e), k(this, ic).set(e, t)), t;
        }
        encodeType(e) {
          const t = k(this, Ci).get(e);
          return re(t, `unknown type: ${JSON.stringify(e)}`, "name", e), t;
        }
        encodeData(e, t) {
          return this.getEncoder(e)(t);
        }
        hashStruct(e, t) {
          return gn(this.encodeData(e, t));
        }
        encode(e) {
          return this.encodeData(this.primaryType, e);
        }
        hash(e) {
          return this.hashStruct(this.primaryType, e);
        }
        _visit(e, t, r) {
          if (N0(e)) return r(e, t);
          const i = cu(e).array;
          if (i) return re(i.count === -1 || i.count === t.length, `array length mismatch; expected length ${i.count}`, "value", t), t.map(l => this._visit(i.prefix, l, r));
          const a = this.types[e];
          if (a) return a.reduce((l, {
            name: s,
            type: o
          }) => (l[s] = this._visit(o, t[s], r), l), {});
          re(!1, `unknown type: ${e}`, "type", e);
        }
        visit(e, t) {
          return this._visit(this.primaryType, e, t);
        }
        static from(e) {
          return new yr(e);
        }
        static getPrimaryType(e) {
          return yr.from(e).primaryType;
        }
        static hashStruct(e, t, r) {
          return yr.from(t).hashStruct(e, r);
        }
        static hashDomain(e) {
          const t = [];
          for (const r in e) {
            if (e[r] == null) continue;
            const i = cg[r];
            re(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), t.push({
              name: r,
              type: i
            });
          }
          return t.sort((r, i) => R0.indexOf(r.name) - R0.indexOf(i.name)), yr.hashStruct("EIP712Domain", {
            EIP712Domain: t
          }, e);
        }
        static encode(e, t, r) {
          return sn(["0x1901", yr.hashDomain(e), yr.from(t).hash(r)]);
        }
        static hash(e, t, r) {
          return gn(yr.encode(e, t, r));
        }
        static async resolveNames(e, t, r, i) {
          e = Object.assign({}, e);
          for (const s in e) e[s] == null && delete e[s];
          const a = {};
          e.verifyingContract && !Xt(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x");
          const l = yr.from(t);
          l.visit(r, (s, o) => (s === "address" && !Xt(o, 20) && (a[o] = "0x"), o));
          for (const s in a) a[s] = await i(s);
          return e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]), r = l.visit(r, (s, o) => s === "address" && a[o] ? a[o] : o), {
            domain: e,
            value: r
          };
        }
        static getPayload(e, t, r) {
          yr.hashDomain(e);
          const i = {},
            a = [];
          R0.forEach(o => {
            const c = e[o];
            c != null && (i[o] = d_[o](c), a.push({
              name: o,
              type: cg[o]
            }));
          });
          const l = yr.from(t);
          t = l.types;
          const s = Object.assign({}, t);
          return re(s.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", t), s.EIP712Domain = a, l.encode(r), {
            types: s,
            domain: i,
            primaryType: l.primaryType,
            message: l.visit(r, (o, c) => {
              if (o.match(/^bytes(\d*)/)) return Se(ft(c));
              if (o.match(/^u?int/)) return Le(c).toString();
              switch (o) {
                case "address":
                  return c.toLowerCase();
                case "bool":
                  return !!c;
                case "string":
                  return re(typeof c == "string", "invalid string", "value", c), c;
              }
              re(!1, "unsupported type", "type", o);
            })
          };
        }
      };
      xl = new WeakMap(), Ci = new WeakMap(), ic = new WeakMap(), Of = new WeakSet(), zb = function (e) {
        {
          const i = N0(e);
          if (i) return i;
        }
        const t = cu(e).array;
        if (t) {
          const i = t.prefix,
            a = this.getEncoder(i);
          return l => {
            re(t.count === -1 || t.count === l.length, `array length mismatch; expected length ${t.count}`, "value", l);
            let s = l.map(a);
            return k(this, Ci).has(i) && (s = s.map(gn)), gn(sn(s));
          };
        }
        const r = this.types[e];
        if (r) {
          const i = No(k(this, Ci).get(e));
          return a => {
            const l = r.map(({
              name: s,
              type: o
            }) => {
              const c = this.getEncoder(o)(a[s]);
              return k(this, Ci).has(o) ? gn(c) : c;
            });
            return l.unshift(i), sn(l);
          };
        }
        re(!1, `unknown type: ${e}`, "type", e);
      };
      let lu = yr;
      function Wn(n) {
        const e = new Set();
        return n.forEach(t => e.add(t)), Object.freeze(e);
      }
      const h_ = Wn("external public payable override".split(" ")),
        fg = "constant external internal payable private public pure view override",
        p_ = Wn(fg.split(" ")),
        dg = "constructor error event fallback function receive struct",
        hg = Wn(dg.split(" ")),
        pg = "calldata memory storage payable indexed",
        g_ = Wn(pg.split(" ")),
        v_ = [dg, pg, "tuple returns", fg].join(" "),
        y_ = Wn(v_.split(" ")),
        m_ = {
          "(": "OPEN_PAREN",
          ")": "CLOSE_PAREN",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          ",": "COMMA",
          "@": "AT"
        },
        b_ = new RegExp("^(\\s*)"),
        w_ = new RegExp("^([0-9]+)"),
        x_ = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
        gg = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
        vg = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"),
        Af = class Af {
          constructor(e) {
            de(this, _l);
            de(this, Pn);
            de(this, Kr);
            z(this, Pn, 0), z(this, Kr, e.slice());
          }
          get offset() {
            return k(this, Pn);
          }
          get length() {
            return k(this, Kr).length - k(this, Pn);
          }
          clone() {
            return new Af(k(this, Kr));
          }
          reset() {
            z(this, Pn, 0);
          }
          popKeyword(e) {
            const t = this.peek();
            if (t.type !== "KEYWORD" || !e.has(t.text)) throw new Error(`expected keyword ${t.text}`);
            return this.pop().text;
          }
          popType(e) {
            if (this.peek().type !== e) {
              const t = this.peek();
              throw new Error(`expected ${e}; got ${t.type} ${JSON.stringify(t.text)}`);
            }
            return this.pop().text;
          }
          popParen() {
            const e = this.peek();
            if (e.type !== "OPEN_PAREN") throw new Error("bad start");
            const t = _e(this, _l, Zd).call(this, k(this, Pn) + 1, e.match + 1);
            return z(this, Pn, e.match + 1), t;
          }
          popParams() {
            const e = this.peek();
            if (e.type !== "OPEN_PAREN") throw new Error("bad start");
            const t = [];
            for (; k(this, Pn) < e.match - 1;) {
              const r = this.peek().linkNext;
              t.push(_e(this, _l, Zd).call(this, k(this, Pn) + 1, r)), z(this, Pn, r);
            }
            return z(this, Pn, e.match + 1), t;
          }
          peek() {
            if (k(this, Pn) >= k(this, Kr).length) throw new Error("out-of-bounds");
            return k(this, Kr)[k(this, Pn)];
          }
          peekKeyword(e) {
            const t = this.peekType("KEYWORD");
            return t != null && e.has(t) ? t : null;
          }
          peekType(e) {
            if (this.length === 0) return null;
            const t = this.peek();
            return t.type === e ? t.text : null;
          }
          pop() {
            const e = this.peek();
            return Dl(this, Pn)._++, e;
          }
          toString() {
            const e = [];
            for (let t = k(this, Pn); t < k(this, Kr).length; t++) {
              const r = k(this, Kr)[t];
              e.push(`${r.type}:${r.text}`);
            }
            return `<TokenString ${e.join(" ")}>`;
          }
        };
      Pn = new WeakMap(), Kr = new WeakMap(), _l = new WeakSet(), Zd = function (e = 0, t = 0) {
        return new Af(k(this, Kr).slice(e, t).map(r => Object.freeze(Object.assign({}, r, {
          match: r.match - e,
          linkBack: r.linkBack - e,
          linkNext: r.linkNext - e
        }))));
      };
      let Rr = Af;
      function ji(n) {
        const e = [],
          t = l => {
            const s = a < n.length ? JSON.stringify(n[a]) : "$EOI";
            throw new Error(`invalid token ${s} at ${a}: ${l}`);
          };
        let r = [],
          i = [],
          a = 0;
        for (; a < n.length;) {
          let l = n.substring(a),
            s = l.match(b_);
          s && (a += s[1].length, l = n.substring(a));
          const o = {
            depth: r.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: a,
            value: -1
          };
          e.push(o);
          let c = m_[l[0]] || "";
          if (c) {
            if (o.type = c, o.text = l[0], a++, c === "OPEN_PAREN") r.push(e.length - 1), i.push(e.length - 1);else if (c == "CLOSE_PAREN") r.length === 0 && t("no matching open bracket"), o.match = r.pop(), e[o.match].match = e.length - 1, o.depth--, o.linkBack = i.pop(), e[o.linkBack].linkNext = e.length - 1;else if (c === "COMMA") o.linkBack = i.pop(), e[o.linkBack].linkNext = e.length - 1, i.push(e.length - 1);else if (c === "OPEN_BRACKET") o.type = "BRACKET";else if (c === "CLOSE_BRACKET") {
              let u = e.pop().text;
              if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                const f = e.pop().text;
                u = f + u, e[e.length - 1].value = ct(f);
              }
              if (e.length === 0 || e[e.length - 1].type !== "BRACKET") throw new Error("missing opening bracket");
              e[e.length - 1].text += u;
            }
            continue;
          }
          if (s = l.match(x_), s) {
            if (o.text = s[1], a += o.text.length, y_.has(o.text)) {
              o.type = "KEYWORD";
              continue;
            }
            if (o.text.match(vg)) {
              o.type = "TYPE";
              continue;
            }
            o.type = "ID";
            continue;
          }
          if (s = l.match(w_), s) {
            o.text = s[1], o.type = "NUMBER", a += o.text.length;
            continue;
          }
          throw new Error(`unexpected token ${JSON.stringify(l[0])} at position ${a}`);
        }
        return new Rr(e.map(l => Object.freeze(l)));
      }
      function yg(n, e) {
        let t = [];
        for (const r in e.keys()) n.has(r) && t.push(r);
        if (t.length > 1) throw new Error(`conflicting types: ${t.join(", ")}`);
      }
      function uu(n, e) {
        if (e.peekKeyword(hg)) {
          const t = e.pop().text;
          if (t !== n) throw new Error(`expected ${n}, got ${t}`);
        }
        return e.popType("ID");
      }
      function ci(n, e) {
        const t = new Set();
        for (;;) {
          const r = n.peekType("KEYWORD");
          if (r == null || e && !e.has(r)) break;
          if (n.pop(), t.has(r)) throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
          t.add(r);
        }
        return Object.freeze(t);
      }
      function mg(n) {
        let e = ci(n, p_);
        return yg(e, Wn("constant payable nonpayable".split(" "))), yg(e, Wn("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
      }
      function li(n, e) {
        return n.popParams().map(t => Sn.from(t, e));
      }
      function bg(n) {
        if (n.peekType("AT")) {
          if (n.pop(), n.peekType("NUMBER")) return Le(n.pop().text);
          throw new Error("invalid gas");
        }
        return null;
      }
      function Do(n) {
        if (n.length) throw new Error(`unexpected tokens at offset ${n.offset}: ${n.toString()}`);
      }
      const __ = new RegExp(/^(.*)\[([0-9]*)\]$/);
      function wg(n) {
        const e = n.match(vg);
        if (re(e, "invalid type", "type", n), n === "uint") return "uint256";
        if (n === "int") return "int256";
        if (e[2]) {
          const t = parseInt(e[2]);
          re(t !== 0 && t <= 32, "invalid bytes length", "type", n);
        } else if (e[3]) {
          const t = parseInt(e[3]);
          re(t !== 0 && t <= 256 && t % 8 === 0, "invalid numeric width", "type", n);
        }
        return n;
      }
      const Zt = {},
        $n = Symbol.for("_ethers_internal"),
        xg = "_ParamTypeInternal",
        _g = "_ErrorInternal",
        Eg = "_EventInternal",
        Cg = "_ConstructorInternal",
        Og = "_FallbackInternal",
        Ag = "_FunctionInternal",
        Rg = "_StructInternal",
        mr = class mr {
          constructor(e, t, r, i, a, l, s, o) {
            de(this, oc);
            ce(this, "name");
            ce(this, "type");
            ce(this, "baseType");
            ce(this, "indexed");
            ce(this, "components");
            ce(this, "arrayLength");
            ce(this, "arrayChildren");
            if (Oc(e, Zt, "ParamType"), Object.defineProperty(this, $n, {
              value: xg
            }), l && (l = Object.freeze(l.slice())), i === "array") {
              if (s == null || o == null) throw new Error("");
            } else if (s != null || o != null) throw new Error("");
            if (i === "tuple") {
              if (l == null) throw new Error("");
            } else if (l != null) throw new Error("");
            Ge(this, {
              name: t,
              type: r,
              baseType: i,
              indexed: a,
              components: l,
              arrayLength: s,
              arrayChildren: o
            });
          }
          format(e) {
            if (e == null && (e = "sighash"), e === "json") {
              const r = this.name || "";
              if (this.isArray()) {
                const a = JSON.parse(this.arrayChildren.format("json"));
                return a.name = r, a.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(a);
              }
              const i = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: r
              };
              return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map(a => JSON.parse(a.format(e)))), JSON.stringify(i);
            }
            let t = "";
            return this.isArray() ? (t += this.arrayChildren.format(e), t += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? t += "(" + this.components.map(r => r.format(e)).join(e === "full" ? ", " : ",") + ")" : t += this.type, e !== "sighash" && (this.indexed === !0 && (t += " indexed"), e === "full" && this.name && (t += " " + this.name)), t;
          }
          isArray() {
            return this.baseType === "array";
          }
          isTuple() {
            return this.baseType === "tuple";
          }
          isIndexable() {
            return this.indexed != null;
          }
          walk(e, t) {
            if (this.isArray()) {
              if (!Array.isArray(e)) throw new Error("invalid array value");
              if (this.arrayLength !== -1 && e.length !== this.arrayLength) throw new Error("array is wrong length");
              const r = this;
              return e.map(i => r.arrayChildren.walk(i, t));
            }
            if (this.isTuple()) {
              if (!Array.isArray(e)) throw new Error("invalid tuple value");
              if (e.length !== this.components.length) throw new Error("array is wrong length");
              const r = this;
              return e.map((i, a) => r.components[a].walk(i, t));
            }
            return t(this.type, e);
          }
          async walkAsync(e, t) {
            const r = [],
              i = [e];
            return _e(this, oc, Kf).call(this, r, e, t, a => {
              i[0] = a;
            }), r.length && (await Promise.all(r)), i[0];
          }
          static from(e, t) {
            if (mr.isParamType(e)) return e;
            if (typeof e == "string") try {
              return mr.from(ji(e), t);
            } catch {
              re(!1, "invalid param type", "obj", e);
            } else if (e instanceof Rr) {
              let s = "",
                o = "",
                c = null;
              ci(e, Wn(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (o = "tuple", c = e.popParams().map(h => mr.from(h)), s = `tuple(${c.map(h => h.format()).join(",")})`) : (s = wg(e.popType("TYPE")), o = s);
              let u = null,
                f = null;
              for (; e.length && e.peekType("BRACKET");) {
                const h = e.pop();
                u = new mr(Zt, "", s, o, null, c, f, u), f = h.value, s += h.text, o = "array", c = null;
              }
              let d = null;
              if (ci(e, g_).has("indexed")) {
                if (!t) throw new Error("");
                d = !0;
              }
              const v = e.peekType("ID") ? e.pop().text : "";
              if (e.length) throw new Error("leftover tokens");
              return new mr(Zt, v, s, o, d, c, f, u);
            }
            const r = e.name;
            re(!r || typeof r == "string" && r.match(gg), "invalid name", "obj.name", r);
            let i = e.indexed;
            i != null && (re(t, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
            let a = e.type,
              l = a.match(__);
            if (l) {
              const s = parseInt(l[2] || "-1"),
                o = mr.from({
                  type: l[1],
                  components: e.components
                });
              return new mr(Zt, r || "", a, "array", i, null, s, o);
            }
            if (a === "tuple" || a.startsWith("tuple(") || a.startsWith("(")) {
              const s = e.components != null ? e.components.map(c => mr.from(c)) : null;
              return new mr(Zt, r || "", a, "tuple", i, s, null, null);
            }
            return a = wg(e.type), new mr(Zt, r || "", a, a, i, null, null, null);
          }
          static isParamType(e) {
            return e && e[$n] === xg;
          }
        };
      oc = new WeakSet(), Kf = function (e, t, r, i) {
        if (this.isArray()) {
          if (!Array.isArray(t)) throw new Error("invalid array value");
          if (this.arrayLength !== -1 && t.length !== this.arrayLength) throw new Error("array is wrong length");
          const l = this.arrayChildren,
            s = t.slice();
          s.forEach((o, c) => {
            var u;
            _e(u = l, oc, Kf).call(u, e, o, r, f => {
              s[c] = f;
            });
          }), i(s);
          return;
        }
        if (this.isTuple()) {
          const l = this.components;
          let s;
          if (Array.isArray(t)) s = t.slice();else {
            if (t == null || typeof t != "object") throw new Error("invalid tuple value");
            s = l.map(o => {
              if (!o.name) throw new Error("cannot use object value with unnamed components");
              if (!(o.name in t)) throw new Error(`missing value for component ${o.name}`);
              return t[o.name];
            });
          }
          if (s.length !== this.components.length) throw new Error("array is wrong length");
          s.forEach((o, c) => {
            var u;
            _e(u = l[c], oc, Kf).call(u, e, o, r, f => {
              s[c] = f;
            });
          }), i(s);
          return;
        }
        const a = r(this.type, t);
        a.then ? e.push(async function () {
          i(await a);
        }()) : i(a);
      };
      let Sn = mr;
      class Po {
        constructor(e, t, r) {
          ce(this, "type");
          ce(this, "inputs");
          Oc(e, Zt, "Fragment"), r = Object.freeze(r.slice()), Ge(this, {
            type: t,
            inputs: r
          });
        }
        static from(e) {
          if (typeof e == "string") {
            try {
              Po.from(JSON.parse(e));
            } catch {}
            return Po.from(ji(e));
          }
          if (e instanceof Rr) switch (e.peekKeyword(hg)) {
            case "constructor":
              return ui.from(e);
            case "error":
              return Qn.from(e);
            case "event":
              return Fr.from(e);
            case "fallback":
            case "receive":
              return fi.from(e);
            case "function":
              return Hr.from(e);
            case "struct":
              return Io.from(e);
          } else if (typeof e == "object") {
            switch (e.type) {
              case "constructor":
                return ui.from(e);
              case "error":
                return Qn.from(e);
              case "event":
                return Fr.from(e);
              case "fallback":
              case "receive":
                return fi.from(e);
              case "function":
                return Hr.from(e);
              case "struct":
                return Io.from(e);
            }
            be(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
              operation: "Fragment.from"
            });
          }
          re(!1, "unsupported frgament object", "obj", e);
        }
        static isConstructor(e) {
          return ui.isFragment(e);
        }
        static isError(e) {
          return Qn.isFragment(e);
        }
        static isEvent(e) {
          return Fr.isFragment(e);
        }
        static isFunction(e) {
          return Hr.isFragment(e);
        }
        static isStruct(e) {
          return Io.isFragment(e);
        }
      }
      class fu extends Po {
        constructor(t, r, i, a) {
          super(t, r, a);
          ce(this, "name");
          re(typeof i == "string" && i.match(gg), "invalid identifier", "name", i), a = Object.freeze(a.slice()), Ge(this, {
            name: i
          });
        }
      }
      function Fc(n, e) {
        return "(" + e.map(t => t.format(n)).join(n === "full" ? ", " : ",") + ")";
      }
      class Qn extends fu {
        constructor(e, t, r) {
          super(e, "error", t, r), Object.defineProperty(this, $n, {
            value: _g
          });
        }
        get selector() {
          return No(this.format("sighash")).substring(0, 10);
        }
        format(e) {
          if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(r => JSON.parse(r.format(e)))
          });
          const t = [];
          return e !== "sighash" && t.push("error"), t.push(this.name + Fc(e, this.inputs)), t.join(" ");
        }
        static from(e) {
          if (Qn.isFragment(e)) return e;
          if (typeof e == "string") return Qn.from(ji(e));
          if (e instanceof Rr) {
            const t = uu("error", e),
              r = li(e);
            return Do(e), new Qn(Zt, t, r);
          }
          return new Qn(Zt, e.name, e.inputs ? e.inputs.map(Sn.from) : []);
        }
        static isFragment(e) {
          return e && e[$n] === _g;
        }
      }
      class Fr extends fu {
        constructor(t, r, i, a) {
          super(t, "event", r, i);
          ce(this, "anonymous");
          Object.defineProperty(this, $n, {
            value: Eg
          }), Ge(this, {
            anonymous: a
          });
        }
        get topicHash() {
          return No(this.format("sighash"));
        }
        format(t) {
          if (t == null && (t = "sighash"), t === "json") return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(i => JSON.parse(i.format(t)))
          });
          const r = [];
          return t !== "sighash" && r.push("event"), r.push(this.name + Fc(t, this.inputs)), t !== "sighash" && this.anonymous && r.push("anonymous"), r.join(" ");
        }
        static getTopicHash(t, r) {
          return r = (r || []).map(a => Sn.from(a)), new Fr(Zt, t, r, !1).topicHash;
        }
        static from(t) {
          if (Fr.isFragment(t)) return t;
          if (typeof t == "string") try {
            return Fr.from(ji(t));
          } catch {
            re(!1, "invalid event fragment", "obj", t);
          } else if (t instanceof Rr) {
            const r = uu("event", t),
              i = li(t, !0),
              a = !!ci(t, Wn(["anonymous"])).has("anonymous");
            return Do(t), new Fr(Zt, r, i, a);
          }
          return new Fr(Zt, t.name, t.inputs ? t.inputs.map(r => Sn.from(r, !0)) : [], !!t.anonymous);
        }
        static isFragment(t) {
          return t && t[$n] === Eg;
        }
      }
      class ui extends Po {
        constructor(t, r, i, a, l) {
          super(t, r, i);
          ce(this, "payable");
          ce(this, "gas");
          Object.defineProperty(this, $n, {
            value: Cg
          }), Ge(this, {
            payable: a,
            gas: l
          });
        }
        format(t) {
          if (be(t != null && t !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
            operation: "format(sighash)"
          }), t === "json") return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(i => JSON.parse(i.format(t)))
          });
          const r = [`constructor${Fc(t, this.inputs)}`];
          return this.payable && r.push("payable"), this.gas != null && r.push(`@${this.gas.toString()}`), r.join(" ");
        }
        static from(t) {
          if (ui.isFragment(t)) return t;
          if (typeof t == "string") try {
            return ui.from(ji(t));
          } catch {
            re(!1, "invalid constuctor fragment", "obj", t);
          } else if (t instanceof Rr) {
            ci(t, Wn(["constructor"]));
            const r = li(t),
              i = !!ci(t, h_).has("payable"),
              a = bg(t);
            return Do(t), new ui(Zt, "constructor", r, i, a);
          }
          return new ui(Zt, "constructor", t.inputs ? t.inputs.map(Sn.from) : [], !!t.payable, t.gas != null ? t.gas : null);
        }
        static isFragment(t) {
          return t && t[$n] === Cg;
        }
      }
      class fi extends Po {
        constructor(t, r, i) {
          super(t, "fallback", r);
          ce(this, "payable");
          Object.defineProperty(this, $n, {
            value: Og
          }), Ge(this, {
            payable: i
          });
        }
        format(t) {
          const r = this.inputs.length === 0 ? "receive" : "fallback";
          if (t === "json") {
            const i = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
              type: r,
              stateMutability: i
            });
          }
          return `${r}()${this.payable ? " payable" : ""}`;
        }
        static from(t) {
          if (fi.isFragment(t)) return t;
          if (typeof t == "string") try {
            return fi.from(ji(t));
          } catch {
            re(!1, "invalid fallback fragment", "obj", t);
          } else if (t instanceof Rr) {
            const r = t.toString(),
              i = t.peekKeyword(Wn(["fallback", "receive"]));
            if (re(i, "type must be fallback or receive", "obj", r), t.popKeyword(Wn(["fallback", "receive"])) === "receive") {
              const o = li(t);
              return re(o.length === 0, "receive cannot have arguments", "obj.inputs", o), ci(t, Wn(["payable"])), Do(t), new fi(Zt, [], !0);
            }
            let l = li(t);
            l.length ? re(l.length === 1 && l[0].type === "bytes", "invalid fallback inputs", "obj.inputs", l.map(o => o.format("minimal")).join(", ")) : l = [Sn.from("bytes")];
            const s = mg(t);
            if (re(s === "nonpayable" || s === "payable", "fallback cannot be constants", "obj.stateMutability", s), ci(t, Wn(["returns"])).has("returns")) {
              const o = li(t);
              re(o.length === 1 && o[0].type === "bytes", "invalid fallback outputs", "obj.outputs", o.map(c => c.format("minimal")).join(", "));
            }
            return Do(t), new fi(Zt, l, s === "payable");
          }
          if (t.type === "receive") return new fi(Zt, [], !0);
          if (t.type === "fallback") {
            const r = [Sn.from("bytes")],
              i = t.stateMutability === "payable";
            return new fi(Zt, r, i);
          }
          re(!1, "invalid fallback description", "obj", t);
        }
        static isFragment(t) {
          return t && t[$n] === Og;
        }
      }
      class Hr extends fu {
        constructor(t, r, i, a, l, s) {
          super(t, "function", r, a);
          ce(this, "constant");
          ce(this, "outputs");
          ce(this, "stateMutability");
          ce(this, "payable");
          ce(this, "gas");
          Object.defineProperty(this, $n, {
            value: Ag
          }), l = Object.freeze(l.slice()), Ge(this, {
            constant: i === "view" || i === "pure",
            gas: s,
            outputs: l,
            payable: i === "payable",
            stateMutability: i
          });
        }
        get selector() {
          return No(this.format("sighash")).substring(0, 10);
        }
        format(t) {
          if (t == null && (t = "sighash"), t === "json") return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(i => JSON.parse(i.format(t))),
            outputs: this.outputs.map(i => JSON.parse(i.format(t)))
          });
          const r = [];
          return t !== "sighash" && r.push("function"), r.push(this.name + Fc(t, this.inputs)), t !== "sighash" && (this.stateMutability !== "nonpayable" && r.push(this.stateMutability), this.outputs && this.outputs.length && (r.push("returns"), r.push(Fc(t, this.outputs))), this.gas != null && r.push(`@${this.gas.toString()}`)), r.join(" ");
        }
        static getSelector(t, r) {
          return r = (r || []).map(a => Sn.from(a)), new Hr(Zt, t, "view", r, [], null).selector;
        }
        static from(t) {
          if (Hr.isFragment(t)) return t;
          if (typeof t == "string") try {
            return Hr.from(ji(t));
          } catch {
            re(!1, "invalid function fragment", "obj", t);
          } else if (t instanceof Rr) {
            const i = uu("function", t),
              a = li(t),
              l = mg(t);
            let s = [];
            ci(t, Wn(["returns"])).has("returns") && (s = li(t));
            const o = bg(t);
            return Do(t), new Hr(Zt, i, l, a, s, o);
          }
          let r = t.stateMutability;
          return r == null && (r = "payable", typeof t.constant == "boolean" ? (r = "view", t.constant || (r = "payable", typeof t.payable == "boolean" && !t.payable && (r = "nonpayable"))) : typeof t.payable == "boolean" && !t.payable && (r = "nonpayable")), new Hr(Zt, t.name, r, t.inputs ? t.inputs.map(Sn.from) : [], t.outputs ? t.outputs.map(Sn.from) : [], t.gas != null ? t.gas : null);
        }
        static isFragment(t) {
          return t && t[$n] === Ag;
        }
      }
      class Io extends fu {
        constructor(e, t, r) {
          super(e, "struct", t, r), Object.defineProperty(this, $n, {
            value: Rg
          });
        }
        format() {
          throw new Error("@TODO");
        }
        static from(e) {
          if (typeof e == "string") try {
            return Io.from(ji(e));
          } catch {
            re(!1, "invalid struct fragment", "obj", e);
          } else if (e instanceof Rr) {
            const t = uu("struct", e),
              r = li(e);
            return Do(e), new Io(Zt, t, r);
          }
          return new Io(Zt, e.name, e.inputs ? e.inputs.map(Sn.from) : []);
        }
        static isFragment(e) {
          return e && e[$n] === Rg;
        }
      }
      const Nr = new Map();
      Nr.set(0, "GENERIC_PANIC"), Nr.set(1, "ASSERT_FALSE"), Nr.set(17, "OVERFLOW"), Nr.set(18, "DIVIDE_BY_ZERO"), Nr.set(33, "ENUM_RANGE_ERROR"), Nr.set(34, "BAD_STORAGE_DATA"), Nr.set(49, "STACK_UNDERFLOW"), Nr.set(50, "ARRAY_RANGE_ERROR"), Nr.set(65, "OUT_OF_MEMORY"), Nr.set(81, "UNINITIALIZED_FUNCTION_CALL");
      const E_ = new RegExp(/^bytes([0-9]*)$/),
        C_ = new RegExp(/^(u?int)([0-9]*)$/);
      let S0 = null,
        Ng = 1024;
      function O_(n, e, t, r) {
        let i = "missing revert data",
          a = null;
        const l = null;
        let s = null;
        if (t) {
          i = "execution reverted";
          const c = ft(t);
          if (t = Se(t), c.length === 0) i += " (no data present; likely require(false) occurred", a = "require(false)";else if (c.length % 32 !== 4) i += " (could not decode reason; invalid data length)";else if (Se(c.slice(0, 4)) === "0x08c379a0") try {
            a = r.decode(["string"], c.slice(4))[0], s = {
              signature: "Error(string)",
              name: "Error",
              args: [a]
            }, i += `: ${JSON.stringify(a)}`;
          } catch {
            i += " (could not decode reason; invalid string data)";
          } else if (Se(c.slice(0, 4)) === "0x4e487b71") try {
            const u = Number(r.decode(["uint256"], c.slice(4))[0]);
            s = {
              signature: "Panic(uint256)",
              name: "Panic",
              args: [u]
            }, a = `Panic due to ${Nr.get(u) || "UNKNOWN"}(${u})`, i += `: ${a}`;
          } catch {
            i += " (could not decode panic code)";
          } else i += " (unknown custom error)";
        }
        const o = {
          to: e.to ? Mt(e.to) : null,
          data: e.data || "0x"
        };
        return e.from && (o.from = Mt(e.from)), Vt(i, "CALL_EXCEPTION", {
          action: n,
          data: t,
          reason: a,
          transaction: o,
          invocation: l,
          revert: s
        });
      }
      const Rf = class Rf {
        constructor() {
          de(this, so);
        }
        getDefaultValue(e) {
          const t = e.map(i => _e(this, so, Ec).call(this, Sn.from(i)));
          return new $l(t, "_").defaultValue();
        }
        encode(e, t) {
          ah(t.length, e.length, "types/values length mismatch");
          const r = e.map(l => _e(this, so, Ec).call(this, Sn.from(l))),
            i = new $l(r, "_"),
            a = new Vf();
          return i.encode(a, t), a.data;
        }
        decode(e, t, r) {
          const i = e.map(l => _e(this, so, Ec).call(this, Sn.from(l)));
          return new $l(i, "_").decode(new zf(t, r, Ng));
        }
        static _setDefaultMaxInflation(e) {
          re(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), Ng = e;
        }
        static defaultAbiCoder() {
          return S0 == null && (S0 = new Rf()), S0;
        }
        static getBuiltinCallException(e, t, r) {
          return O_(e, t, r, Rf.defaultAbiCoder());
        }
      };
      so = new WeakSet(), Ec = function (e) {
        if (e.isArray()) return new qw(_e(this, so, Ec).call(this, e.arrayChildren), e.arrayLength, e.name);
        if (e.isTuple()) return new $l(e.components.map(r => _e(this, so, Ec).call(this, r)), e.name);
        switch (e.baseType) {
          case "address":
            return new Ww(e.name);
          case "bool":
            return new Jw(e.name);
          case "string":
            return new tx(e.name);
          case "bytes":
            return new Gw(e.name);
          case "":
            return new $w(e.name);
        }
        let t = e.type.match(C_);
        if (t) {
          let r = parseInt(t[2] || "256");
          return re(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + t[1] + " bit length", "param", e), new ex(r / 8, t[1] === "int", e.name);
        }
        if (t = e.type.match(E_), t) {
          let r = parseInt(t[1]);
          return re(r !== 0 && r <= 32, "invalid bytes length", "param", e), new Vw(r, e.name);
        }
        re(!1, "invalid type", "type", e.type);
      };
      let Hc = Rf;
      class A_ {
        constructor(e, t, r) {
          ce(this, "fragment");
          ce(this, "name");
          ce(this, "signature");
          ce(this, "topic");
          ce(this, "args");
          const i = e.name,
            a = e.format();
          Ge(this, {
            fragment: e,
            name: i,
            signature: a,
            topic: t,
            args: r
          });
        }
      }
      class R_ {
        constructor(e, t, r, i) {
          ce(this, "fragment");
          ce(this, "name");
          ce(this, "args");
          ce(this, "signature");
          ce(this, "selector");
          ce(this, "value");
          const a = e.name,
            l = e.format();
          Ge(this, {
            fragment: e,
            name: a,
            args: r,
            signature: l,
            selector: t,
            value: i
          });
        }
      }
      class N_ {
        constructor(e, t, r) {
          ce(this, "fragment");
          ce(this, "name");
          ce(this, "args");
          ce(this, "signature");
          ce(this, "selector");
          const i = e.name,
            a = e.format();
          Ge(this, {
            fragment: e,
            name: i,
            args: r,
            signature: a,
            selector: t
          });
        }
      }
      class Sg {
        constructor(e) {
          ce(this, "hash");
          ce(this, "_isIndexed");
          Ge(this, {
            hash: e,
            _isIndexed: !0
          });
        }
        static isIndexed(e) {
          return !!(e && e._isIndexed);
        }
      }
      const Tg = {
          0: "generic panic",
          1: "assert(false)",
          17: "arithmetic overflow",
          18: "division or modulo by zero",
          33: "enum overflow",
          34: "invalid encoded storage byte array accessed",
          49: "out-of-bounds array access; popping on an empty array",
          50: "out-of-bounds access of an array or bytesN",
          65: "out of memory",
          81: "uninitialized function"
        },
        Dg = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: n => `reverted with reason string ${JSON.stringify(n)}`
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: n => {
              let e = "unknown panic code";
              return n >= 0 && n <= 255 && Tg[n.toString()] && (e = Tg[n.toString()]), `reverted with panic code 0x${n.toString(16)} (${e})`;
            }
          }
        },
        zs = class zs {
          constructor(e) {
            de(this, Yr);
            ce(this, "fragments");
            ce(this, "deploy");
            ce(this, "fallback");
            ce(this, "receive");
            de(this, zr);
            de(this, $r);
            de(this, Qr);
            de(this, Kn);
            let t = [];
            typeof e == "string" ? t = JSON.parse(e) : t = e, z(this, Qr, new Map()), z(this, zr, new Map()), z(this, $r, new Map());
            const r = [];
            for (const l of t) try {
              r.push(Po.from(l));
            } catch (s) {
              console.log(`[Warning] Invalid Fragment ${JSON.stringify(l)}:`, s.message);
            }
            Ge(this, {
              fragments: Object.freeze(r)
            });
            let i = null,
              a = !1;
            z(this, Kn, this.getAbiCoder()), this.fragments.forEach((l, s) => {
              let o;
              switch (l.type) {
                case "constructor":
                  if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return;
                  }
                  Ge(this, {
                    deploy: l
                  });
                  return;
                case "fallback":
                  l.inputs.length === 0 ? a = !0 : (re(!i || l.payable !== i.payable, "conflicting fallback fragments", `fragments[${s}]`, l), i = l, a = i.payable);
                  return;
                case "function":
                  o = k(this, Qr);
                  break;
                case "event":
                  o = k(this, $r);
                  break;
                case "error":
                  o = k(this, zr);
                  break;
                default:
                  return;
              }
              const c = l.format();
              o.has(c) || o.set(c, l);
            }), this.deploy || Ge(this, {
              deploy: ui.from("constructor()")
            }), Ge(this, {
              fallback: i,
              receive: a
            });
          }
          format(e) {
            const t = e ? "minimal" : "full";
            return this.fragments.map(i => i.format(t));
          }
          formatJson() {
            const e = this.fragments.map(t => t.format("json"));
            return JSON.stringify(e.map(t => JSON.parse(t)));
          }
          getAbiCoder() {
            return Hc.defaultAbiCoder();
          }
          getFunctionName(e) {
            const t = _e(this, Yr, Lf).call(this, e, null, !1);
            return re(t, "no matching function", "key", e), t.name;
          }
          hasFunction(e) {
            return !!_e(this, Yr, Lf).call(this, e, null, !1);
          }
          getFunction(e, t) {
            return _e(this, Yr, Lf).call(this, e, t || null, !0);
          }
          forEachFunction(e) {
            const t = Array.from(k(this, Qr).keys());
            t.sort((r, i) => r.localeCompare(i));
            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              e(k(this, Qr).get(i), r);
            }
          }
          getEventName(e) {
            const t = _e(this, Yr, Uf).call(this, e, null, !1);
            return re(t, "no matching event", "key", e), t.name;
          }
          hasEvent(e) {
            return !!_e(this, Yr, Uf).call(this, e, null, !1);
          }
          getEvent(e, t) {
            return _e(this, Yr, Uf).call(this, e, t || null, !0);
          }
          forEachEvent(e) {
            const t = Array.from(k(this, $r).keys());
            t.sort((r, i) => r.localeCompare(i));
            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              e(k(this, $r).get(i), r);
            }
          }
          getError(e, t) {
            if (Xt(e)) {
              const i = e.toLowerCase();
              if (Dg[i]) return Qn.from(Dg[i].signature);
              for (const a of k(this, zr).values()) if (i === a.selector) return a;
              return null;
            }
            if (e.indexOf("(") === -1) {
              const i = [];
              for (const [a, l] of k(this, zr)) a.split("(")[0] === e && i.push(l);
              if (i.length === 0) return e === "Error" ? Qn.from("error Error(string)") : e === "Panic" ? Qn.from("error Panic(uint256)") : null;
              if (i.length > 1) {
                const a = i.map(l => JSON.stringify(l.format())).join(", ");
                re(!1, `ambiguous error description (i.e. ${a})`, "name", e);
              }
              return i[0];
            }
            if (e = Qn.from(e).format(), e === "Error(string)") return Qn.from("error Error(string)");
            if (e === "Panic(uint256)") return Qn.from("error Panic(uint256)");
            const r = k(this, zr).get(e);
            return r || null;
          }
          forEachError(e) {
            const t = Array.from(k(this, zr).keys());
            t.sort((r, i) => r.localeCompare(i));
            for (let r = 0; r < t.length; r++) {
              const i = t[r];
              e(k(this, zr).get(i), r);
            }
          }
          _decodeParams(e, t) {
            return k(this, Kn).decode(e, t);
          }
          _encodeParams(e, t) {
            return k(this, Kn).encode(e, t);
          }
          encodeDeploy(e) {
            return this._encodeParams(this.deploy.inputs, e || []);
          }
          decodeErrorResult(e, t) {
            if (typeof e == "string") {
              const r = this.getError(e);
              re(r, "unknown error", "fragment", e), e = r;
            }
            return re(an(t, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", t), this._decodeParams(e.inputs, an(t, 4));
          }
          encodeErrorResult(e, t) {
            if (typeof e == "string") {
              const r = this.getError(e);
              re(r, "unknown error", "fragment", e), e = r;
            }
            return sn([e.selector, this._encodeParams(e.inputs, t || [])]);
          }
          decodeFunctionData(e, t) {
            if (typeof e == "string") {
              const r = this.getFunction(e);
              re(r, "unknown function", "fragment", e), e = r;
            }
            return re(an(t, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", t), this._decodeParams(e.inputs, an(t, 4));
          }
          encodeFunctionData(e, t) {
            if (typeof e == "string") {
              const r = this.getFunction(e);
              re(r, "unknown function", "fragment", e), e = r;
            }
            return sn([e.selector, this._encodeParams(e.inputs, t || [])]);
          }
          decodeFunctionResult(e, t) {
            if (typeof e == "string") {
              const a = this.getFunction(e);
              re(a, "unknown function", "fragment", e), e = a;
            }
            let r = "invalid length for result data";
            const i = Fn(t);
            if (i.length % 32 === 0) try {
              return k(this, Kn).decode(e.outputs, i);
            } catch {
              r = "could not decode result data";
            }
            be(!1, r, "BAD_DATA", {
              value: Se(i),
              info: {
                method: e.name,
                signature: e.format()
              }
            });
          }
          makeError(e, t) {
            const r = ft(e, "data"),
              i = Hc.getBuiltinCallException("call", t, r);
            if (i.message.startsWith("execution reverted (unknown custom error)")) {
              const s = Se(r.slice(0, 4)),
                o = this.getError(s);
              if (o) try {
                const c = k(this, Kn).decode(o.inputs, r.slice(4));
                i.revert = {
                  name: o.name,
                  signature: o.format(),
                  args: c
                }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`;
              } catch {
                i.message = "execution reverted (coult not decode custom error)";
              }
            }
            const l = this.parseTransaction(t);
            return l && (i.invocation = {
              method: l.name,
              signature: l.signature,
              args: l.args
            }), i;
          }
          encodeFunctionResult(e, t) {
            if (typeof e == "string") {
              const r = this.getFunction(e);
              re(r, "unknown function", "fragment", e), e = r;
            }
            return Se(k(this, Kn).encode(e.outputs, t || []));
          }
          encodeFilterTopics(e, t) {
            if (typeof e == "string") {
              const a = this.getEvent(e);
              re(a, "unknown event", "eventFragment", e), e = a;
            }
            be(t.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
              count: t.length,
              expectedCount: e.inputs.length
            });
            const r = [];
            e.anonymous || r.push(e.topicHash);
            const i = (a, l) => a.type === "string" ? No(l) : a.type === "bytes" ? gn(Se(l)) : (a.type === "bool" && typeof l == "boolean" ? l = l ? "0x01" : "0x00" : a.type.match(/^u?int/) ? l = Ii(l) : a.type.match(/^bytes/) ? l = Yb(l, 32) : a.type === "address" && k(this, Kn).encode(["address"], [l]), ri(Se(l), 32));
            for (t.forEach((a, l) => {
              const s = e.inputs[l];
              if (!s.indexed) {
                re(a == null, "cannot filter non-indexed parameters; must be null", "contract." + s.name, a);
                return;
              }
              a == null ? r.push(null) : s.baseType === "array" || s.baseType === "tuple" ? re(!1, "filtering with tuples or arrays not supported", "contract." + s.name, a) : Array.isArray(a) ? r.push(a.map(o => i(s, o))) : r.push(i(s, a));
            }); r.length && r[r.length - 1] === null;) r.pop();
            return r;
          }
          encodeEventLog(e, t) {
            if (typeof e == "string") {
              const l = this.getEvent(e);
              re(l, "unknown event", "eventFragment", e), e = l;
            }
            const r = [],
              i = [],
              a = [];
            return e.anonymous || r.push(e.topicHash), re(t.length === e.inputs.length, "event arguments/values mismatch", "values", t), e.inputs.forEach((l, s) => {
              const o = t[s];
              if (l.indexed) {
                if (l.type === "string") r.push(No(o));else if (l.type === "bytes") r.push(gn(o));else {
                  if (l.baseType === "tuple" || l.baseType === "array") throw new Error("not implemented");
                  r.push(k(this, Kn).encode([l.type], [o]));
                }
              } else i.push(l), a.push(o);
            }), {
              data: k(this, Kn).encode(i, a),
              topics: r
            };
          }
          decodeEventLog(e, t, r) {
            if (typeof e == "string") {
              const p = this.getEvent(e);
              re(p, "unknown event", "eventFragment", e), e = p;
            }
            if (r != null && !e.anonymous) {
              const p = e.topicHash;
              re(Xt(r[0], 32) && r[0].toLowerCase() === p, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
            }
            const i = [],
              a = [],
              l = [];
            e.inputs.forEach((p, v) => {
              p.indexed ? p.type === "string" || p.type === "bytes" || p.baseType === "tuple" || p.baseType === "array" ? (i.push(Sn.from({
                type: "bytes32",
                name: p.name
              })), l.push(!0)) : (i.push(p), l.push(!1)) : (a.push(p), l.push(!1));
            });
            const s = r != null ? k(this, Kn).decode(i, sn(r)) : null,
              o = k(this, Kn).decode(a, t, !0),
              c = [],
              u = [];
            let f = 0,
              d = 0;
            return e.inputs.forEach((p, v) => {
              let h = null;
              if (p.indexed) {
                if (s == null) h = new Sg(null);else if (l[v]) h = new Sg(s[d++]);else try {
                  h = s[d++];
                } catch (g) {
                  h = g;
                }
              } else try {
                h = o[f++];
              } catch (g) {
                h = g;
              }
              c.push(h), u.push(p.name || null);
            }), da.fromItems(c, u);
          }
          parseTransaction(e) {
            const t = ft(e.data, "tx.data"),
              r = Le(e.value != null ? e.value : 0, "tx.value"),
              i = this.getFunction(Se(t.slice(0, 4)));
            if (!i) return null;
            const a = k(this, Kn).decode(i.inputs, t.slice(4));
            return new R_(i, i.selector, a, r);
          }
          parseCallResult(e) {
            throw new Error("@TODO");
          }
          parseLog(e) {
            const t = this.getEvent(e.topics[0]);
            return !t || t.anonymous ? null : new A_(t, t.topicHash, this.decodeEventLog(t, e.data, e.topics));
          }
          parseError(e) {
            const t = Se(e),
              r = this.getError(an(t, 0, 4));
            if (!r) return null;
            const i = k(this, Kn).decode(r.inputs, an(t, 4));
            return new N_(r, r.selector, i);
          }
          static from(e) {
            return e instanceof zs ? e : typeof e == "string" ? new zs(JSON.parse(e)) : typeof e.formatJson == "function" ? new zs(e.formatJson()) : typeof e.format == "function" ? new zs(e.format("json")) : new zs(e);
          }
        };
      zr = new WeakMap(), $r = new WeakMap(), Qr = new WeakMap(), Kn = new WeakMap(), Yr = new WeakSet(), Lf = function (e, t, r) {
        if (Xt(e)) {
          const a = e.toLowerCase();
          for (const l of k(this, Qr).values()) if (a === l.selector) return l;
          return null;
        }
        if (e.indexOf("(") === -1) {
          const a = [];
          for (const [l, s] of k(this, Qr)) l.split("(")[0] === e && a.push(s);
          if (t) {
            const l = t.length > 0 ? t[t.length - 1] : null;
            let s = t.length,
              o = !0;
            Bn.isTyped(l) && l.type === "overrides" && (o = !1, s--);
            for (let c = a.length - 1; c >= 0; c--) {
              const u = a[c].inputs.length;
              u !== s && (!o || u !== s - 1) && a.splice(c, 1);
            }
            for (let c = a.length - 1; c >= 0; c--) {
              const u = a[c].inputs;
              for (let f = 0; f < t.length; f++) if (Bn.isTyped(t[f])) {
                if (f >= u.length) {
                  if (t[f].type === "overrides") continue;
                  a.splice(c, 1);
                  break;
                }
                if (t[f].type !== u[f].baseType) {
                  a.splice(c, 1);
                  break;
                }
              }
            }
          }
          if (a.length === 1 && t && t.length !== a[0].inputs.length) {
            const l = t[t.length - 1];
            (l == null || Array.isArray(l) || typeof l != "object") && a.splice(0, 1);
          }
          if (a.length === 0) return null;
          if (a.length > 1 && r) {
            const l = a.map(s => JSON.stringify(s.format())).join(", ");
            re(!1, `ambiguous function description (i.e. matches ${l})`, "key", e);
          }
          return a[0];
        }
        const i = k(this, Qr).get(Hr.from(e).format());
        return i || null;
      }, Uf = function (e, t, r) {
        if (Xt(e)) {
          const a = e.toLowerCase();
          for (const l of k(this, $r).values()) if (a === l.topicHash) return l;
          return null;
        }
        if (e.indexOf("(") === -1) {
          const a = [];
          for (const [l, s] of k(this, $r)) l.split("(")[0] === e && a.push(s);
          if (t) {
            for (let l = a.length - 1; l >= 0; l--) a[l].inputs.length < t.length && a.splice(l, 1);
            for (let l = a.length - 1; l >= 0; l--) {
              const s = a[l].inputs;
              for (let o = 0; o < t.length; o++) if (Bn.isTyped(t[o]) && t[o].type !== s[o].baseType) {
                a.splice(l, 1);
                break;
              }
            }
          }
          if (a.length === 0) return null;
          if (a.length > 1 && r) {
            const l = a.map(s => JSON.stringify(s.format())).join(", ");
            re(!1, `ambiguous event description (i.e. matches ${l})`, "key", e);
          }
          return a[0];
        }
        const i = k(this, $r).get(Fr.from(e).format());
        return i || null;
      };
      let T0 = zs;
      const Pg = BigInt(0);
      function Ca(n) {
        return n == null ? null : n;
      }
      function dn(n) {
        return n == null ? null : n.toString();
      }
      class Ig {
        constructor(e, t, r) {
          ce(this, "gasPrice");
          ce(this, "maxFeePerGas");
          ce(this, "maxPriorityFeePerGas");
          Ge(this, {
            gasPrice: Ca(e),
            maxFeePerGas: Ca(t),
            maxPriorityFeePerGas: Ca(r)
          });
        }
        toJSON() {
          const {
            gasPrice: e,
            maxFeePerGas: t,
            maxPriorityFeePerGas: r
          } = this;
          return {
            _type: "FeeData",
            gasPrice: dn(e),
            maxFeePerGas: dn(t),
            maxPriorityFeePerGas: dn(r)
          };
        }
      }
      function du(n) {
        const e = {};
        n.to && (e.to = n.to), n.from && (e.from = n.from), n.data && (e.data = Se(n.data));
        const t = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
        for (const i of t) !(i in n) || n[i] == null || (e[i] = Le(n[i], `request.${i}`));
        const r = "type,nonce".split(/,/);
        for (const i of r) !(i in n) || n[i] == null || (e[i] = ct(n[i], `request.${i}`));
        return n.accessList && (e.accessList = Ao(n.accessList)), n.authorizationList && (e.authorizationList = n.authorizationList.slice()), "blockTag" in n && (e.blockTag = n.blockTag), "enableCcipRead" in n && (e.enableCcipRead = !!n.enableCcipRead), "customData" in n && (e.customData = n.customData), "blobVersionedHashes" in n && n.blobVersionedHashes && (e.blobVersionedHashes = n.blobVersionedHashes.slice()), "kzg" in n && (e.kzg = n.kzg), "blobs" in n && n.blobs && (e.blobs = n.blobs.map(i => Wf(i) ? Se(i) : Object.assign({}, i))), e;
      }
      class S_ {
        constructor(e, t) {
          ce(this, "provider");
          ce(this, "number");
          ce(this, "hash");
          ce(this, "timestamp");
          ce(this, "parentHash");
          ce(this, "parentBeaconBlockRoot");
          ce(this, "nonce");
          ce(this, "difficulty");
          ce(this, "gasLimit");
          ce(this, "gasUsed");
          ce(this, "stateRoot");
          ce(this, "receiptsRoot");
          ce(this, "blobGasUsed");
          ce(this, "excessBlobGas");
          ce(this, "miner");
          ce(this, "prevRandao");
          ce(this, "extraData");
          ce(this, "baseFeePerGas");
          de(this, Oi);
          z(this, Oi, e.transactions.map(r => typeof r != "string" ? new Wc(r, t) : r)), Ge(this, {
            provider: t,
            hash: Ca(e.hash),
            number: e.number,
            timestamp: e.timestamp,
            parentHash: e.parentHash,
            parentBeaconBlockRoot: e.parentBeaconBlockRoot,
            nonce: e.nonce,
            difficulty: e.difficulty,
            gasLimit: e.gasLimit,
            gasUsed: e.gasUsed,
            blobGasUsed: e.blobGasUsed,
            excessBlobGas: e.excessBlobGas,
            miner: e.miner,
            prevRandao: Ca(e.prevRandao),
            extraData: e.extraData,
            baseFeePerGas: Ca(e.baseFeePerGas),
            stateRoot: e.stateRoot,
            receiptsRoot: e.receiptsRoot
          });
        }
        get transactions() {
          return k(this, Oi).map(e => typeof e == "string" ? e : e.hash);
        }
        get prefetchedTransactions() {
          const e = k(this, Oi).slice();
          return e.length === 0 ? [] : (be(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
          }), e);
        }
        toJSON() {
          const {
            baseFeePerGas: e,
            difficulty: t,
            extraData: r,
            gasLimit: i,
            gasUsed: a,
            hash: l,
            miner: s,
            prevRandao: o,
            nonce: c,
            number: u,
            parentHash: f,
            parentBeaconBlockRoot: d,
            stateRoot: p,
            receiptsRoot: v,
            timestamp: h,
            transactions: g
          } = this;
          return {
            _type: "Block",
            baseFeePerGas: dn(e),
            difficulty: dn(t),
            extraData: r,
            gasLimit: dn(i),
            gasUsed: dn(a),
            blobGasUsed: dn(this.blobGasUsed),
            excessBlobGas: dn(this.excessBlobGas),
            hash: l,
            miner: s,
            prevRandao: o,
            nonce: c,
            number: u,
            parentHash: f,
            timestamp: h,
            parentBeaconBlockRoot: d,
            stateRoot: p,
            receiptsRoot: v,
            transactions: g
          };
        }
        [Symbol.iterator]() {
          let e = 0;
          const t = this.transactions;
          return {
            next: () => e < this.length ? {
              value: t[e++],
              done: !1
            } : {
              value: void 0,
              done: !0
            }
          };
        }
        get length() {
          return k(this, Oi).length;
        }
        get date() {
          return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
        }
        async getTransaction(e) {
          let t;
          if (typeof e == "number") t = k(this, Oi)[e];else {
            const r = e.toLowerCase();
            for (const i of k(this, Oi)) if (typeof i == "string") {
              if (i !== r) continue;
              t = i;
              break;
            } else {
              if (i.hash !== r) continue;
              t = i;
              break;
            }
          }
          if (t == null) throw new Error("no such tx");
          return typeof t == "string" ? await this.provider.getTransaction(t) : t;
        }
        getPrefetchedTransaction(e) {
          const t = this.prefetchedTransactions;
          if (typeof e == "number") return t[e];
          e = e.toLowerCase();
          for (const r of t) if (r.hash === e) return r;
          re(!1, "no matching transaction", "indexOrHash", e);
        }
        isMined() {
          return !!this.hash;
        }
        isLondon() {
          return !!this.baseFeePerGas;
        }
        orphanedEvent() {
          if (!this.isMined()) throw new Error("");
          return T_(this);
        }
      }
      Oi = new WeakMap();
      class jc {
        constructor(e, t) {
          ce(this, "provider");
          ce(this, "transactionHash");
          ce(this, "blockHash");
          ce(this, "blockNumber");
          ce(this, "removed");
          ce(this, "address");
          ce(this, "data");
          ce(this, "topics");
          ce(this, "index");
          ce(this, "transactionIndex");
          this.provider = t;
          const r = Object.freeze(e.topics.slice());
          Ge(this, {
            transactionHash: e.transactionHash,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            removed: e.removed,
            address: e.address,
            data: e.data,
            topics: r,
            index: e.index,
            transactionIndex: e.transactionIndex
          });
        }
        toJSON() {
          const {
            address: e,
            blockHash: t,
            blockNumber: r,
            data: i,
            index: a,
            removed: l,
            topics: s,
            transactionHash: o,
            transactionIndex: c
          } = this;
          return {
            _type: "log",
            address: e,
            blockHash: t,
            blockNumber: r,
            data: i,
            index: a,
            removed: l,
            topics: s,
            transactionHash: o,
            transactionIndex: c
          };
        }
        async getBlock() {
          const e = await this.provider.getBlock(this.blockHash);
          return be(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
        }
        async getTransaction() {
          const e = await this.provider.getTransaction(this.transactionHash);
          return be(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
        }
        async getTransactionReceipt() {
          const e = await this.provider.getTransactionReceipt(this.transactionHash);
          return be(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
        }
        removedEvent() {
          return D_(this);
        }
      }
      class Bg {
        constructor(e, t) {
          ce(this, "provider");
          ce(this, "to");
          ce(this, "from");
          ce(this, "contractAddress");
          ce(this, "hash");
          ce(this, "index");
          ce(this, "blockHash");
          ce(this, "blockNumber");
          ce(this, "logsBloom");
          ce(this, "gasUsed");
          ce(this, "blobGasUsed");
          ce(this, "cumulativeGasUsed");
          ce(this, "gasPrice");
          ce(this, "blobGasPrice");
          ce(this, "type");
          ce(this, "status");
          ce(this, "root");
          de(this, El);
          z(this, El, Object.freeze(e.logs.map(i => new jc(i, t))));
          let r = Pg;
          e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), Ge(this, {
            provider: t,
            to: e.to,
            from: e.from,
            contractAddress: e.contractAddress,
            hash: e.hash,
            index: e.index,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            logsBloom: e.logsBloom,
            gasUsed: e.gasUsed,
            cumulativeGasUsed: e.cumulativeGasUsed,
            blobGasUsed: e.blobGasUsed,
            gasPrice: r,
            blobGasPrice: e.blobGasPrice,
            type: e.type,
            status: e.status,
            root: e.root
          });
        }
        get logs() {
          return k(this, El);
        }
        toJSON() {
          const {
            to: e,
            from: t,
            contractAddress: r,
            hash: i,
            index: a,
            blockHash: l,
            blockNumber: s,
            logsBloom: o,
            logs: c,
            status: u,
            root: f
          } = this;
          return {
            _type: "TransactionReceipt",
            blockHash: l,
            blockNumber: s,
            contractAddress: r,
            cumulativeGasUsed: dn(this.cumulativeGasUsed),
            from: t,
            gasPrice: dn(this.gasPrice),
            blobGasUsed: dn(this.blobGasUsed),
            blobGasPrice: dn(this.blobGasPrice),
            gasUsed: dn(this.gasUsed),
            hash: i,
            index: a,
            logs: c,
            logsBloom: o,
            root: f,
            status: u,
            to: e
          };
        }
        get length() {
          return this.logs.length;
        }
        [Symbol.iterator]() {
          let e = 0;
          return {
            next: () => e < this.length ? {
              value: this.logs[e++],
              done: !1
            } : {
              value: void 0,
              done: !0
            }
          };
        }
        get fee() {
          return this.gasUsed * this.gasPrice;
        }
        async getBlock() {
          const e = await this.provider.getBlock(this.blockHash);
          if (e == null) throw new Error("TODO");
          return e;
        }
        async getTransaction() {
          const e = await this.provider.getTransaction(this.hash);
          if (e == null) throw new Error("TODO");
          return e;
        }
        async getResult() {
          return await this.provider.getTransactionResult(this.hash);
        }
        async confirmations() {
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        removedEvent() {
          return Mg(this);
        }
        reorderedEvent(e) {
          return be(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "reorderedEvent(other)"
          }), kg(this, e);
        }
      }
      El = new WeakMap();
      const Jd = class Jd {
        constructor(e, t) {
          ce(this, "provider");
          ce(this, "blockNumber");
          ce(this, "blockHash");
          ce(this, "index");
          ce(this, "hash");
          ce(this, "type");
          ce(this, "to");
          ce(this, "from");
          ce(this, "nonce");
          ce(this, "gasLimit");
          ce(this, "gasPrice");
          ce(this, "maxPriorityFeePerGas");
          ce(this, "maxFeePerGas");
          ce(this, "maxFeePerBlobGas");
          ce(this, "data");
          ce(this, "value");
          ce(this, "chainId");
          ce(this, "signature");
          ce(this, "accessList");
          ce(this, "blobVersionedHashes");
          ce(this, "authorizationList");
          de(this, ao);
          this.provider = t, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, z(this, ao, -1);
        }
        toJSON() {
          const {
            blockNumber: e,
            blockHash: t,
            index: r,
            hash: i,
            type: a,
            to: l,
            from: s,
            nonce: o,
            data: c,
            signature: u,
            accessList: f,
            blobVersionedHashes: d
          } = this;
          return {
            _type: "TransactionResponse",
            accessList: f,
            blockNumber: e,
            blockHash: t,
            blobVersionedHashes: d,
            chainId: dn(this.chainId),
            data: c,
            from: s,
            gasLimit: dn(this.gasLimit),
            gasPrice: dn(this.gasPrice),
            hash: i,
            maxFeePerGas: dn(this.maxFeePerGas),
            maxPriorityFeePerGas: dn(this.maxPriorityFeePerGas),
            maxFeePerBlobGas: dn(this.maxFeePerBlobGas),
            nonce: o,
            signature: u,
            to: l,
            index: r,
            type: a,
            value: dn(this.value)
          };
        }
        async getBlock() {
          let e = this.blockNumber;
          if (e == null) {
            const r = await this.getTransaction();
            r && (e = r.blockNumber);
          }
          if (e == null) return null;
          const t = this.provider.getBlock(e);
          if (t == null) throw new Error("TODO");
          return t;
        }
        async getTransaction() {
          return this.provider.getTransaction(this.hash);
        }
        async confirmations() {
          if (this.blockNumber == null) {
            const {
              tx: t,
              blockNumber: r
            } = await pn({
              tx: this.getTransaction(),
              blockNumber: this.provider.getBlockNumber()
            });
            return t == null || t.blockNumber == null ? 0 : r - t.blockNumber + 1;
          }
          return (await this.provider.getBlockNumber()) - this.blockNumber + 1;
        }
        async wait(e, t) {
          const r = e == null ? 1 : e,
            i = t == null ? 0 : t;
          let a = k(this, ao),
            l = -1,
            s = a === -1;
          const o = async () => {
              if (s) return null;
              const {
                blockNumber: d,
                nonce: p
              } = await pn({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from)
              });
              if (p < this.nonce) {
                a = d;
                return;
              }
              if (s) return null;
              const v = await this.getTransaction();
              if (!(v && v.blockNumber != null)) for (l === -1 && (l = a - 3, l < k(this, ao) && (l = k(this, ao))); l <= d;) {
                if (s) return null;
                const h = await this.provider.getBlock(l, !0);
                if (h == null) return;
                for (const g of h) if (g === this.hash) return;
                for (let g = 0; g < h.length; g++) {
                  const b = await h.getTransaction(g);
                  if (b.from === this.from && b.nonce === this.nonce) {
                    if (s) return null;
                    const m = await this.provider.getTransactionReceipt(b.hash);
                    if (m == null || d - m.blockNumber + 1 < r) return;
                    let _ = "replaced";
                    b.data === this.data && b.to === this.to && b.value === this.value ? _ = "repriced" : b.data === "0x" && b.from === b.to && b.value === Pg && (_ = "cancelled"), be(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                      cancelled: _ === "replaced" || _ === "cancelled",
                      reason: _,
                      replacement: b.replaceableTransaction(a),
                      hash: b.hash,
                      receipt: m
                    });
                  }
                }
                l++;
              }
            },
            c = d => {
              if (d == null || d.status !== 0) return d;
              be(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                action: "sendTransaction",
                data: null,
                reason: null,
                invocation: null,
                revert: null,
                transaction: {
                  to: d.to,
                  from: d.from,
                  data: ""
                },
                receipt: d
              });
            },
            u = await this.provider.getTransactionReceipt(this.hash);
          if (r === 0) return c(u);
          if (u) {
            if (r === 1 || (await u.confirmations()) >= r) return c(u);
          } else if (await o(), r === 0) return null;
          return await new Promise((d, p) => {
            const v = [],
              h = () => {
                v.forEach(b => b());
              };
            if (v.push(() => {
              s = !0;
            }), i > 0) {
              const b = setTimeout(() => {
                h(), p(Vt("wait for transaction timeout", "TIMEOUT"));
              }, i);
              v.push(() => {
                clearTimeout(b);
              });
            }
            const g = async b => {
              if ((await b.confirmations()) >= r) {
                h();
                try {
                  d(c(b));
                } catch (m) {
                  p(m);
                }
              }
            };
            if (v.push(() => {
              this.provider.off(this.hash, g);
            }), this.provider.on(this.hash, g), a >= 0) {
              const b = async () => {
                try {
                  await o();
                } catch (m) {
                  if (Nn(m, "TRANSACTION_REPLACED")) {
                    h(), p(m);
                    return;
                  }
                }
                s || this.provider.once("block", b);
              };
              v.push(() => {
                this.provider.off("block", b);
              }), this.provider.once("block", b);
            }
          });
        }
        isMined() {
          return this.blockHash != null;
        }
        isLegacy() {
          return this.type === 0;
        }
        isBerlin() {
          return this.type === 1;
        }
        isLondon() {
          return this.type === 2;
        }
        isCancun() {
          return this.type === 3;
        }
        removedEvent() {
          return be(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          }), Mg(this);
        }
        reorderedEvent(e) {
          return be(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          }), be(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
          }), kg(this, e);
        }
        replaceableTransaction(e) {
          re(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
          const t = new Jd(this, this.provider);
          return z(t, ao, e), t;
        }
      };
      ao = new WeakMap();
      let Wc = Jd;
      function T_(n) {
        return {
          orphan: "drop-block",
          hash: n.hash,
          number: n.number
        };
      }
      function kg(n, e) {
        return {
          orphan: "reorder-transaction",
          tx: n,
          other: e
        };
      }
      function Mg(n) {
        return {
          orphan: "drop-transaction",
          tx: n
        };
      }
      function D_(n) {
        return {
          orphan: "drop-log",
          log: {
            transactionHash: n.transactionHash,
            blockHash: n.blockHash,
            blockNumber: n.blockNumber,
            address: n.address,
            data: n.data,
            topics: Object.freeze(n.topics.slice()),
            index: n.index
          }
        };
      }
      class D0 extends jc {
        constructor(t, r, i) {
          super(t, t.provider);
          ce(this, "interface");
          ce(this, "fragment");
          ce(this, "args");
          const a = r.decodeEventLog(i, t.data, t.topics);
          Ge(this, {
            args: a,
            fragment: i,
            interface: r
          });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      class Kg extends jc {
        constructor(t, r) {
          super(t, t.provider);
          ce(this, "error");
          Ge(this, {
            error: r
          });
        }
      }
      class P_ extends Bg {
        constructor(t, r, i) {
          super(i, r);
          de(this, sc);
          z(this, sc, t);
        }
        get logs() {
          return super.logs.map(t => {
            const r = t.topics.length ? k(this, sc).getEvent(t.topics[0]) : null;
            if (r) try {
              return new D0(t, k(this, sc), r);
            } catch (i) {
              return new Kg(t, i);
            }
            return t;
          });
        }
      }
      sc = new WeakMap();
      class P0 extends Wc {
        constructor(t, r, i) {
          super(i, r);
          de(this, Cl);
          z(this, Cl, t);
        }
        async wait(t, r) {
          const i = await super.wait(t, r);
          return i == null ? null : new P_(k(this, Cl), this.provider, i);
        }
      }
      Cl = new WeakMap();
      class Lg extends gh {
        constructor(t, r, i, a) {
          super(t, r, i);
          ce(this, "log");
          Ge(this, {
            log: a
          });
        }
        async getBlock() {
          return await this.log.getBlock();
        }
        async getTransaction() {
          return await this.log.getTransaction();
        }
        async getTransactionReceipt() {
          return await this.log.getTransactionReceipt();
        }
      }
      class I_ extends Lg {
        constructor(e, t, r, i, a) {
          super(e, t, r, new D0(a, e.interface, i));
          const l = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
          Ge(this, {
            args: l,
            fragment: i
          });
        }
        get eventName() {
          return this.fragment.name;
        }
        get eventSignature() {
          return this.fragment.format();
        }
      }
      const Ug = BigInt(0);
      function Fg(n) {
        return n && typeof n.call == "function";
      }
      function Hg(n) {
        return n && typeof n.estimateGas == "function";
      }
      function hu(n) {
        return n && typeof n.resolveName == "function";
      }
      function jg(n) {
        return n && typeof n.sendTransaction == "function";
      }
      function Wg(n) {
        if (n != null) {
          if (hu(n)) return n;
          if (n.provider) return n.provider;
        }
      }
      class B_ {
        constructor(e, t, r) {
          de(this, Ol);
          ce(this, "fragment");
          if (Ge(this, {
            fragment: t
          }), t.inputs.length < r.length) throw new Error("too many arguments");
          const i = Bo(e.runner, "resolveName"),
            a = hu(i) ? i : null;
          z(this, Ol, async function () {
            const l = await Promise.all(t.inputs.map((s, o) => r[o] == null ? null : s.walkAsync(r[o], (u, f) => u === "address" ? Array.isArray(f) ? Promise.all(f.map(d => jn(d, a))) : jn(f, a) : f)));
            return e.interface.encodeFilterTopics(t, l);
          }());
        }
        getTopicFilter() {
          return k(this, Ol);
        }
      }
      Ol = new WeakMap();
      function Bo(n, e) {
        return n == null ? null : typeof n[e] == "function" ? n : n.provider && typeof n.provider[e] == "function" ? n.provider : null;
      }
      function ko(n) {
        return n == null ? null : n.provider || null;
      }
      async function Xg(n, e) {
        const t = Bn.dereference(n, "overrides");
        re(typeof t == "object", "invalid overrides parameter", "overrides", n);
        const r = du(t);
        return re(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), re(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
      }
      async function k_(n, e, t) {
        const r = Bo(n, "resolveName"),
          i = hu(r) ? r : null;
        return await Promise.all(e.map((a, l) => a.walkAsync(t[l], (s, o) => (o = Bn.dereference(o, s), s === "address" ? jn(o, i) : o))));
      }
      function M_(n) {
        const e = async function (l) {
            const s = await Xg(l, ["data"]);
            s.to = await n.getAddress(), s.from && (s.from = await jn(s.from, Wg(n.runner)));
            const o = n.interface,
              c = Le(s.value || Ug, "overrides.value") === Ug,
              u = (s.data || "0x") === "0x";
            o.fallback && !o.fallback.payable && o.receive && !u && !c && re(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", l), re(o.fallback || u, "cannot send data to receive-only contract", "overrides.data", s.data);
            const f = o.receive || o.fallback && o.fallback.payable;
            return re(f || c, "cannot send value to non-payable fallback", "overrides.value", s.value), re(o.fallback || u, "cannot send data to receive-only contract", "overrides.data", s.data), s;
          },
          t = async function (l) {
            const s = Bo(n.runner, "call");
            be(Fg(s), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
              operation: "call"
            });
            const o = await e(l);
            try {
              return await s.call(o);
            } catch (c) {
              throw jf(c) && c.data ? n.interface.makeError(c.data, o) : c;
            }
          },
          r = async function (l) {
            const s = n.runner;
            be(jg(s), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
              operation: "sendTransaction"
            });
            const o = await s.sendTransaction(await e(l)),
              c = ko(n.runner);
            return new P0(n.interface, c, o);
          },
          i = async function (l) {
            const s = Bo(n.runner, "estimateGas");
            return be(Hg(s), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
              operation: "estimateGas"
            }), await s.estimateGas(await e(l));
          },
          a = async l => await r(l);
        return Ge(a, {
          _contract: n,
          estimateGas: i,
          populateTransaction: e,
          send: r,
          staticCall: t
        }), a;
      }
      function K_(n, e) {
        const t = function (...c) {
            const u = n.interface.getFunction(e, c);
            return be(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key: e,
                args: c
              }
            }), u;
          },
          r = async function (...c) {
            const u = t(...c);
            let f = {};
            if (u.inputs.length + 1 === c.length && (f = await Xg(c.pop()), f.from && (f.from = await jn(f.from, Wg(n.runner)))), u.inputs.length !== c.length) throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            const d = await k_(n.runner, u.inputs, c);
            return Object.assign({}, f, await pn({
              to: n.getAddress(),
              data: n.interface.encodeFunctionData(u, d)
            }));
          },
          i = async function (...c) {
            const u = await s(...c);
            return u.length === 1 ? u[0] : u;
          },
          a = async function (...c) {
            const u = n.runner;
            be(jg(u), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
              operation: "sendTransaction"
            });
            const f = await u.sendTransaction(await r(...c)),
              d = ko(n.runner);
            return new P0(n.interface, d, f);
          },
          l = async function (...c) {
            const u = Bo(n.runner, "estimateGas");
            return be(Hg(u), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
              operation: "estimateGas"
            }), await u.estimateGas(await r(...c));
          },
          s = async function (...c) {
            const u = Bo(n.runner, "call");
            be(Fg(u), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
              operation: "call"
            });
            const f = await r(...c);
            let d = "0x";
            try {
              d = await u.call(f);
            } catch (v) {
              throw jf(v) && v.data ? n.interface.makeError(v.data, f) : v;
            }
            const p = t(...c);
            return n.interface.decodeFunctionResult(p, d);
          },
          o = async (...c) => t(...c).constant ? await i(...c) : await a(...c);
        return Ge(o, {
          name: n.interface.getFunctionName(e),
          _contract: n,
          _key: e,
          getFragment: t,
          estimateGas: l,
          populateTransaction: r,
          send: a,
          staticCall: i,
          staticCallResult: s
        }), Object.defineProperty(o, "fragment", {
          configurable: !1,
          enumerable: !0,
          get: () => {
            const c = n.interface.getFunction(e);
            return be(c, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key: e
              }
            }), c;
          }
        }), o;
      }
      function L_(n, e) {
        const t = function (...i) {
            const a = n.interface.getEvent(e, i);
            return be(a, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key: e,
                args: i
              }
            }), a;
          },
          r = function (...i) {
            return new B_(n, t(...i), i);
          };
        return Ge(r, {
          name: n.interface.getEventName(e),
          _contract: n,
          _key: e,
          getFragment: t
        }), Object.defineProperty(r, "fragment", {
          configurable: !1,
          enumerable: !0,
          get: () => {
            const i = n.interface.getEvent(e);
            return be(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
              operation: "fragment",
              info: {
                key: e
              }
            }), i;
          }
        }), r;
      }
      const pu = Symbol.for("_ethersInternal_contract"),
        qg = new WeakMap();
      function U_(n, e) {
        qg.set(n[pu], e);
      }
      function er(n) {
        return qg.get(n[pu]);
      }
      function F_(n) {
        return n && typeof n == "object" && "getTopicFilter" in n && typeof n.getTopicFilter == "function" && n.fragment;
      }
      async function I0(n, e) {
        let t,
          r = null;
        if (Array.isArray(e)) {
          const a = function (l) {
            if (Xt(l, 32)) return l;
            const s = n.interface.getEvent(l);
            return re(s, "unknown fragment", "name", l), s.topicHash;
          };
          t = e.map(l => l == null ? null : Array.isArray(l) ? l.map(a) : a(l));
        } else e === "*" ? t = [null] : typeof e == "string" ? Xt(e, 32) ? t = [e] : (r = n.interface.getEvent(e), re(r, "unknown fragment", "event", e), t = [r.topicHash]) : F_(e) ? t = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, t = [r.topicHash]) : re(!1, "unknown event name", "event", e);
        t = t.map(a => {
          if (a == null) return null;
          if (Array.isArray(a)) {
            const l = Array.from(new Set(a.map(s => s.toLowerCase())).values());
            return l.length === 1 ? l[0] : (l.sort(), l);
          }
          return a.toLowerCase();
        });
        const i = t.map(a => a == null ? "null" : Array.isArray(a) ? a.join("|") : a).join("&");
        return {
          fragment: r,
          tag: i,
          topics: t
        };
      }
      async function Xc(n, e) {
        const {
          subs: t
        } = er(n);
        return t.get((await I0(n, e)).tag) || null;
      }
      async function Jg(n, e, t) {
        const r = ko(n.runner);
        be(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
          operation: e
        });
        const {
            fragment: i,
            tag: a,
            topics: l
          } = await I0(n, t),
          {
            addr: s,
            subs: o
          } = er(n);
        let c = o.get(a);
        if (!c) {
          const f = {
              address: s || n,
              topics: l
            },
            d = g => {
              let b = i;
              if (b == null) try {
                b = n.interface.getEvent(g.topics[0]);
              } catch {}
              if (b) {
                const m = b,
                  _ = i ? n.interface.decodeEventLog(i, g.data, g.topics) : [];
                k0(n, t, _, N => new I_(n, N, t, m, g));
              } else k0(n, t, [], m => new Lg(n, m, t, g));
            };
          let p = [];
          c = {
            tag: a,
            listeners: [],
            start: () => {
              p.length || p.push(r.on(f, d));
            },
            stop: async () => {
              if (p.length == 0) return;
              let g = p;
              p = [], await Promise.all(g), r.off(f, d);
            }
          }, o.set(a, c);
        }
        return c;
      }
      let B0 = Promise.resolve();
      async function H_(n, e, t, r) {
        await B0;
        const i = await Xc(n, e);
        if (!i) return !1;
        const a = i.listeners.length;
        return i.listeners = i.listeners.filter(({
          listener: l,
          once: s
        }) => {
          const o = Array.from(t);
          r && o.push(r(s ? null : l));
          try {
            l.call(n, ...o);
          } catch {}
          return !s;
        }), i.listeners.length === 0 && (i.stop(), er(n).subs.delete(i.tag)), a > 0;
      }
      async function k0(n, e, t, r) {
        try {
          await B0;
        } catch {}
        const i = H_(n, e, t, r);
        return B0 = i, await i;
      }
      const gu = ["then"];
      qb = pu;
      const Al = class Al {
        constructor(e, t, r, i) {
          ce(this, "target");
          ce(this, "interface");
          ce(this, "runner");
          ce(this, "filters");
          ce(this, qb);
          ce(this, "fallback");
          re(typeof e == "string" || Op(e), "invalid value for Contract target", "target", e), r == null && (r = null);
          const a = T0.from(t);
          Ge(this, {
            target: e,
            runner: r,
            interface: a
          }), Object.defineProperty(this, pu, {
            value: {}
          });
          let l,
            s = null,
            o = null;
          if (i) {
            const f = ko(r);
            o = new P0(this.interface, f, i);
          }
          let c = new Map();
          if (typeof e == "string") {
            if (Xt(e)) s = e, l = Promise.resolve(e);else {
              const f = Bo(r, "resolveName");
              if (!hu(f)) throw Vt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                operation: "resolveName"
              });
              l = f.resolveName(e).then(d => {
                if (d == null) throw Vt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                  value: e
                });
                return er(this).addr = d, d;
              });
            }
          } else l = e.getAddress().then(f => {
            if (f == null) throw new Error("TODO");
            return er(this).addr = f, f;
          });
          U_(this, {
            addrPromise: l,
            addr: s,
            deployTx: o,
            subs: c
          });
          const u = new Proxy({}, {
            get: (f, d, p) => {
              if (typeof d == "symbol" || gu.indexOf(d) >= 0) return Reflect.get(f, d, p);
              try {
                return this.getEvent(d);
              } catch (v) {
                if (!Nn(v, "INVALID_ARGUMENT") || v.argument !== "key") throw v;
              }
            },
            has: (f, d) => gu.indexOf(d) >= 0 ? Reflect.has(f, d) : Reflect.has(f, d) || this.interface.hasEvent(String(d))
          });
          return Ge(this, {
            filters: u
          }), Ge(this, {
            fallback: a.receive || a.fallback ? M_(this) : null
          }), new Proxy(this, {
            get: (f, d, p) => {
              if (typeof d == "symbol" || d in f || gu.indexOf(d) >= 0) return Reflect.get(f, d, p);
              try {
                return f.getFunction(d);
              } catch (v) {
                if (!Nn(v, "INVALID_ARGUMENT") || v.argument !== "key") throw v;
              }
            },
            has: (f, d) => typeof d == "symbol" || d in f || gu.indexOf(d) >= 0 ? Reflect.has(f, d) : f.interface.hasFunction(d)
          });
        }
        connect(e) {
          return new Al(this.target, this.interface, e);
        }
        attach(e) {
          return new Al(e, this.interface, this.runner);
        }
        async getAddress() {
          return await er(this).addrPromise;
        }
        async getDeployedCode() {
          const e = ko(this.runner);
          be(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "getDeployedCode"
          });
          const t = await e.getCode(await this.getAddress());
          return t === "0x" ? null : t;
        }
        async waitForDeployment() {
          const e = this.deploymentTransaction();
          if (e) return await e.wait(), this;
          if ((await this.getDeployedCode()) != null) return this;
          const r = ko(this.runner);
          return be(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "waitForDeployment"
          }), new Promise((i, a) => {
            const l = async () => {
              try {
                if ((await this.getDeployedCode()) != null) return i(this);
                r.once("block", l);
              } catch (s) {
                a(s);
              }
            };
            l();
          });
        }
        deploymentTransaction() {
          return er(this).deployTx;
        }
        getFunction(e) {
          return typeof e != "string" && (e = e.format()), K_(this, e);
        }
        getEvent(e) {
          return typeof e != "string" && (e = e.format()), L_(this, e);
        }
        async queryTransaction(e) {
          throw new Error("@TODO");
        }
        async queryFilter(e, t, r) {
          t == null && (t = 0), r == null && (r = "latest");
          const {
              addr: i,
              addrPromise: a
            } = er(this),
            l = i || (await a),
            {
              fragment: s,
              topics: o
            } = await I0(this, e),
            c = {
              address: l,
              topics: o,
              fromBlock: t,
              toBlock: r
            },
            u = ko(this.runner);
          return be(u, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
            operation: "queryFilter"
          }), (await u.getLogs(c)).map(f => {
            let d = s;
            if (d == null) try {
              d = this.interface.getEvent(f.topics[0]);
            } catch {}
            if (d) try {
              return new D0(f, this.interface, d);
            } catch (p) {
              return new Kg(f, p);
            }
            return new jc(f, u);
          });
        }
        async on(e, t) {
          const r = await Jg(this, "on", e);
          return r.listeners.push({
            listener: t,
            once: !1
          }), r.start(), this;
        }
        async once(e, t) {
          const r = await Jg(this, "once", e);
          return r.listeners.push({
            listener: t,
            once: !0
          }), r.start(), this;
        }
        async emit(e, ...t) {
          return await k0(this, e, t, null);
        }
        async listenerCount(e) {
          if (e) {
            const i = await Xc(this, e);
            return i ? i.listeners.length : 0;
          }
          const {
            subs: t
          } = er(this);
          let r = 0;
          for (const {
            listeners: i
          } of t.values()) r += i.length;
          return r;
        }
        async listeners(e) {
          if (e) {
            const i = await Xc(this, e);
            return i ? i.listeners.map(({
              listener: a
            }) => a) : [];
          }
          const {
            subs: t
          } = er(this);
          let r = [];
          for (const {
            listeners: i
          } of t.values()) r = r.concat(i.map(({
            listener: a
          }) => a));
          return r;
        }
        async off(e, t) {
          const r = await Xc(this, e);
          if (!r) return this;
          if (t) {
            const i = r.listeners.map(({
              listener: a
            }) => a).indexOf(t);
            i >= 0 && r.listeners.splice(i, 1);
          }
          return (t == null || r.listeners.length === 0) && (r.stop(), er(this).subs.delete(r.tag)), this;
        }
        async removeAllListeners(e) {
          if (e) {
            const t = await Xc(this, e);
            if (!t) return this;
            t.stop(), er(this).subs.delete(t.tag);
          } else {
            const {
              subs: t
            } = er(this);
            for (const {
              tag: r,
              stop: i
            } of t.values()) i(), t.delete(r);
          }
          return this;
        }
        async addListener(e, t) {
          return await this.on(e, t);
        }
        async removeListener(e, t) {
          return await this.off(e, t);
        }
        static buildClass(e) {
          class t extends Al {
            constructor(i, a = null) {
              super(i, e, a);
            }
          }
          return t;
        }
        static from(e, t, r) {
          return r == null && (r = null), new this(e, t, r);
        }
      };
      let M0 = Al;
      function j_() {
        return M0;
      }
      class Mo extends j_() {}
      function K0(n) {
        return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : re(!1, "unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
      }
      class W_ {
        constructor(e) {
          ce(this, "name");
          Ge(this, {
            name: e
          });
        }
        connect(e) {
          return this;
        }
        supportsCoinType(e) {
          return !1;
        }
        async encodeAddress(e, t) {
          throw new Error("unsupported coin");
        }
        async decodeAddress(e, t) {
          throw new Error("unsupported coin");
        }
      }
      const Gg = new RegExp("^(ipfs)://(.*)$", "i"),
        Vg = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), Gg, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")],
        ac = class ac {
          constructor(e, t, r) {
            de(this, lo);
            ce(this, "provider");
            ce(this, "address");
            ce(this, "name");
            de(this, co);
            de(this, $s);
            Ge(this, {
              provider: e,
              address: t,
              name: r
            }), z(this, co, null), z(this, $s, new Mo(t, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], e));
          }
          async supportsWildcard() {
            return k(this, co) == null && z(this, co, (async () => {
              try {
                return await k(this, $s).supportsInterface("0x9061b923");
              } catch (e) {
                if (Nn(e, "CALL_EXCEPTION")) return !1;
                throw z(this, co, null), e;
              }
            })()), await k(this, co);
          }
          async getAddress(e) {
            if (e == null && (e = 60), e === 60) try {
              const a = await _e(this, lo, Cc).call(this, "addr(bytes32)");
              return a == null || a === Pc ? null : a;
            } catch (a) {
              if (Nn(a, "CALL_EXCEPTION")) return null;
              throw a;
            }
            if (e >= 0 && e < 2147483648) {
              let a = e + 2147483648;
              const l = await _e(this, lo, Cc).call(this, "addr(bytes32,uint)", [a]);
              if (Xt(l, 20)) return Mt(l);
            }
            let t = null;
            for (const a of this.provider.plugins) if (a instanceof W_ && a.supportsCoinType(e)) {
              t = a;
              break;
            }
            if (t == null) return null;
            const r = await _e(this, lo, Cc).call(this, "addr(bytes32,uint)", [e]);
            if (r == null || r === "0x") return null;
            const i = await t.decodeAddress(e, r);
            if (i != null) return i;
            be(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${e})`,
              info: {
                coinType: e,
                data: r
              }
            });
          }
          async getText(e) {
            const t = await _e(this, lo, Cc).call(this, "text(bytes32,string)", [e]);
            return t == null || t === "0x" ? null : t;
          }
          async getContentHash() {
            const e = await _e(this, lo, Cc).call(this, "contenthash(bytes32)");
            if (e == null || e === "0x") return null;
            const t = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (t) {
              const i = t[1] === "e3010170" ? "ipfs" : "ipns",
                a = parseInt(t[4], 16);
              if (t[5].length === a * 2) return `${i}://${e1("0x" + t[2])}`;
            }
            const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (r && r[1].length === 64) return `bzz://${r[1]}`;
            be(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
              operation: "getContentHash()",
              info: {
                data: e
              }
            });
          }
          async getAvatar() {
            return (await this._getAvatar()).url;
          }
          async _getAvatar() {
            const e = [{
              type: "name",
              value: this.name
            }];
            try {
              const t = await this.getText("avatar");
              if (t == null) return e.push({
                type: "!avatar",
                value: ""
              }), {
                url: null,
                linkage: e
              };
              e.push({
                type: "avatar",
                value: t
              });
              for (let r = 0; r < Vg.length; r++) {
                const i = t.match(Vg[r]);
                if (i == null) continue;
                const a = i[1].toLowerCase();
                switch (a) {
                  case "https":
                  case "data":
                    return e.push({
                      type: "url",
                      value: t
                    }), {
                      linkage: e,
                      url: t
                    };
                  case "ipfs":
                    {
                      const l = K0(t);
                      return e.push({
                        type: "ipfs",
                        value: t
                      }), e.push({
                        type: "url",
                        value: l
                      }), {
                        linkage: e,
                        url: l
                      };
                    }
                  case "erc721":
                  case "erc1155":
                    {
                      const l = a === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                      e.push({
                        type: a,
                        value: t
                      });
                      const s = await this.getAddress();
                      if (s == null) return e.push({
                        type: "!owner",
                        value: ""
                      }), {
                        url: null,
                        linkage: e
                      };
                      const o = (i[2] || "").split("/");
                      if (o.length !== 2) return e.push({
                        type: `!${a}caip`,
                        value: i[2] || ""
                      }), {
                        url: null,
                        linkage: e
                      };
                      const c = o[1],
                        u = new Mo(o[0], ["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider);
                      if (a === "erc721") {
                        const h = await u.ownerOf(c);
                        if (s !== h) return e.push({
                          type: "!owner",
                          value: h
                        }), {
                          url: null,
                          linkage: e
                        };
                        e.push({
                          type: "owner",
                          value: h
                        });
                      } else if (a === "erc1155") {
                        const h = await u.balanceOf(s, c);
                        if (!h) return e.push({
                          type: "!balance",
                          value: "0"
                        }), {
                          url: null,
                          linkage: e
                        };
                        e.push({
                          type: "balance",
                          value: h.toString()
                        });
                      }
                      let f = await u[l](c);
                      if (f == null || f === "0x") return e.push({
                        type: "!metadata-url",
                        value: ""
                      }), {
                        url: null,
                        linkage: e
                      };
                      e.push({
                        type: "metadata-url-base",
                        value: f
                      }), a === "erc1155" && (f = f.replace("{id}", Ii(c, 32).substring(2)), e.push({
                        type: "metadata-url-expanded",
                        value: f
                      })), f.match(/^ipfs:/i) && (f = K0(f)), e.push({
                        type: "metadata-url",
                        value: f
                      });
                      let d = {};
                      const p = await new Bi(f).send();
                      p.assertOk();
                      try {
                        d = p.bodyJson;
                      } catch {
                        try {
                          e.push({
                            type: "!metadata",
                            value: p.bodyText
                          });
                        } catch {
                          const b = p.body;
                          return b && e.push({
                            type: "!metadata",
                            value: Se(b)
                          }), {
                            url: null,
                            linkage: e
                          };
                        }
                        return {
                          url: null,
                          linkage: e
                        };
                      }
                      if (!d) return e.push({
                        type: "!metadata",
                        value: ""
                      }), {
                        url: null,
                        linkage: e
                      };
                      e.push({
                        type: "metadata",
                        value: JSON.stringify(d)
                      });
                      let v = d.image;
                      if (typeof v != "string") return e.push({
                        type: "!imageUrl",
                        value: ""
                      }), {
                        url: null,
                        linkage: e
                      };
                      if (!v.match(/^(https:\/\/|data:)/i)) {
                        if (v.match(Gg) == null) return e.push({
                          type: "!imageUrl-ipfs",
                          value: v
                        }), {
                          url: null,
                          linkage: e
                        };
                        e.push({
                          type: "imageUrl-ipfs",
                          value: v
                        }), v = K0(v);
                      }
                      return e.push({
                        type: "url",
                        value: v
                      }), {
                        linkage: e,
                        url: v
                      };
                    }
                }
              }
            } catch {}
            return {
              linkage: e,
              url: null
            };
          }
          static async getEnsAddress(e) {
            const t = await e.getNetwork(),
              r = t.getPlugin("org.ethers.plugins.network.Ens");
            return be(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
              operation: "getEnsAddress",
              info: {
                network: t
              }
            }), r.address;
          }
          static async fromName(e, t) {
            var i;
            let r = t;
            for (;;) {
              if (r === "" || r === "." || t !== "eth" && r === "eth") return null;
              const a = await _e(i = ac, Nf, $b).call(i, e, r);
              if (a != null) {
                const l = new ac(e, a, t);
                return r !== t && !(await l.supportsWildcard()) ? null : l;
              }
              r = r.split(".").slice(1).join(".");
            }
          }
        };
      co = new WeakMap(), $s = new WeakMap(), lo = new WeakSet(), Cc = async function (e, t) {
        t = (t || []).slice();
        const r = k(this, $s).interface;
        t.unshift(A0(this.name));
        let i = null;
        (await this.supportsWildcard()) && (i = r.getFunction(e), be(i, "missing fragment", "UNKNOWN_ERROR", {
          info: {
            funcName: e
          }
        }), t = [s_(this.name, 255), r.encodeFunctionData(i, t)], e = "resolve(bytes,bytes)"), t.push({
          enableCcipRead: !0
        });
        try {
          const a = await k(this, $s)[e](...t);
          return i ? r.decodeFunctionResult(i, a)[0] : a;
        } catch (a) {
          if (!Nn(a, "CALL_EXCEPTION")) throw a;
        }
        return null;
      }, Nf = new WeakSet(), $b = async function (e, t) {
        const r = await ac.getEnsAddress(e);
        try {
          const a = await new Mo(r, ["function resolver(bytes32) view returns (address)"], e).resolver(A0(t), {
            enableCcipRead: !0
          });
          return a === Pc ? null : a;
        } catch (i) {
          throw i;
        }
        return null;
      }, de(ac, Nf);
      let vu = ac;
      const zg = BigInt(0);
      function xt(n, e) {
        return function (t) {
          return t == null ? e : n(t);
        };
      }
      function qc(n, e) {
        return t => {
          if (e && t == null) return null;
          if (!Array.isArray(t)) throw new Error("not an array");
          return t.map(r => n(r));
        };
      }
      function Jc(n, e) {
        return t => {
          const r = {};
          for (const i in n) {
            let a = i;
            if (e && i in e && !(a in t)) {
              for (const l of e[i]) if (l in t) {
                a = l;
                break;
              }
            }
            try {
              const l = n[i](t[a]);
              l !== void 0 && (r[i] = l);
            } catch (l) {
              const s = l instanceof Error ? l.message : "not-an-error";
              be(!1, `invalid value for value.${i} (${s})`, "BAD_DATA", {
                value: t
              });
            }
          }
          return r;
        };
      }
      function X_(n) {
        switch (n) {
          case !0:
          case "true":
            return !0;
          case !1:
          case "false":
            return !1;
        }
        re(!1, `invalid boolean; ${JSON.stringify(n)}`, "value", n);
      }
      function Oa(n) {
        return re(Xt(n, !0), "invalid data", "value", n), n;
      }
      function Tn(n) {
        return re(Xt(n, 32), "invalid hash", "value", n), n;
      }
      const q_ = Jc({
        address: Mt,
        blockHash: Tn,
        blockNumber: ct,
        data: Oa,
        index: ct,
        removed: xt(X_, !1),
        topics: qc(Tn),
        transactionHash: Tn,
        transactionIndex: ct
      }, {
        index: ["logIndex"]
      });
      function J_(n) {
        return q_(n);
      }
      const G_ = Jc({
        hash: xt(Tn),
        parentHash: Tn,
        parentBeaconBlockRoot: xt(Tn, null),
        number: ct,
        timestamp: ct,
        nonce: xt(Oa),
        difficulty: Le,
        gasLimit: Le,
        gasUsed: Le,
        stateRoot: xt(Tn, null),
        receiptsRoot: xt(Tn, null),
        blobGasUsed: xt(Le, null),
        excessBlobGas: xt(Le, null),
        miner: xt(Mt),
        prevRandao: xt(Tn, null),
        extraData: Oa,
        baseFeePerGas: xt(Le)
      }, {
        prevRandao: ["mixHash"]
      });
      function V_(n) {
        const e = G_(n);
        return e.transactions = n.transactions.map(t => typeof t == "string" ? t : $g(t)), e;
      }
      const z_ = Jc({
        transactionIndex: ct,
        blockNumber: ct,
        transactionHash: Tn,
        address: Mt,
        topics: qc(Tn),
        data: Oa,
        index: ct,
        blockHash: Tn
      }, {
        index: ["logIndex"]
      });
      function $_(n) {
        return z_(n);
      }
      const Q_ = Jc({
        to: xt(Mt, null),
        from: xt(Mt, null),
        contractAddress: xt(Mt, null),
        index: ct,
        root: xt(Se),
        gasUsed: Le,
        blobGasUsed: xt(Le, null),
        logsBloom: xt(Oa),
        blockHash: Tn,
        hash: Tn,
        logs: qc($_),
        blockNumber: ct,
        cumulativeGasUsed: Le,
        effectiveGasPrice: xt(Le),
        blobGasPrice: xt(Le, null),
        status: xt(ct),
        type: xt(ct, 0)
      }, {
        effectiveGasPrice: ["gasPrice"],
        hash: ["transactionHash"],
        index: ["transactionIndex"]
      });
      function Y_(n) {
        return Q_(n);
      }
      function $g(n) {
        n.to && Le(n.to) === zg && (n.to = "0x0000000000000000000000000000000000000000");
        const e = Jc({
          hash: Tn,
          index: xt(ct, void 0),
          type: t => t === "0x" || t == null ? 0 : ct(t),
          accessList: xt(Ao, null),
          blobVersionedHashes: xt(qc(Tn, !0), null),
          authorizationList: xt(qc(t => {
            let r;
            if (t.signature) r = t.signature;else {
              let i = t.yParity;
              i === "0x1b" ? i = 0 : i === "0x1c" && (i = 1), r = Object.assign({}, t, {
                yParity: i
              });
            }
            return {
              address: Mt(t.address),
              chainId: Le(t.chainId),
              nonce: Le(t.nonce),
              signature: zn.from(r)
            };
          }, !1), null),
          blockHash: xt(Tn, null),
          blockNumber: xt(ct, null),
          transactionIndex: xt(ct, null),
          from: Mt,
          gasPrice: xt(Le),
          maxPriorityFeePerGas: xt(Le),
          maxFeePerGas: xt(Le),
          maxFeePerBlobGas: xt(Le, null),
          gasLimit: Le,
          to: xt(Mt, null),
          value: Le,
          nonce: ct,
          data: Oa,
          creates: xt(Mt, null),
          chainId: xt(Le, null)
        }, {
          data: ["input"],
          gasLimit: ["gas"],
          index: ["transactionIndex"]
        })(n);
        if (e.to == null && e.creates == null && (e.creates = jw(e)), (n.type === 1 || n.type === 2) && n.accessList == null && (e.accessList = []), n.signature ? e.signature = zn.from(n.signature) : e.signature = zn.from(n), e.chainId == null) {
          const t = e.signature.legacyChainId;
          t != null && (e.chainId = t);
        }
        return e.blockHash && Le(e.blockHash) === zg && (e.blockHash = null), e;
      }
      const Z_ = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
      class Gc {
        constructor(e) {
          ce(this, "name");
          Ge(this, {
            name: e
          });
        }
        clone() {
          return new Gc(this.name);
        }
      }
      class yu extends Gc {
        constructor(t, r) {
          t == null && (t = 0);
          super(`org.ethers.network.plugins.GasCost#${t || 0}`);
          ce(this, "effectiveBlock");
          ce(this, "txBase");
          ce(this, "txCreate");
          ce(this, "txDataZero");
          ce(this, "txDataNonzero");
          ce(this, "txAccessListStorageKey");
          ce(this, "txAccessListAddress");
          const i = {
            effectiveBlock: t
          };
          function a(l, s) {
            let o = (r || {})[l];
            o == null && (o = s), re(typeof o == "number", `invalud value for ${l}`, "costs", r), i[l] = o;
          }
          a("txBase", 21e3), a("txCreate", 32e3), a("txDataZero", 4), a("txDataNonzero", 16), a("txAccessListStorageKey", 1900), a("txAccessListAddress", 2400), Ge(this, i);
        }
        clone() {
          return new yu(this.effectiveBlock, this);
        }
      }
      class mu extends Gc {
        constructor(t, r) {
          super("org.ethers.plugins.network.Ens");
          ce(this, "address");
          ce(this, "targetNetwork");
          Ge(this, {
            address: t || Z_,
            targetNetwork: r == null ? 1 : r
          });
        }
        clone() {
          return new mu(this.address, this.targetNetwork);
        }
      }
      class eE extends Gc {
        constructor(t, r) {
          super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          de(this, Rl);
          de(this, Nl);
          z(this, Rl, t), z(this, Nl, r);
        }
        get url() {
          return k(this, Rl);
        }
        get processFunc() {
          return k(this, Nl);
        }
        clone() {
          return this;
        }
      }
      Rl = new WeakMap(), Nl = new WeakMap();
      const L0 = new Map(),
        uc = class uc {
          constructor(e, t) {
            de(this, cc);
            de(this, lc);
            de(this, uo);
            z(this, cc, e), z(this, lc, Le(t)), z(this, uo, new Map());
          }
          toJSON() {
            return {
              name: this.name,
              chainId: String(this.chainId)
            };
          }
          get name() {
            return k(this, cc);
          }
          set name(e) {
            z(this, cc, e);
          }
          get chainId() {
            return k(this, lc);
          }
          set chainId(e) {
            z(this, lc, Le(e, "chainId"));
          }
          matches(e) {
            if (e == null) return !1;
            if (typeof e == "string") {
              try {
                return this.chainId === Le(e);
              } catch {}
              return this.name === e;
            }
            if (typeof e == "number" || typeof e == "bigint") {
              try {
                return this.chainId === Le(e);
              } catch {}
              return !1;
            }
            if (typeof e == "object") {
              if (e.chainId != null) {
                try {
                  return this.chainId === Le(e.chainId);
                } catch {}
                return !1;
              }
              return e.name != null ? this.name === e.name : !1;
            }
            return !1;
          }
          get plugins() {
            return Array.from(k(this, uo).values());
          }
          attachPlugin(e) {
            if (k(this, uo).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
            return k(this, uo).set(e.name, e.clone()), this;
          }
          getPlugin(e) {
            return k(this, uo).get(e) || null;
          }
          getPlugins(e) {
            return this.plugins.filter(t => t.name.split("#")[0] === e);
          }
          clone() {
            const e = new uc(this.name, this.chainId);
            return this.plugins.forEach(t => {
              e.attachPlugin(t.clone());
            }), e;
          }
          computeIntrinsicGas(e) {
            const t = this.getPlugin("org.ethers.plugins.network.GasCost") || new yu();
            let r = t.txBase;
            if (e.to == null && (r += t.txCreate), e.data) for (let i = 2; i < e.data.length; i += 2) e.data.substring(i, i + 2) === "00" ? r += t.txDataZero : r += t.txDataNonzero;
            if (e.accessList) {
              const i = Ao(e.accessList);
              for (const a in i) r += t.txAccessListAddress + t.txAccessListStorageKey * i[a].storageKeys.length;
            }
            return r;
          }
          static from(e) {
            if (tE(), e == null) return uc.from("mainnet");
            if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
              const t = L0.get(e);
              if (t) return t();
              if (typeof e == "bigint") return new uc("unknown", e);
              re(!1, "unknown network", "network", e);
            }
            if (typeof e.clone == "function") return e.clone();
            if (typeof e == "object") {
              re(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
              const t = new uc(e.name, e.chainId);
              return (e.ensAddress || e.ensNetwork != null) && t.attachPlugin(new mu(e.ensAddress, e.ensNetwork)), t;
            }
            re(!1, "invalid network", "network", e);
          }
          static register(e, t) {
            typeof e == "number" && (e = BigInt(e));
            const r = L0.get(e);
            r && re(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), L0.set(e, t);
          }
        };
      cc = new WeakMap(), lc = new WeakMap(), uo = new WeakMap();
      let jr = uc;
      function Qg(n, e) {
        const t = String(n);
        if (!t.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${n}`);
        const r = t.split(".");
        if (r.length === 1 && r.push(""), r.length !== 2) throw new Error(`invalid gwei value: ${n}`);
        for (; r[1].length < e;) r[1] += "0";
        if (r[1].length > 9) {
          let i = BigInt(r[1].substring(0, 9));
          r[1].substring(9).match(/^0+$/) || i++, r[1] = i.toString();
        }
        return BigInt(r[0] + r[1]);
      }
      function Yg(n) {
        return new eE(n, async (e, t, r) => {
          r.setHeader("User-Agent", "ethers");
          let i;
          try {
            const [a, l] = await Promise.all([r.send(), e()]);
            i = a;
            const s = i.bodyJson.standard;
            return {
              gasPrice: l.gasPrice,
              maxFeePerGas: Qg(s.maxFee, 9),
              maxPriorityFeePerGas: Qg(s.maxPriorityFee, 9)
            };
          } catch (a) {
            be(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", {
              request: r,
              response: i,
              error: a
            });
          }
        });
      }
      let Zg = !1;
      function tE() {
        if (Zg) return;
        Zg = !0;
        function n(e, t, r) {
          const i = function () {
            const a = new jr(e, t);
            return r.ensNetwork != null && a.attachPlugin(new mu(null, r.ensNetwork)), a.attachPlugin(new yu()), (r.plugins || []).forEach(l => {
              a.attachPlugin(l);
            }), a;
          };
          jr.register(e, i), jr.register(t, i), r.altNames && r.altNames.forEach(a => {
            jr.register(a, i);
          });
        }
        n("mainnet", 1, {
          ensNetwork: 1,
          altNames: ["homestead"]
        }), n("ropsten", 3, {
          ensNetwork: 3
        }), n("rinkeby", 4, {
          ensNetwork: 4
        }), n("goerli", 5, {
          ensNetwork: 5
        }), n("kovan", 42, {
          ensNetwork: 42
        }), n("sepolia", 11155111, {
          ensNetwork: 11155111
        }), n("holesky", 17e3, {
          ensNetwork: 17e3
        }), n("classic", 61, {}), n("classicKotti", 6, {}), n("arbitrum", 42161, {
          ensNetwork: 1
        }), n("arbitrum-goerli", 421613, {}), n("arbitrum-sepolia", 421614, {}), n("base", 8453, {
          ensNetwork: 1
        }), n("base-goerli", 84531, {}), n("base-sepolia", 84532, {}), n("bnb", 56, {
          ensNetwork: 1
        }), n("bnbt", 97, {}), n("linea", 59144, {
          ensNetwork: 1
        }), n("linea-goerli", 59140, {}), n("linea-sepolia", 59141, {}), n("matic", 137, {
          ensNetwork: 1,
          plugins: [Yg("https://gasstation.polygon.technology/v2")]
        }), n("matic-amoy", 80002, {}), n("matic-mumbai", 80001, {
          altNames: ["maticMumbai", "maticmum"],
          plugins: [Yg("https://gasstation-testnet.polygon.technology/v2")]
        }), n("optimism", 10, {
          ensNetwork: 1,
          plugins: []
        }), n("optimism-goerli", 420, {}), n("optimism-sepolia", 11155420, {}), n("xdai", 100, {
          ensNetwork: 1
        });
      }
      function U0(n) {
        return JSON.parse(JSON.stringify(n));
      }
      class nE {
        constructor(e) {
          de(this, fc);
          de(this, Ai);
          de(this, br);
          de(this, fo);
          de(this, Zr);
          z(this, Ai, e), z(this, br, null), z(this, fo, 4e3), z(this, Zr, -2);
        }
        get pollingInterval() {
          return k(this, fo);
        }
        set pollingInterval(e) {
          z(this, fo, e);
        }
        start() {
          k(this, br) || (z(this, br, k(this, Ai)._setTimeout(_e(this, fc, Ff).bind(this), k(this, fo))), _e(this, fc, Ff).call(this));
        }
        stop() {
          k(this, br) && (k(this, Ai)._clearTimeout(k(this, br)), z(this, br, null));
        }
        pause(e) {
          this.stop(), e && z(this, Zr, -2);
        }
        resume() {
          this.start();
        }
      }
      Ai = new WeakMap(), br = new WeakMap(), fo = new WeakMap(), Zr = new WeakMap(), fc = new WeakSet(), Ff = async function () {
        try {
          const e = await k(this, Ai).getBlockNumber();
          if (k(this, Zr) === -2) {
            z(this, Zr, e);
            return;
          }
          if (e !== k(this, Zr)) {
            for (let t = k(this, Zr) + 1; t <= e; t++) {
              if (k(this, br) == null) return;
              await k(this, Ai).emit("block", t);
            }
            z(this, Zr, e);
          }
        } catch {}
        k(this, br) != null && z(this, br, k(this, Ai)._setTimeout(_e(this, fc, Ff).bind(this), k(this, fo)));
      };
      class F0 {
        constructor(e) {
          de(this, Qs);
          de(this, Ys);
          de(this, ho);
          z(this, Qs, e), z(this, ho, !1), z(this, Ys, t => {
            this._poll(t, k(this, Qs));
          });
        }
        async _poll(e, t) {
          throw new Error("sub-classes must override this");
        }
        start() {
          k(this, ho) || (z(this, ho, !0), k(this, Ys).call(this, -2), k(this, Qs).on("block", k(this, Ys)));
        }
        stop() {
          k(this, ho) && (z(this, ho, !1), k(this, Qs).off("block", k(this, Ys)));
        }
        pause(e) {
          this.stop();
        }
        resume() {
          this.start();
        }
      }
      Qs = new WeakMap(), Ys = new WeakMap(), ho = new WeakMap();
      class rE extends F0 {
        constructor(t, r) {
          super(t);
          de(this, dc);
          de(this, Ri);
          z(this, dc, r), z(this, Ri, -2);
        }
        pause(t) {
          t && z(this, Ri, -2), super.pause(t);
        }
        async _poll(t, r) {
          const i = await r.getBlock(k(this, dc));
          i != null && (k(this, Ri) === -2 ? z(this, Ri, i.number) : i.number > k(this, Ri) && (r.emit(k(this, dc), i.number), z(this, Ri, i.number)));
        }
      }
      dc = new WeakMap(), Ri = new WeakMap();
      class iE extends F0 {
        constructor(t, r) {
          super(t);
          de(this, Sf);
          z(this, Sf, U0(r));
        }
        async _poll(t, r) {
          throw new Error("@TODO");
        }
      }
      Sf = new WeakMap();
      class oE extends F0 {
        constructor(t, r) {
          super(t);
          de(this, hc);
          z(this, hc, r);
        }
        async _poll(t, r) {
          const i = await r.getTransactionReceipt(k(this, hc));
          i && r.emit(k(this, hc), i);
        }
      }
      hc = new WeakMap();
      class H0 {
        constructor(e, t) {
          de(this, Tf);
          de(this, Ni);
          de(this, pc);
          de(this, gc);
          de(this, po);
          de(this, wr);
          z(this, Ni, e), z(this, pc, U0(t)), z(this, gc, _e(this, Tf, Qb).bind(this)), z(this, po, !1), z(this, wr, -2);
        }
        start() {
          k(this, po) || (z(this, po, !0), k(this, wr) === -2 && k(this, Ni).getBlockNumber().then(e => {
            z(this, wr, e);
          }), k(this, Ni).on("block", k(this, gc)));
        }
        stop() {
          k(this, po) && (z(this, po, !1), k(this, Ni).off("block", k(this, gc)));
        }
        pause(e) {
          this.stop(), e && z(this, wr, -2);
        }
        resume() {
          this.start();
        }
      }
      Ni = new WeakMap(), pc = new WeakMap(), gc = new WeakMap(), po = new WeakMap(), wr = new WeakMap(), Tf = new WeakSet(), Qb = async function (e) {
        if (k(this, wr) === -2) return;
        const t = U0(k(this, pc));
        t.fromBlock = k(this, wr) + 1, t.toBlock = e;
        const r = await k(this, Ni).getLogs(t);
        if (r.length === 0) {
          k(this, wr) < e - 60 && z(this, wr, e - 60);
          return;
        }
        for (const i of r) k(this, Ni).emit(k(this, pc), i), z(this, wr, i.blockNumber);
      };
      const sE = BigInt(2),
        aE = 10;
      function bu(n) {
        return n && typeof n.then == "function";
      }
      function wu(n, e) {
        return n + ":" + JSON.stringify(e, (t, r) => {
          if (r == null) return "null";
          if (typeof r == "bigint") return `bigint:${r.toString()}`;
          if (typeof r == "string") return r.toLowerCase();
          if (typeof r == "object" && !Array.isArray(r)) {
            const i = Object.keys(r);
            return i.sort(), i.reduce((a, l) => (a[l] = r[l], a), {});
          }
          return r;
        });
      }
      class ev {
        constructor(e) {
          ce(this, "name");
          Ge(this, {
            name: e
          });
        }
        start() {}
        stop() {}
        pause(e) {}
        resume() {}
      }
      function cE(n) {
        return JSON.parse(JSON.stringify(n));
      }
      function j0(n) {
        return n = Array.from(new Set(n).values()), n.sort(), n;
      }
      async function W0(n, e) {
        if (n == null) throw new Error("invalid event");
        if (Array.isArray(n) && (n = {
          topics: n
        }), typeof n == "string") switch (n) {
          case "block":
          case "debug":
          case "error":
          case "finalized":
          case "network":
          case "pending":
          case "safe":
            return {
              type: n,
              tag: n
            };
        }
        if (Xt(n, 32)) {
          const t = n.toLowerCase();
          return {
            type: "transaction",
            tag: wu("tx", {
              hash: t
            }),
            hash: t
          };
        }
        if (n.orphan) {
          const t = n;
          return {
            type: "orphan",
            tag: wu("orphan", t),
            filter: cE(t)
          };
        }
        if (n.address || n.topics) {
          const t = n,
            r = {
              topics: (t.topics || []).map(i => i == null ? null : Array.isArray(i) ? j0(i.map(a => a.toLowerCase())) : i.toLowerCase())
            };
          if (t.address) {
            const i = [],
              a = [],
              l = s => {
                Xt(s) ? i.push(s) : a.push((async () => {
                  i.push(await jn(s, e));
                })());
              };
            Array.isArray(t.address) ? t.address.forEach(l) : l(t.address), a.length && (await Promise.all(a)), r.address = j0(i.map(s => s.toLowerCase()));
          }
          return {
            filter: r,
            tag: wu("event", r),
            type: "event"
          };
        }
        re(!1, "unknown ProviderEvent", "event", n);
      }
      function X0() {
        return new Date().getTime();
      }
      const lE = {
        cacheTimeout: 250,
        pollingInterval: 4e3
      };
      class uE {
        constructor(e, t) {
          de(this, gt);
          de(this, Ln);
          de(this, go);
          de(this, Un);
          de(this, vc);
          de(this, fr);
          de(this, Zs);
          de(this, vo);
          de(this, Si);
          de(this, Sl);
          de(this, xr);
          de(this, yc);
          de(this, mc);
          if (z(this, mc, Object.assign({}, lE, t || {})), e === "any") z(this, Zs, !0), z(this, fr, null);else if (e) {
            const r = jr.from(e);
            z(this, Zs, !1), z(this, fr, Promise.resolve(r)), setTimeout(() => {
              this.emit("network", r, null);
            }, 0);
          } else z(this, Zs, !1), z(this, fr, null);
          z(this, Si, -1), z(this, vo, new Map()), z(this, Ln, new Map()), z(this, go, new Map()), z(this, Un, null), z(this, vc, !1), z(this, Sl, 1), z(this, xr, new Map()), z(this, yc, !1);
        }
        get pollingInterval() {
          return k(this, mc).pollingInterval;
        }
        get provider() {
          return this;
        }
        get plugins() {
          return Array.from(k(this, go).values());
        }
        attachPlugin(e) {
          if (k(this, go).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
          return k(this, go).set(e.name, e.connect(this)), this;
        }
        getPlugin(e) {
          return k(this, go).get(e) || null;
        }
        get disableCcipRead() {
          return k(this, yc);
        }
        set disableCcipRead(e) {
          z(this, yc, !!e);
        }
        async ccipReadFetch(e, t, r) {
          if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
          const i = e.to.toLowerCase(),
            a = t.toLowerCase(),
            l = [];
          for (let s = 0; s < r.length; s++) {
            const o = r[s],
              c = o.replace("{sender}", i).replace("{data}", a),
              u = new Bi(c);
            o.indexOf("{data}") === -1 && (u.body = {
              data: a,
              sender: i
            }), this.emit("debug", {
              action: "sendCcipReadFetchRequest",
              request: u,
              index: s,
              urls: r
            });
            let f = "unknown error",
              d;
            try {
              d = await u.send();
            } catch (p) {
              l.push(p.message), this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: u,
                result: {
                  error: p
                }
              });
              continue;
            }
            try {
              const p = d.bodyJson;
              if (p.data) return this.emit("debug", {
                action: "receiveCcipReadFetchResult",
                request: u,
                result: p
              }), p.data;
              p.message && (f = p.message), this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: u,
                result: p
              });
            } catch {}
            be(d.statusCode < 400 || d.statusCode >= 500, `response not found during CCIP fetch: ${f}`, "OFFCHAIN_FAULT", {
              reason: "404_MISSING_RESOURCE",
              transaction: e,
              info: {
                url: o,
                errorMessage: f
              }
            }), l.push(f);
          }
          be(!1, `error encountered during CCIP fetch: ${l.map(s => JSON.stringify(s)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: e,
            info: {
              urls: r,
              errorMessages: l
            }
          });
        }
        _wrapBlock(e, t) {
          return new S_(V_(e), this);
        }
        _wrapLog(e, t) {
          return new jc(J_(e), this);
        }
        _wrapTransactionReceipt(e, t) {
          return new Bg(Y_(e), this);
        }
        _wrapTransactionResponse(e, t) {
          return new Wc($g(e), this);
        }
        _detectNetwork() {
          be(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
          });
        }
        async _perform(e) {
          be(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: e
          });
        }
        async getBlockNumber() {
          const e = ct(await _e(this, gt, dr).call(this, {
            method: "getBlockNumber"
          }), "%response");
          return k(this, Si) >= 0 && z(this, Si, e), e;
        }
        _getAddress(e) {
          return jn(e, this);
        }
        _getBlockTag(e) {
          if (e == null) return "latest";
          switch (e) {
            case "earliest":
              return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
              return e;
          }
          if (Xt(e)) return Xt(e, 32) ? e : Cr(e);
          if (typeof e == "bigint" && (e = ct(e, "blockTag")), typeof e == "number") return e >= 0 ? Cr(e) : k(this, Si) >= 0 ? Cr(k(this, Si) + e) : this.getBlockNumber().then(t => Cr(t + e));
          re(!1, "invalid blockTag", "blockTag", e);
        }
        _getFilter(e) {
          const t = (e.topics || []).map(o => o == null ? null : Array.isArray(o) ? j0(o.map(c => c.toLowerCase())) : o.toLowerCase()),
            r = "blockHash" in e ? e.blockHash : void 0,
            i = (o, c, u) => {
              let f;
              switch (o.length) {
                case 0:
                  break;
                case 1:
                  f = o[0];
                  break;
                default:
                  o.sort(), f = o;
              }
              if (r && (c != null || u != null)) throw new Error("invalid filter");
              const d = {};
              return f && (d.address = f), t.length && (d.topics = t), c && (d.fromBlock = c), u && (d.toBlock = u), r && (d.blockHash = r), d;
            };
          let a = [];
          if (e.address) if (Array.isArray(e.address)) for (const o of e.address) a.push(this._getAddress(o));else a.push(this._getAddress(e.address));
          let l;
          "fromBlock" in e && (l = this._getBlockTag(e.fromBlock));
          let s;
          return "toBlock" in e && (s = this._getBlockTag(e.toBlock)), a.filter(o => typeof o != "string").length || l != null && typeof l != "string" || s != null && typeof s != "string" ? Promise.all([Promise.all(a), l, s]).then(o => i(o[0], o[1], o[2])) : i(a, l, s);
        }
        _getTransactionRequest(e) {
          const t = du(e),
            r = [];
          if (["to", "from"].forEach(i => {
            if (t[i] == null) return;
            const a = jn(t[i], this);
            bu(a) ? r.push(async function () {
              t[i] = await a;
            }()) : t[i] = a;
          }), t.blockTag != null) {
            const i = this._getBlockTag(t.blockTag);
            bu(i) ? r.push(async function () {
              t.blockTag = await i;
            }()) : t.blockTag = i;
          }
          return r.length ? async function () {
            return await Promise.all(r), t;
          }() : t;
        }
        async getNetwork() {
          if (k(this, fr) == null) {
            const i = (async () => {
              try {
                const a = await this._detectNetwork();
                return this.emit("network", a, null), a;
              } catch (a) {
                throw k(this, fr) === i && z(this, fr, null), a;
              }
            })();
            return z(this, fr, i), (await i).clone();
          }
          const e = k(this, fr),
            [t, r] = await Promise.all([e, this._detectNetwork()]);
          return t.chainId !== r.chainId && (k(this, Zs) ? (this.emit("network", r, t), k(this, fr) === e && z(this, fr, Promise.resolve(r))) : be(!1, `network changed: ${t.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
            event: "changed"
          })), t.clone();
        }
        async getFeeData() {
          const e = await this.getNetwork(),
            t = async () => {
              const {
                _block: i,
                gasPrice: a,
                priorityFee: l
              } = await pn({
                _block: _e(this, gt, nh).call(this, "latest", !1),
                gasPrice: (async () => {
                  try {
                    const u = await _e(this, gt, dr).call(this, {
                      method: "getGasPrice"
                    });
                    return Le(u, "%response");
                  } catch {}
                  return null;
                })(),
                priorityFee: (async () => {
                  try {
                    const u = await _e(this, gt, dr).call(this, {
                      method: "getPriorityFee"
                    });
                    return Le(u, "%response");
                  } catch {}
                  return null;
                })()
              });
              let s = null,
                o = null;
              const c = this._wrapBlock(i, e);
              return c && c.baseFeePerGas && (o = l != null ? l : BigInt("1000000000"), s = c.baseFeePerGas * sE + o), new Ig(a, s, o);
            },
            r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
          if (r) {
            const i = new Bi(r.url),
              a = await r.processFunc(t, this, i);
            return new Ig(a.gasPrice, a.maxFeePerGas, a.maxPriorityFeePerGas);
          }
          return await t();
        }
        async estimateGas(e) {
          let t = this._getTransactionRequest(e);
          return bu(t) && (t = await t), Le(await _e(this, gt, dr).call(this, {
            method: "estimateGas",
            transaction: t
          }), "%response");
        }
        async call(e) {
          const {
            tx: t,
            blockTag: r
          } = await pn({
            tx: this._getTransactionRequest(e),
            blockTag: this._getBlockTag(e.blockTag)
          });
          return await _e(this, gt, th).call(this, _e(this, gt, eh).call(this, t, r, e.enableCcipRead ? 0 : -1));
        }
        async getBalance(e, t) {
          return Le(await _e(this, gt, Il).call(this, {
            method: "getBalance"
          }, e, t), "%response");
        }
        async getTransactionCount(e, t) {
          return ct(await _e(this, gt, Il).call(this, {
            method: "getTransactionCount"
          }, e, t), "%response");
        }
        async getCode(e, t) {
          return Se(await _e(this, gt, Il).call(this, {
            method: "getCode"
          }, e, t));
        }
        async getStorage(e, t, r) {
          const i = Le(t, "position");
          return Se(await _e(this, gt, Il).call(this, {
            method: "getStorage",
            position: i
          }, e, r));
        }
        async broadcastTransaction(e) {
          const {
              blockNumber: t,
              hash: r,
              network: i
            } = await pn({
              blockNumber: this.getBlockNumber(),
              hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: e
              }),
              network: this.getNetwork()
            }),
            a = eu.from(e);
          if (a.hash !== r) throw new Error("@TODO: the returned hash did not match");
          return this._wrapTransactionResponse(a, i).replaceableTransaction(t);
        }
        async getBlock(e, t) {
          const {
            network: r,
            params: i
          } = await pn({
            network: this.getNetwork(),
            params: _e(this, gt, nh).call(this, e, !!t)
          });
          return i == null ? null : this._wrapBlock(i, r);
        }
        async getTransaction(e) {
          const {
            network: t,
            params: r
          } = await pn({
            network: this.getNetwork(),
            params: _e(this, gt, dr).call(this, {
              method: "getTransaction",
              hash: e
            })
          });
          return r == null ? null : this._wrapTransactionResponse(r, t);
        }
        async getTransactionReceipt(e) {
          const {
            network: t,
            params: r
          } = await pn({
            network: this.getNetwork(),
            params: _e(this, gt, dr).call(this, {
              method: "getTransactionReceipt",
              hash: e
            })
          });
          if (r == null) return null;
          if (r.gasPrice == null && r.effectiveGasPrice == null) {
            const i = await _e(this, gt, dr).call(this, {
              method: "getTransaction",
              hash: e
            });
            if (i == null) throw new Error("report this; could not find tx or effectiveGasPrice");
            r.effectiveGasPrice = i.gasPrice;
          }
          return this._wrapTransactionReceipt(r, t);
        }
        async getTransactionResult(e) {
          const {
            result: t
          } = await pn({
            network: this.getNetwork(),
            result: _e(this, gt, dr).call(this, {
              method: "getTransactionResult",
              hash: e
            })
          });
          return t == null ? null : Se(t);
        }
        async getLogs(e) {
          let t = this._getFilter(e);
          bu(t) && (t = await t);
          const {
            network: r,
            params: i
          } = await pn({
            network: this.getNetwork(),
            params: _e(this, gt, dr).call(this, {
              method: "getLogs",
              filter: t
            })
          });
          return i.map(a => this._wrapLog(a, r));
        }
        _getProvider(e) {
          be(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
          });
        }
        async getResolver(e) {
          return await vu.fromName(this, e);
        }
        async getAvatar(e) {
          const t = await this.getResolver(e);
          return t ? await t.getAvatar() : null;
        }
        async resolveName(e) {
          const t = await this.getResolver(e);
          return t ? await t.getAddress() : null;
        }
        async lookupAddress(e) {
          e = Mt(e);
          const t = A0(e.substring(2).toLowerCase() + ".addr.reverse");
          try {
            const r = await vu.getEnsAddress(this),
              a = await new Mo(r, ["function resolver(bytes32) view returns (address)"], this).resolver(t);
            if (a == null || a === Pc) return null;
            const s = await new Mo(a, ["function name(bytes32) view returns (string)"], this).name(t);
            return (await this.resolveName(s)) !== e ? null : s;
          } catch (r) {
            if (Nn(r, "BAD_DATA") && r.value === "0x" || Nn(r, "CALL_EXCEPTION")) return null;
            throw r;
          }
          return null;
        }
        async waitForTransaction(e, t, r) {
          const i = t != null ? t : 1;
          return i === 0 ? this.getTransactionReceipt(e) : new Promise(async (a, l) => {
            let s = null;
            const o = async c => {
              try {
                const u = await this.getTransactionReceipt(e);
                if (u != null && c - u.blockNumber + 1 >= i) {
                  a(u), s && (clearTimeout(s), s = null);
                  return;
                }
              } catch (u) {
                console.log("EEE", u);
              }
              this.once("block", o);
            };
            r != null && (s = setTimeout(() => {
              s != null && (s = null, this.off("block", o), l(Vt("timeout", "TIMEOUT", {
                reason: "timeout"
              })));
            }, r)), o(await this.getBlockNumber());
          });
        }
        async waitForBlock(e) {
          be(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
          });
        }
        _clearTimeout(e) {
          const t = k(this, xr).get(e);
          t && (t.timer && clearTimeout(t.timer), k(this, xr).delete(e));
        }
        _setTimeout(e, t) {
          t == null && (t = 0);
          const r = Dl(this, Sl)._++,
            i = () => {
              k(this, xr).delete(r), e();
            };
          if (this.paused) k(this, xr).set(r, {
            timer: null,
            func: i,
            time: t
          });else {
            const a = setTimeout(i, t);
            k(this, xr).set(r, {
              timer: a,
              func: i,
              time: X0()
            });
          }
          return r;
        }
        _forEachSubscriber(e) {
          for (const t of k(this, Ln).values()) e(t.subscriber);
        }
        _getSubscriber(e) {
          switch (e.type) {
            case "debug":
            case "error":
            case "network":
              return new ev(e.type);
            case "block":
              {
                const t = new nE(this);
                return t.pollingInterval = this.pollingInterval, t;
              }
            case "safe":
            case "finalized":
              return new rE(this, e.type);
            case "event":
              return new H0(this, e.filter);
            case "transaction":
              return new oE(this, e.hash);
            case "orphan":
              return new iE(this, e.filter);
          }
          throw new Error(`unsupported event: ${e.type}`);
        }
        _recoverSubscriber(e, t) {
          for (const r of k(this, Ln).values()) if (r.subscriber === e) {
            r.started && r.subscriber.stop(), r.subscriber = t, r.started && t.start(), k(this, Un) != null && t.pause(k(this, Un));
            break;
          }
        }
        async on(e, t) {
          const r = await _e(this, gt, Hf).call(this, e);
          return r.listeners.push({
            listener: t,
            once: !1
          }), r.started || (r.subscriber.start(), r.started = !0, k(this, Un) != null && r.subscriber.pause(k(this, Un))), this;
        }
        async once(e, t) {
          const r = await _e(this, gt, Hf).call(this, e);
          return r.listeners.push({
            listener: t,
            once: !0
          }), r.started || (r.subscriber.start(), r.started = !0, k(this, Un) != null && r.subscriber.pause(k(this, Un))), this;
        }
        async emit(e, ...t) {
          const r = await _e(this, gt, Bl).call(this, e, t);
          if (!r || r.listeners.length === 0) return !1;
          const i = r.listeners.length;
          return r.listeners = r.listeners.filter(({
            listener: a,
            once: l
          }) => {
            const s = new gh(this, l ? null : a, e);
            try {
              a.call(this, ...t, s);
            } catch {}
            return !l;
          }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), k(this, Ln).delete(r.tag)), i > 0;
        }
        async listenerCount(e) {
          if (e) {
            const r = await _e(this, gt, Bl).call(this, e);
            return r ? r.listeners.length : 0;
          }
          let t = 0;
          for (const {
            listeners: r
          } of k(this, Ln).values()) t += r.length;
          return t;
        }
        async listeners(e) {
          if (e) {
            const r = await _e(this, gt, Bl).call(this, e);
            return r ? r.listeners.map(({
              listener: i
            }) => i) : [];
          }
          let t = [];
          for (const {
            listeners: r
          } of k(this, Ln).values()) t = t.concat(r.map(({
            listener: i
          }) => i));
          return t;
        }
        async off(e, t) {
          const r = await _e(this, gt, Bl).call(this, e);
          if (!r) return this;
          if (t) {
            const i = r.listeners.map(({
              listener: a
            }) => a).indexOf(t);
            i >= 0 && r.listeners.splice(i, 1);
          }
          return (!t || r.listeners.length === 0) && (r.started && r.subscriber.stop(), k(this, Ln).delete(r.tag)), this;
        }
        async removeAllListeners(e) {
          if (e) {
            const {
              tag: t,
              started: r,
              subscriber: i
            } = await _e(this, gt, Hf).call(this, e);
            r && i.stop(), k(this, Ln).delete(t);
          } else for (const [t, {
            started: r,
            subscriber: i
          }] of k(this, Ln)) r && i.stop(), k(this, Ln).delete(t);
          return this;
        }
        async addListener(e, t) {
          return await this.on(e, t);
        }
        async removeListener(e, t) {
          return this.off(e, t);
        }
        get destroyed() {
          return k(this, vc);
        }
        destroy() {
          this.removeAllListeners();
          for (const e of k(this, xr).keys()) this._clearTimeout(e);
          z(this, vc, !0);
        }
        get paused() {
          return k(this, Un) != null;
        }
        set paused(e) {
          !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1));
        }
        pause(e) {
          if (z(this, Si, -1), k(this, Un) != null) {
            if (k(this, Un) == !!e) return;
            be(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
              operation: "pause"
            });
          }
          this._forEachSubscriber(t => t.pause(e)), z(this, Un, !!e);
          for (const t of k(this, xr).values()) t.timer && clearTimeout(t.timer), t.time = X0() - t.time;
        }
        resume() {
          if (k(this, Un) != null) {
            this._forEachSubscriber(e => e.resume()), z(this, Un, null);
            for (const e of k(this, xr).values()) {
              let t = e.time;
              t < 0 && (t = 0), e.time = X0(), setTimeout(e.func, t);
            }
          }
        }
      }
      Ln = new WeakMap(), go = new WeakMap(), Un = new WeakMap(), vc = new WeakMap(), fr = new WeakMap(), Zs = new WeakMap(), vo = new WeakMap(), Si = new WeakMap(), Sl = new WeakMap(), xr = new WeakMap(), yc = new WeakMap(), mc = new WeakMap(), gt = new WeakSet(), dr = async function (e) {
        const t = k(this, mc).cacheTimeout;
        if (t < 0) return await this._perform(e);
        const r = wu(e.method, e);
        let i = k(this, vo).get(r);
        return i || (i = this._perform(e), k(this, vo).set(r, i), setTimeout(() => {
          k(this, vo).get(r) === i && k(this, vo).delete(r);
        }, t)), await i;
      }, eh = async function (e, t, r) {
        be(r < aE, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
          reason: "TOO_MANY_REDIRECTS",
          transaction: Object.assign({}, e, {
            blockTag: t,
            enableCcipRead: !0
          })
        });
        const i = du(e);
        try {
          return Se(await this._perform({
            method: "call",
            transaction: i,
            blockTag: t
          }));
        } catch (a) {
          if (!this.disableCcipRead && jf(a) && a.data && r >= 0 && t === "latest" && i.to != null && an(a.data, 0, 4) === "0x556f1830") {
            const l = a.data,
              s = await jn(i.to, this);
            let o;
            try {
              o = gE(an(a.data, 4));
            } catch (f) {
              be(!1, f.message, "OFFCHAIN_FAULT", {
                reason: "BAD_DATA",
                transaction: i,
                info: {
                  data: l
                }
              });
            }
            be(o.sender.toLowerCase() === s.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
              action: "call",
              data: l,
              reason: "OffchainLookup",
              transaction: i,
              invocation: null,
              revert: {
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                name: "OffchainLookup",
                args: o.errorArgs
              }
            });
            const c = await this.ccipReadFetch(i, o.calldata, o.urls);
            be(c != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
              reason: "FETCH_FAILED",
              transaction: i,
              info: {
                data: a.data,
                errorArgs: o.errorArgs
              }
            });
            const u = {
              to: s,
              data: sn([o.selector, pE([c, o.extraData])])
            };
            this.emit("debug", {
              action: "sendCcipReadCall",
              transaction: u
            });
            try {
              const f = await _e(this, gt, eh).call(this, u, t, r + 1);
              return this.emit("debug", {
                action: "receiveCcipReadCallResult",
                transaction: Object.assign({}, u),
                result: f
              }), f;
            } catch (f) {
              throw this.emit("debug", {
                action: "receiveCcipReadCallError",
                transaction: Object.assign({}, u),
                error: f
              }), f;
            }
          }
          throw a;
        }
      }, th = async function (e) {
        const {
          value: t
        } = await pn({
          network: this.getNetwork(),
          value: e
        });
        return t;
      }, Il = async function (e, t, r) {
        let i = this._getAddress(t),
          a = this._getBlockTag(r);
        return (typeof i != "string" || typeof a != "string") && ([i, a] = await Promise.all([i, a])), await _e(this, gt, th).call(this, _e(this, gt, dr).call(this, Object.assign(e, {
          address: i,
          blockTag: a
        })));
      }, nh = async function (e, t) {
        if (Xt(e, 32)) return await _e(this, gt, dr).call(this, {
          method: "getBlock",
          blockHash: e,
          includeTransactions: t
        });
        let r = this._getBlockTag(e);
        return typeof r != "string" && (r = await r), await _e(this, gt, dr).call(this, {
          method: "getBlock",
          blockTag: r,
          includeTransactions: t
        });
      }, Bl = async function (e, t) {
        let r = await W0(e, this);
        return r.type === "event" && t && t.length > 0 && t[0].removed === !0 && (r = await W0({
          orphan: "drop-log",
          log: t[0]
        }, this)), k(this, Ln).get(r.tag) || null;
      }, Hf = async function (e) {
        const t = await W0(e, this),
          r = t.tag;
        let i = k(this, Ln).get(r);
        return i || (i = {
          subscriber: this._getSubscriber(t),
          tag: r,
          addressableMap: new WeakMap(),
          nameMap: new Map(),
          started: !1,
          listeners: []
        }, k(this, Ln).set(r, i)), i;
      };
      function fE(n, e) {
        try {
          const t = q0(n, e);
          if (t) return Ul(t);
        } catch {}
        return null;
      }
      function q0(n, e) {
        if (n === "0x") return null;
        try {
          const t = ct(an(n, e, e + 32)),
            r = ct(an(n, t, t + 32));
          return an(n, t + 32, t + 32 + r);
        } catch {}
        return null;
      }
      function tv(n) {
        const e = wn(n);
        if (e.length > 32) throw new Error("internal; should not happen");
        const t = new Uint8Array(32);
        return t.set(e, 32 - e.length), t;
      }
      function dE(n) {
        if (n.length % 32 === 0) return n;
        const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
        return e.set(n), e;
      }
      const hE = new Uint8Array([]);
      function pE(n) {
        const e = [];
        let t = 0;
        for (let r = 0; r < n.length; r++) e.push(hE), t += 32;
        for (let r = 0; r < n.length; r++) {
          const i = ft(n[r]);
          e[r] = tv(t), e.push(tv(i.length)), e.push(dE(i)), t += 32 + Math.ceil(i.length / 32) * 32;
        }
        return sn(e);
      }
      const nv = "0x0000000000000000000000000000000000000000000000000000000000000000";
      function gE(n) {
        const e = {
          sender: "",
          urls: [],
          calldata: "",
          selector: "",
          extraData: "",
          errorArgs: []
        };
        be(aa(n) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
          reason: "insufficient OffchainLookup data"
        });
        const t = an(n, 0, 32);
        be(an(t, 0, 12) === an(nv, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup sender"
        }), e.sender = an(t, 12);
        try {
          const r = [],
            i = ct(an(n, 32, 64)),
            a = ct(an(n, i, i + 32)),
            l = an(n, i + 32);
          for (let s = 0; s < a; s++) {
            const o = fE(l, s * 32);
            if (o == null) throw new Error("abort");
            r.push(o);
          }
          e.urls = r;
        } catch {
          be(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
          });
        }
        try {
          const r = q0(n, 64);
          if (r == null) throw new Error("abort");
          e.calldata = r;
        } catch {
          be(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
          });
        }
        be(an(n, 100, 128) === an(nv, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup callbaackSelector"
        }), e.selector = an(n, 96, 100);
        try {
          const r = q0(n, 128);
          if (r == null) throw new Error("abort");
          e.extraData = r;
        } catch {
          be(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
          });
        }
        return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(r => e[r]), e;
      }
      function Ko(n, e) {
        if (n.provider) return n.provider;
        be(!1, "missing provider", "UNSUPPORTED_OPERATION", {
          operation: e
        });
      }
      async function rv(n, e) {
        let t = du(e);
        if (t.to != null && (t.to = jn(t.to, n)), t.from != null) {
          const r = t.from;
          t.from = Promise.all([n.getAddress(), jn(r, n)]).then(([i, a]) => (re(i.toLowerCase() === a.toLowerCase(), "transaction from mismatch", "tx.from", a), i));
        } else t.from = n.getAddress();
        return await pn(t);
      }
      class vE {
        constructor(e) {
          ce(this, "provider");
          Ge(this, {
            provider: e || null
          });
        }
        async getNonce(e) {
          return Ko(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
        }
        async populateCall(e) {
          return await rv(this, e);
        }
        async populateTransaction(e) {
          const t = Ko(this, "populateTransaction"),
            r = await rv(this, e);
          r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
          const i = await this.provider.getNetwork();
          if (r.chainId != null) {
            const l = Le(r.chainId);
            re(l === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
          } else r.chainId = i.chainId;
          const a = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
          if (r.gasPrice != null && (r.type === 2 || a) ? re(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && a && re(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;else if (r.type === 0 || r.type === 1) {
            const l = await t.getFeeData();
            be(l.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
              operation: "getGasPrice"
            }), r.gasPrice == null && (r.gasPrice = l.gasPrice);
          } else {
            const l = await t.getFeeData();
            if (r.type == null) {
              if (l.maxFeePerGas != null && l.maxPriorityFeePerGas != null) {
                if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, r.gasPrice != null) {
                  const s = r.gasPrice;
                  delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s;
                } else r.maxFeePerGas == null && (r.maxFeePerGas = l.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = l.maxPriorityFeePerGas);
              } else l.gasPrice != null ? (be(!a, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                operation: "populateTransaction"
              }), r.gasPrice == null && (r.gasPrice = l.gasPrice), r.type = 0) : be(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                operation: "signer.getFeeData"
              });
            } else (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = l.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = l.maxPriorityFeePerGas));
          }
          return await pn(r);
        }
        async populateAuthorization(e) {
          const t = Object.assign({}, e);
          return t.chainId == null && (t.chainId = (await Ko(this, "getNetwork").getNetwork()).chainId), t.nonce == null && (t.nonce = await this.getNonce()), t;
        }
        async estimateGas(e) {
          return Ko(this, "estimateGas").estimateGas(await this.populateCall(e));
        }
        async call(e) {
          return Ko(this, "call").call(await this.populateCall(e));
        }
        async resolveName(e) {
          return await Ko(this, "resolveName").resolveName(e);
        }
        async sendTransaction(e) {
          const t = Ko(this, "sendTransaction"),
            r = await this.populateTransaction(e);
          delete r.from;
          const i = eu.from(r);
          return await t.broadcastTransaction(await this.signTransaction(i));
        }
        authorize(e) {
          be(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", {
            operation: "authorize"
          });
        }
      }
      function yE(n) {
        return JSON.parse(JSON.stringify(n));
      }
      class iv {
        constructor(e) {
          de(this, mo);
          de(this, Jn);
          de(this, ei);
          de(this, ea);
          de(this, yo);
          de(this, ta);
          de(this, bc);
          z(this, Jn, e), z(this, ei, null), z(this, ea, _e(this, mo, rh).bind(this)), z(this, yo, !1), z(this, ta, null), z(this, bc, !1);
        }
        _subscribe(e) {
          throw new Error("subclasses must override this");
        }
        _emitResults(e, t) {
          throw new Error("subclasses must override this");
        }
        _recover(e) {
          throw new Error("subclasses must override this");
        }
        start() {
          k(this, yo) || (z(this, yo, !0), _e(this, mo, rh).call(this, -2));
        }
        stop() {
          k(this, yo) && (z(this, yo, !1), z(this, bc, !0), _e(this, mo, ih).call(this), k(this, Jn).off("block", k(this, ea)));
        }
        pause(e) {
          e && _e(this, mo, ih).call(this), k(this, Jn).off("block", k(this, ea));
        }
        resume() {
          this.start();
        }
      }
      Jn = new WeakMap(), ei = new WeakMap(), ea = new WeakMap(), yo = new WeakMap(), ta = new WeakMap(), bc = new WeakMap(), mo = new WeakSet(), rh = async function (e) {
        try {
          k(this, ei) == null && z(this, ei, this._subscribe(k(this, Jn)));
          let t = null;
          try {
            t = await k(this, ei);
          } catch (a) {
            if (!Nn(a, "UNSUPPORTED_OPERATION") || a.operation !== "eth_newFilter") throw a;
          }
          if (t == null) {
            z(this, ei, null), k(this, Jn)._recoverSubscriber(this, this._recover(k(this, Jn)));
            return;
          }
          const r = await k(this, Jn).getNetwork();
          if (k(this, ta) || z(this, ta, r), k(this, ta).chainId !== r.chainId) throw new Error("chaid changed");
          if (k(this, bc)) return;
          const i = await k(this, Jn).send("eth_getFilterChanges", [t]);
          await this._emitResults(k(this, Jn), i);
        } catch (t) {
          console.log("@TODO", t);
        }
        k(this, Jn).once("block", k(this, ea));
      }, ih = function () {
        const e = k(this, ei);
        e && (z(this, ei, null), e.then(t => {
          k(this, Jn).destroyed || k(this, Jn).send("eth_uninstallFilter", [t]);
        }));
      };
      class mE extends iv {
        constructor(t, r) {
          super(t);
          de(this, na);
          z(this, na, yE(r));
        }
        _recover(t) {
          return new H0(t, k(this, na));
        }
        async _subscribe(t) {
          return await t.send("eth_newFilter", [k(this, na)]);
        }
        async _emitResults(t, r) {
          for (const i of r) t.emit(k(this, na), t._wrapLog(i, t._network));
        }
      }
      na = new WeakMap();
      class bE extends iv {
        async _subscribe(e) {
          return await e.send("eth_newPendingTransactionFilter", []);
        }
        async _emitResults(e, t) {
          for (const r of t) e.emit("pending", r);
        }
      }
      const wE = "bigint,boolean,function,number,string,symbol".split(/,/g);
      function xu(n) {
        if (n == null || wE.indexOf(typeof n) >= 0 || typeof n.getAddress == "function") return n;
        if (Array.isArray(n)) return n.map(xu);
        if (typeof n == "object") return Object.keys(n).reduce((e, t) => (e[t] = n[t], e), {});
        throw new Error(`should not happen: ${n} (${typeof n})`);
      }
      function xE(n) {
        return new Promise(e => {
          setTimeout(e, n);
        });
      }
      function Aa(n) {
        return n && n.toLowerCase();
      }
      function ov(n) {
        return n && typeof n.pollingInterval == "number";
      }
      const sv = {
        polling: !1,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1 << 20,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4e3
      };
      class J0 extends vE {
        constructor(t, r) {
          super(t);
          ce(this, "address");
          r = Mt(r), Ge(this, {
            address: r
          });
        }
        connect(t) {
          be(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
          });
        }
        async getAddress() {
          return this.address;
        }
        async populateTransaction(t) {
          return await this.populateCall(t);
        }
        async sendUncheckedTransaction(t) {
          const r = xu(t),
            i = [];
          if (r.from) {
            const l = r.from;
            i.push((async () => {
              const s = await jn(l, this.provider);
              re(s != null && s.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), r.from = s;
            })());
          } else r.from = this.address;
          if (r.gasLimit == null && i.push((async () => {
            r.gasLimit = await this.provider.estimateGas({
              ...r,
              from: this.address
            });
          })()), r.to != null) {
            const l = r.to;
            i.push((async () => {
              r.to = await jn(l, this.provider);
            })());
          }
          i.length && (await Promise.all(i));
          const a = this.provider.getRpcTransaction(r);
          return this.provider.send("eth_sendTransaction", [a]);
        }
        async sendTransaction(t) {
          const r = await this.provider.getBlockNumber(),
            i = await this.sendUncheckedTransaction(t);
          return await new Promise((a, l) => {
            const s = [1e3, 100];
            let o = 0;
            const c = async () => {
              try {
                const u = await this.provider.getTransaction(i);
                if (u != null) {
                  a(u.replaceableTransaction(r));
                  return;
                }
              } catch (u) {
                if (Nn(u, "CANCELLED") || Nn(u, "BAD_DATA") || Nn(u, "NETWORK_ERROR") || Nn(u, "UNSUPPORTED_OPERATION")) {
                  u.info == null && (u.info = {}), u.info.sendTransactionHash = i, l(u);
                  return;
                }
                if (Nn(u, "INVALID_ARGUMENT") && (o++, u.info == null && (u.info = {}), u.info.sendTransactionHash = i, o > 10)) {
                  l(u);
                  return;
                }
                this.provider.emit("error", Vt("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                  error: u
                }));
              }
              this.provider._setTimeout(() => {
                c();
              }, s.pop() || 4e3);
            };
            c();
          });
        }
        async signTransaction(t) {
          const r = xu(t);
          if (r.from) {
            const a = await jn(r.from, this.provider);
            re(a != null && a.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", t), r.from = a;
          } else r.from = this.address;
          const i = this.provider.getRpcTransaction(r);
          return await this.provider.send("eth_signTransaction", [i]);
        }
        async signMessage(t) {
          const r = typeof t == "string" ? ii(t) : t;
          return await this.provider.send("personal_sign", [Se(r), this.address.toLowerCase()]);
        }
        async signTypedData(t, r, i) {
          const a = xu(i),
            l = await lu.resolveNames(t, r, a, async s => {
              const o = await jn(s);
              return re(o != null, "TypedData does not support null address", "value", s), o;
            });
          return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(lu.getPayload(l.domain, r, l.value))]);
        }
        async unlock(t) {
          return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), t, null]);
        }
        async _legacySignMessage(t) {
          const r = typeof t == "string" ? ii(t) : t;
          return await this.provider.send("eth_sign", [this.address.toLowerCase(), Se(r)]);
        }
      }
      class _E extends uE {
        constructor(t, r) {
          super(t, r);
          de(this, Tl);
          de(this, ra);
          de(this, wc);
          de(this, Ti);
          de(this, ti);
          de(this, Lr);
          de(this, _r);
          de(this, Zn);
          z(this, wc, 1), z(this, ra, Object.assign({}, sv, r || {})), z(this, Ti, []), z(this, ti, null), z(this, _r, null), z(this, Zn, null);
          {
            let a = null;
            const l = new Promise(s => {
              a = s;
            });
            z(this, Lr, {
              promise: l,
              resolve: a
            });
          }
          const i = this._getOption("staticNetwork");
          typeof i == "boolean" ? (re(!i || t !== "any", "staticNetwork cannot be used on special network 'any'", "options", r), i && t != null && z(this, _r, jr.from(t))) : i && (re(t == null || i.matches(t), "staticNetwork MUST match network object", "options", r), z(this, _r, i));
        }
        _getOption(t) {
          return k(this, ra)[t];
        }
        get _network() {
          return be(k(this, _r), "network is not available yet", "NETWORK_ERROR"), k(this, _r);
        }
        async _perform(t) {
          if (t.method === "call" || t.method === "estimateGas") {
            let i = t.transaction;
            if (i && i.type != null && Le(i.type) && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
              const a = await this.getFeeData();
              a.maxFeePerGas == null && a.maxPriorityFeePerGas == null && (t = Object.assign({}, t, {
                transaction: Object.assign({}, i, {
                  type: void 0
                })
              }));
            }
          }
          const r = this.getRpcRequest(t);
          return r != null ? await this.send(r.method, r.args) : super._perform(t);
        }
        async _detectNetwork() {
          const t = this._getOption("staticNetwork");
          if (t) if (t === !0) {
            if (k(this, _r)) return k(this, _r);
          } else return t;
          return k(this, Zn) ? await k(this, Zn) : this.ready ? (z(this, Zn, (async () => {
            try {
              const r = jr.from(Le(await this.send("eth_chainId", [])));
              return z(this, Zn, null), r;
            } catch (r) {
              throw z(this, Zn, null), r;
            }
          })()), await k(this, Zn)) : (z(this, Zn, (async () => {
            const r = {
              id: Dl(this, wc)._++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0"
            };
            this.emit("debug", {
              action: "sendRpcPayload",
              payload: r
            });
            let i;
            try {
              i = (await this._send(r))[0], z(this, Zn, null);
            } catch (a) {
              throw z(this, Zn, null), this.emit("debug", {
                action: "receiveRpcError",
                error: a
              }), a;
            }
            if (this.emit("debug", {
              action: "receiveRpcResult",
              result: i
            }), "result" in i) return jr.from(Le(i.result));
            throw this.getRpcError(r, i);
          })()), await k(this, Zn));
        }
        _start() {
          k(this, Lr) == null || k(this, Lr).resolve == null || (k(this, Lr).resolve(), z(this, Lr, null), (async () => {
            for (; k(this, _r) == null && !this.destroyed;) try {
              z(this, _r, await this._detectNetwork());
            } catch (t) {
              if (this.destroyed) break;
              console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Vt("failed to bootstrap network detection", "NETWORK_ERROR", {
                event: "initial-network-discovery",
                info: {
                  error: t
                }
              })), await xE(1e3);
            }
            _e(this, Tl, oh).call(this);
          })());
        }
        async _waitUntilReady() {
          if (k(this, Lr) != null) return await k(this, Lr).promise;
        }
        _getSubscriber(t) {
          return t.type === "pending" ? new bE(this) : t.type === "event" ? this._getOption("polling") ? new H0(this, t.filter) : new mE(this, t.filter) : t.type === "orphan" && t.filter.orphan === "drop-log" ? new ev("orphan") : super._getSubscriber(t);
        }
        get ready() {
          return k(this, Lr) == null;
        }
        getRpcTransaction(t) {
          const r = {};
          return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(i => {
            if (t[i] == null) return;
            let a = i;
            i === "gasLimit" && (a = "gas"), r[a] = Cr(Le(t[i], `tx.${i}`));
          }), ["from", "to", "data"].forEach(i => {
            t[i] != null && (r[i] = Se(t[i]));
          }), t.accessList && (r.accessList = Ao(t.accessList)), t.blobVersionedHashes && (r.blobVersionedHashes = t.blobVersionedHashes.map(i => i.toLowerCase())), t.authorizationList && (r.authorizationList = t.authorizationList.map(i => {
            const a = Tp(i);
            return {
              address: a.address,
              nonce: Cr(a.nonce),
              chainId: Cr(a.chainId),
              yParity: Cr(a.signature.yParity),
              r: Cr(a.signature.r),
              s: Cr(a.signature.s)
            };
          })), r;
        }
        getRpcRequest(t) {
          switch (t.method) {
            case "chainId":
              return {
                method: "eth_chainId",
                args: []
              };
            case "getBlockNumber":
              return {
                method: "eth_blockNumber",
                args: []
              };
            case "getGasPrice":
              return {
                method: "eth_gasPrice",
                args: []
              };
            case "getPriorityFee":
              return {
                method: "eth_maxPriorityFeePerGas",
                args: []
              };
            case "getBalance":
              return {
                method: "eth_getBalance",
                args: [Aa(t.address), t.blockTag]
              };
            case "getTransactionCount":
              return {
                method: "eth_getTransactionCount",
                args: [Aa(t.address), t.blockTag]
              };
            case "getCode":
              return {
                method: "eth_getCode",
                args: [Aa(t.address), t.blockTag]
              };
            case "getStorage":
              return {
                method: "eth_getStorageAt",
                args: [Aa(t.address), "0x" + t.position.toString(16), t.blockTag]
              };
            case "broadcastTransaction":
              return {
                method: "eth_sendRawTransaction",
                args: [t.signedTransaction]
              };
            case "getBlock":
              if ("blockTag" in t) return {
                method: "eth_getBlockByNumber",
                args: [t.blockTag, !!t.includeTransactions]
              };
              if ("blockHash" in t) return {
                method: "eth_getBlockByHash",
                args: [t.blockHash, !!t.includeTransactions]
              };
              break;
            case "getTransaction":
              return {
                method: "eth_getTransactionByHash",
                args: [t.hash]
              };
            case "getTransactionReceipt":
              return {
                method: "eth_getTransactionReceipt",
                args: [t.hash]
              };
            case "call":
              return {
                method: "eth_call",
                args: [this.getRpcTransaction(t.transaction), t.blockTag]
              };
            case "estimateGas":
              return {
                method: "eth_estimateGas",
                args: [this.getRpcTransaction(t.transaction)]
              };
            case "getLogs":
              return t.filter && t.filter.address != null && (Array.isArray(t.filter.address) ? t.filter.address = t.filter.address.map(Aa) : t.filter.address = Aa(t.filter.address)), {
                method: "eth_getLogs",
                args: [t.filter]
              };
          }
          return null;
        }
        getRpcError(t, r) {
          const {
              method: i
            } = t,
            {
              error: a
            } = r;
          if (i === "eth_estimateGas" && a.message) {
            const o = a.message;
            if (!o.match(/revert/i) && o.match(/insufficient funds/i)) return Vt("insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: t.params[0],
              info: {
                payload: t,
                error: a
              }
            });
            if (o.match(/nonce/i) && o.match(/too low/i)) return Vt("nonce has already been used", "NONCE_EXPIRED", {
              transaction: t.params[0],
              info: {
                payload: t,
                error: a
              }
            });
          }
          if (i === "eth_call" || i === "eth_estimateGas") {
            const o = G0(a),
              c = Hc.getBuiltinCallException(i === "eth_call" ? "call" : "estimateGas", t.params[0], o ? o.data : null);
            return c.info = {
              error: a,
              payload: t
            }, c;
          }
          const l = JSON.stringify(CE(a));
          if (typeof a.message == "string" && a.message.match(/user denied|ethers-user-denied/i)) return Vt("user rejected action", "ACTION_REJECTED", {
            action: {
              eth_sign: "signMessage",
              personal_sign: "signMessage",
              eth_signTypedData_v4: "signTypedData",
              eth_signTransaction: "signTransaction",
              eth_sendTransaction: "sendTransaction",
              eth_requestAccounts: "requestAccess",
              wallet_requestAccounts: "requestAccess"
            }[i] || "unknown",
            reason: "rejected",
            info: {
              payload: t,
              error: a
            }
          });
          if (i === "eth_sendRawTransaction" || i === "eth_sendTransaction") {
            const o = t.params[0];
            if (l.match(/insufficient funds|base fee exceeds gas limit/i)) return Vt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction: o,
              info: {
                error: a
              }
            });
            if (l.match(/nonce/i) && l.match(/too low/i)) return Vt("nonce has already been used", "NONCE_EXPIRED", {
              transaction: o,
              info: {
                error: a
              }
            });
            if (l.match(/replacement transaction/i) && l.match(/underpriced/i)) return Vt("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
              transaction: o,
              info: {
                error: a
              }
            });
            if (l.match(/only replay-protected/i)) return Vt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
              operation: i,
              info: {
                transaction: o,
                info: {
                  error: a
                }
              }
            });
          }
          let s = !!l.match(/the method .* does not exist/i);
          return s || a && a.details && a.details.startsWith("Unauthorized method:") && (s = !0), s ? Vt("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: t.method,
            info: {
              error: a,
              payload: t
            }
          }) : Vt("could not coalesce error", "UNKNOWN_ERROR", {
            error: a,
            payload: t
          });
        }
        send(t, r) {
          if (this.destroyed) return Promise.reject(Vt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: t
          }));
          const i = Dl(this, wc)._++,
            a = new Promise((l, s) => {
              k(this, Ti).push({
                resolve: l,
                reject: s,
                payload: {
                  method: t,
                  params: r,
                  id: i,
                  jsonrpc: "2.0"
                }
              });
            });
          return _e(this, Tl, oh).call(this), a;
        }
        async getSigner(t) {
          t == null && (t = 0);
          const r = this.send("eth_accounts", []);
          if (typeof t == "number") {
            const a = await r;
            if (t >= a.length) throw new Error("no such account");
            return new J0(this, a[t]);
          }
          const {
            accounts: i
          } = await pn({
            network: this.getNetwork(),
            accounts: r
          });
          t = Mt(t);
          for (const a of i) if (Mt(a) === t) return new J0(this, t);
          throw new Error("invalid account");
        }
        async listAccounts() {
          return (await this.send("eth_accounts", [])).map(r => new J0(this, r));
        }
        destroy() {
          k(this, ti) && (clearTimeout(k(this, ti)), z(this, ti, null));
          for (const {
            payload: t,
            reject: r
          } of k(this, Ti)) r(Vt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: t.method
          }));
          z(this, Ti, []), super.destroy();
        }
      }
      ra = new WeakMap(), wc = new WeakMap(), Ti = new WeakMap(), ti = new WeakMap(), Lr = new WeakMap(), _r = new WeakMap(), Zn = new WeakMap(), Tl = new WeakSet(), oh = function () {
        if (k(this, ti)) return;
        const t = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
        z(this, ti, setTimeout(() => {
          z(this, ti, null);
          const r = k(this, Ti);
          for (z(this, Ti, []); r.length;) {
            const i = [r.shift()];
            for (; r.length && i.length !== k(this, ra).batchMaxCount;) if (i.push(r.shift()), JSON.stringify(i.map(l => l.payload)).length > k(this, ra).batchMaxSize) {
              r.unshift(i.pop());
              break;
            }
            (async () => {
              const a = i.length === 1 ? i[0].payload : i.map(l => l.payload);
              this.emit("debug", {
                action: "sendRpcPayload",
                payload: a
              });
              try {
                const l = await this._send(a);
                this.emit("debug", {
                  action: "receiveRpcResult",
                  result: l
                });
                for (const {
                  resolve: s,
                  reject: o,
                  payload: c
                } of i) {
                  if (this.destroyed) {
                    o(Vt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                      operation: c.method
                    }));
                    continue;
                  }
                  const u = l.filter(f => f.id === c.id)[0];
                  if (u == null) {
                    const f = Vt("missing response for request", "BAD_DATA", {
                      value: l,
                      info: {
                        payload: c
                      }
                    });
                    this.emit("error", f), o(f);
                    continue;
                  }
                  if ("error" in u) {
                    o(this.getRpcError(c, u));
                    continue;
                  }
                  s(u.result);
                }
              } catch (l) {
                this.emit("debug", {
                  action: "receiveRpcError",
                  error: l
                });
                for (const {
                  reject: s
                } of i) s(l);
              }
            })();
          }
        }, t));
      };
      class EE extends _E {
        constructor(t, r) {
          super(t, r);
          de(this, bo);
          let i = this._getOption("pollingInterval");
          i == null && (i = sv.pollingInterval), z(this, bo, i);
        }
        _getSubscriber(t) {
          const r = super._getSubscriber(t);
          return ov(r) && (r.pollingInterval = k(this, bo)), r;
        }
        get pollingInterval() {
          return k(this, bo);
        }
        set pollingInterval(t) {
          if (!Number.isInteger(t) || t < 0) throw new Error("invalid interval");
          z(this, bo, t), this._forEachSubscriber(r => {
            ov(r) && (r.pollingInterval = k(this, bo));
          });
        }
      }
      bo = new WeakMap();
      function G0(n) {
        if (n == null) return null;
        if (typeof n.message == "string" && n.message.match(/revert/i) && Xt(n.data)) return {
          message: n.message,
          data: n.data
        };
        if (typeof n == "object") {
          for (const e in n) {
            const t = G0(n[e]);
            if (t) return t;
          }
          return null;
        }
        if (typeof n == "string") try {
          return G0(JSON.parse(n));
        } catch {}
        return null;
      }
      function V0(n, e) {
        if (n != null) {
          if (typeof n.message == "string" && e.push(n.message), typeof n == "object") for (const t in n) V0(n[t], e);
          if (typeof n == "string") try {
            return V0(JSON.parse(n), e);
          } catch {}
        }
      }
      function CE(n) {
        const e = [];
        return V0(n, e), e;
      }
      const ia = class ia extends EE {
        constructor(t, r, i) {
          const a = Object.assign({}, i != null ? i : {}, {
            batchMaxCount: 1
          });
          re(t && t.request, "invalid EIP-1193 provider", "ethereum", t);
          super(r, a);
          de(this, xc);
          de(this, _c);
          z(this, _c, null), i && i.providerInfo && z(this, _c, i.providerInfo), z(this, xc, async (l, s) => {
            const o = {
              method: l,
              params: s
            };
            this.emit("debug", {
              action: "sendEip1193Request",
              payload: o
            });
            try {
              const c = await t.request(o);
              return this.emit("debug", {
                action: "receiveEip1193Result",
                result: c
              }), c;
            } catch (c) {
              const u = new Error(c.message);
              throw u.code = c.code, u.data = c.data, u.payload = o, this.emit("debug", {
                action: "receiveEip1193Error",
                error: u
              }), u;
            }
          });
        }
        get providerInfo() {
          return k(this, _c);
        }
        async send(t, r) {
          return await this._start(), await super.send(t, r);
        }
        async _send(t) {
          re(!Array.isArray(t), "EIP-1193 does not support batch request", "payload", t);
          try {
            const r = await k(this, xc).call(this, t.method, t.params || []);
            return [{
              id: t.id,
              result: r
            }];
          } catch (r) {
            return [{
              id: t.id,
              error: {
                code: r.code,
                data: r.data,
                message: r.message
              }
            }];
          }
        }
        getRpcError(t, r) {
          switch (r = JSON.parse(JSON.stringify(r)), r.error.code || -1) {
            case 4001:
              r.error.message = `ethers-user-denied: ${r.error.message}`;
              break;
            case 4200:
              r.error.message = `ethers-unsupported: ${r.error.message}`;
              break;
          }
          return super.getRpcError(t, r);
        }
        async hasSigner(t) {
          t == null && (t = 0);
          const r = await this.send("eth_accounts", []);
          return typeof t == "number" ? r.length > t : (t = t.toLowerCase(), r.filter(i => i.toLowerCase() === t).length !== 0);
        }
        async getSigner(t) {
          if (t == null && (t = 0), !(await this.hasSigner(t))) try {
            await k(this, xc).call(this, "eth_requestAccounts", []);
          } catch (r) {
            const i = r.payload;
            throw this.getRpcError(i, {
              id: i.id,
              error: r
            });
          }
          return await super.getSigner(t);
        }
        static async discover(t) {
          if (t == null && (t = {}), t.provider) return new ia(t.provider);
          const r = t.window ? t.window : typeof window != "undefined" ? window : null;
          if (r == null) return null;
          const i = t.anyProvider;
          if (i && r.ethereum) return new ia(r.ethereum);
          if (!("addEventListener" in r && "dispatchEvent" in r && "removeEventListener" in r)) return null;
          const a = t.timeout ? t.timeout : 300;
          return a === 0 ? null : await new Promise((l, s) => {
            let o = [];
            const c = d => {
                o.push(d.detail), i && u();
              },
              u = () => {
                if (clearTimeout(f), o.length) {
                  if (t && t.filter) {
                    const d = t.filter(o.map(p => Object.assign({}, p.info)));
                    if (d == null) l(null);else if (d instanceof ia) l(d);else {
                      let p = null;
                      if (d.uuid && (p = o.filter(h => d.uuid === h.info.uuid)[0]), p) {
                        const {
                          provider: v,
                          info: h
                        } = p;
                        l(new ia(v, void 0, {
                          providerInfo: h
                        }));
                      } else s(Vt("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                        value: d
                      }));
                    }
                  } else {
                    const {
                      provider: d,
                      info: p
                    } = o[0];
                    l(new ia(d, void 0, {
                      providerInfo: p
                    }));
                  }
                } else l(null);
                r.removeEventListener("eip6963:announceProvider", c);
              },
              f = setTimeout(() => {
                u();
              }, a);
            r.addEventListener("eip6963:announceProvider", c), r.dispatchEvent(new Event("eip6963:requestProvider"));
          });
        }
      };
      xc = new WeakMap(), _c = new WeakMap();
      let Vc = ia;
      class z0 {
        constructor() {
          ce(this, "providerConfig", {});
          ce(this, "tokenConfig", {});
          ce(this, "_address", "");
          ce(this, "_provider", null);
          ce(this, "_signer", null);
          ce(this, "curChainId", 97);
          ce(this, "contractMap", new Map());
          ce(this, "contractReadMap", new Map());
        }
        async init() {}
        async initProviderConfig(e) {
          this.providerConfig = e;
        }
        async initTokenConfig(e) {
          this.tokenConfig = e;
        }
        async initCurChainId(e) {
          this.curChainId = e;
        }
        async connect(e, t) {}
        async isConnected() {
          return !1;
        }
        async sign(e, t) {}
        async getAddress() {
          return this._address;
        }
        async getChainId() {
          return 0;
        }
        async changeChain(e) {}
        async setContractMap(e, t, r) {
          let i = new Mo(t, r, this._signer);
          this.contractMap.set(e, i);
        }
        async setContractReadMap(e, t, r) {
          let i = new Mo(t, r, this._provider);
          this.contractReadMap.set(e, i);
        }
        async getContractMap(e) {
          return this.contractMap.get(e);
        }
        async getContractReadMap(e) {
          return this.contractReadMap.get(e);
        }
        async contractBalance(e, t, r = !1) {
          try {
            const i = await e.balanceOf(t);
            let a = "";
            return r ? a = i.toString() : a = await this.formatEther(i), Number(a);
          } catch (i) {
            return console.log(" contractBalance error ", i), 0;
          }
        }
        async approveContract(e, t, r, i = !1) {
          let a = 0;
          i ? a = r : a = await this.amountToWei(r);
          const l = await e.approve(t, a);
          console.log("approve tx:", l);
        }
        async allowanceNum(e, t, r) {
          try {
            const i = await e.allowance(t, r);
            let a = await this.formatEther(i);
            return Number(a);
          } catch (i) {
            return console.log(" ----------- allowanceNum error  ", i), 0;
          }
        }
        async transferToken(e, t, r, i) {
          let a = await this.amountToWei(r);
          console.log(" == amountWei", a);
          try {
            let l = await e.transfer(t, a);
            console.log("tx", l);
            const s = await l.wait();
            return console.log("receipt", s), l;
          } catch (l) {
            return console.log("transferToken error", l), i && i(), null;
          }
        }
        async formatEther(e) {
          return Number(x1(e)).toFixed(8);
        }
        async amountToWei(e) {
          return _1(e.toString());
        }
        async accountChangedHandler(e) {
          this._address && e[0] != this._address && this.errorHandler("accountChanged");
        }
        async chainChangedHandler(e) {
          console.log("change chainId: ", e), this.errorHandler("chainChanged");
        }
        async disconnectHandler() {
          console.log("disconnect"), this.errorHandler("disconnect");
        }
        async errorHandler(e) {
          console.log(" error ", e);
          try {
            this._provider && this._provider.disconnect && this._provider.disconnect();
          } catch (t) {
            console.log(" --- error ", t);
          }
          localStorage.clear(), sessionStorage.clear(), window.location.reload();
        }
      }
      const Df = class Df extends z0 {
        static get instance() {
          return this._instance || (this._instance = new Df()), this._instance;
        }
        async init() {
          try {
            window.ethereum !== "undefined" && window.ethereum !== void 0 && (window.ethereum.on("disconnect", this.disconnectHandler.bind(this)), window.ethereum.on("accountsChanged", this.accountChangedHandler.bind(this)), window.ethereum.on("chainChanged", this.chainChangedHandler.bind(this)));
          } catch (e) {
            console.error("MetaMaskEVMApi init error", e);
          }
        }
        async connect(e, t) {
          try {
            if (window.ethereum !== "undefined" && window.ethereum !== void 0) {
              if (window.ethereum.isMetaMask) {
                let i = await window.ethereum.request({
                  method: "eth_accounts"
                });
                if (i.length > 0) this._address = i[0];else {
                  let a = await window.ethereum.request({
                    method: "eth_requestAccounts"
                  });
                  this._address = a[0];
                }
                this._address != "" ? (this._provider = new Vc(window.ethereum), this._signer = await this._provider.getSigner(), (await this.getChainId()) == this.curChainId ? this.sign(this._address, e) : this.changeChain(() => {
                  this.sign(this._address, e);
                })) : t && t();
              } else {
                console.log("MetaMask not installed"), t && t();
                return;
              }
            } else {
              console.log("ethereum  not installed"), t && t();
              return;
            }
          } catch {
            t && t();
          }
        }
        async getAddress() {
          return this._address;
        }
        async isConnected() {
          return (await window.ethereum.request({
            method: "eth_accounts"
          })).length > 0;
        }
        async sign(e, t) {
          try {
            await this._signer.signMessage("Welcome to Coinop Game!"), t(e);
          } catch (r) {
            this.errorHandler(r);
          }
        }
        async getChainId() {
          try {
            return (await this._provider.getNetwork()).chainId;
          } catch (e) {
            return console.error("error:", e), 0;
          }
        }
        async changeChain(e) {
          try {
            (await this.getChainId()) != this.curChainId && window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{
                chainId: "0x" + Number(this.curChainId).toString(16)
              }]
            }).then(() => {
              console.log("成功");
            }).catch(async r => {
              console.error(`ERROR:${r.message}`), r.code === 4902 ? window.ethereum.request({
                method: "wallet_addEthereumChain",
                params: [this.providerConfig[this.curChainId]]
              }).then(() => {}).catch(i => {
                this.errorHandler(i);
              }) : (console.log("error: 切链失败", r), this.errorHandler(""));
            });
          } catch (t) {
            console.log("error: 切链失败", t), this.errorHandler("");
          }
        }
        async transferToken(e, t, r, i) {
          let a = this.amountToWei(r);
          try {
            let l = await e.transfer(t, a);
            console.log("tx", l);
            const s = await l.wait();
            return console.log("receipt", s), l;
          } catch (l) {
            return console.log("transferToken error", l), i && i(), null;
          }
        }
      };
      ce(Df, "_instance");
      let _u = Df;
      var qt = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function $0(n) {
        if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
        var e = n.default;
        if (typeof e == "function") {
          var t = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
          };
          t.prototype = e.prototype;
        } else t = {};
        return Object.defineProperty(t, "__esModule", {
          value: !0
        }), Object.keys(n).forEach(function (r) {
          var i = Object.getOwnPropertyDescriptor(n, r);
          Object.defineProperty(t, r, i.get ? i : {
            enumerable: !0,
            get: function () {
              return n[r];
            }
          });
        }), t;
      }
      var Lo = {},
        Uo = {},
        Fo = {},
        av;
      function OE() {
        if (av) return Fo;
        av = 1, Object.defineProperty(Fo, "__esModule", {
          value: !0
        }), Fo.IJSONRpcProvider = Fo.IJSONRpcConnection = void 0;
        class n {}
        Fo.IJSONRpcConnection = n;
        class e {
          constructor(r) {}
        }
        return Fo.IJSONRpcProvider = e, Fo;
      }
      var Q0 = {},
        cv;
      function AE() {
        return cv || (cv = 1, Object.defineProperty(Q0, "__esModule", {
          value: !0
        })), Q0;
      }
      var lv;
      function Y0() {
        return lv || (lv = 1, function (n) {
          var e = Uo && Uo.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = Uo && Uo.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(OE(), n), t(AE(), n);
        }(Uo)), Uo;
      }
      var Ho = {},
        Z0 = {},
        jo = {},
        Wo = {},
        ed = {},
        tr = {},
        td = {},
        uv;
      function zc() {
        return uv || (uv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.ConnectorState = n.CONNECT_PROTOCOL_VER = n.CONNECT_JSONRPC_VER = n.OKXCONNECTOR_SESSION_LIVE_TTL = n.OKXCONNECTOR_MESSAGE_DISCONNECT_TTL = n.OKXCONNECTOR_MESSAGE_TTL = n.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE = n.OKXCONNECTOR_WS_URL_LIST = n.OKXCONNECTOR_WS_URL_IDX_KEY = n.OKXCONNECTOR_WS_URL_3 = n.OKXCONNECTOR_WS_URL_2 = n.OKXCONNECTOR_WS_URL_1 = n.EVENT_EMITTER_MAX_LISTENERS = n.OKXCONNECTOR_PROTOCOL_VERSION = void 0, n.OKXCONNECTOR_PROTOCOL_VERSION = 2, n.EVENT_EMITTER_MAX_LISTENERS = 10, n.OKXCONNECTOR_WS_URL_1 = "wss://wsdexpri.okx.com/ws/v1/wallet-connect-relay", n.OKXCONNECTOR_WS_URL_2 = "wss://wsdexpri.okx.ac/ws/v1/wallet-connect-relay", n.OKXCONNECTOR_WS_URL_3 = "wss://wsdexpri.coinall.ltd/ws/v1/wallet-connect-relay", n.OKXCONNECTOR_WS_URL_IDX_KEY = "wuik", n.OKXCONNECTOR_WS_URL_LIST = [n.OKXCONNECTOR_WS_URL_1, n.OKXCONNECTOR_WS_URL_2, n.OKXCONNECTOR_WS_URL_3], n.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE = {
            TIME_OUT: 3990,
            CANCELED: 3991,
            FINISHED: 3992
          }, n.OKXCONNECTOR_MESSAGE_TTL = 3e5, n.OKXCONNECTOR_MESSAGE_DISCONNECT_TTL = 864e5, n.OKXCONNECTOR_SESSION_LIVE_TTL = 864e5, n.CONNECT_JSONRPC_VER = "2.0", n.CONNECT_PROTOCOL_VER = 2, n.ConnectorState = {
            InitState: 0,
            Connecting: 1,
            Connected: 2,
            Disconnected: 3,
            OnError: 4
          };
        }(td)), td;
      }
      var Dt = {},
        fv;
      function $c() {
        return fv || (fv = 1, Object.defineProperty(Dt, "__esModule", {
          value: !0
        }), Dt.OKXCONNECTOR_STORAGE_TOPIC_WALLET_EXPIRE_CACHE = Dt.OKXCONNECTOR_STORAGE_TOPIC_EXPIRE_CACHE = Dt.OKXCONNECTOR_STORAGE_PROTOCOL_CACHE = Dt.OKXCONNECTOR_STORAGE_CIPHER_METHOD = Dt.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV = Dt.OKXCONNECTOR_STORAGER_CRYPTO_SALT = Dt.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD = Dt.OKXCONNECTOR_TON_KEY = Dt.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE = Dt.OKXCONNECTOR_TOKEN_CACHE = Dt.OKXCONNECTOR_JWT_KEY = Dt.OKXCONNECTOR_SESSION_PREFIX_KEY = Dt.OKXCONNECTOR_CRYPTO_KEY = Dt.OKXCONNECTOR_CACHE_KEY_DAPP = Dt.OKXCONNECTOR_CACHE_KEY = void 0, Dt.OKXCONNECTOR_CACHE_KEY = "ck", Dt.OKXCONNECTOR_CACHE_KEY_DAPP = "ck_dapp", Dt.OKXCONNECTOR_CRYPTO_KEY = "cck_k", Dt.OKXCONNECTOR_SESSION_PREFIX_KEY = "cspk_", Dt.OKXCONNECTOR_JWT_KEY = "cjk_k", Dt.OKXCONNECTOR_TOKEN_CACHE = "ct", Dt.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE = "csp", Dt.OKXCONNECTOR_TON_KEY = "OKXStorage_ctc", Dt.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD = "scp", Dt.OKXCONNECTOR_STORAGER_CRYPTO_SALT = "scs", Dt.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV = "scpc", Dt.OKXCONNECTOR_STORAGE_CIPHER_METHOD = "aes-256-cbc", Dt.OKXCONNECTOR_STORAGE_PROTOCOL_CACHE = "okx_connect_split_cache_key", Dt.OKXCONNECTOR_STORAGE_TOPIC_EXPIRE_CACHE = "okx_connect_te_cache_key", Dt.OKXCONNECTOR_STORAGE_TOPIC_WALLET_EXPIRE_CACHE = "okx_connect_twe_cache_key"), Dt;
      }
      var nr = {};
      function Xo(n) {
        throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
      }
      var nd = {
        exports: {}
      };
      const rd = $0(Object.freeze(Object.defineProperty({
        __proto__: null,
        default: {}
      }, Symbol.toStringTag, {
        value: "Module"
      })));
      var dv;
      function Qc() {
        return dv || (dv = 1, function (n) {
          (function (e) {
            var t = function (P) {
                var U,
                  L = new Float64Array(16);
                if (P) for (U = 0; U < P.length; U++) L[U] = P[U];
                return L;
              },
              r = function () {
                throw new Error("no PRNG");
              },
              i = new Uint8Array(16),
              a = new Uint8Array(32);
            a[0] = 9;
            var l = t(),
              s = t([1]),
              o = t([56129, 1]),
              c = t([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
              u = t([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
              f = t([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
              d = t([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
              p = t([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
            function v(P, U, L, E) {
              P[U] = L >> 24 & 255, P[U + 1] = L >> 16 & 255, P[U + 2] = L >> 8 & 255, P[U + 3] = L & 255, P[U + 4] = E >> 24 & 255, P[U + 5] = E >> 16 & 255, P[U + 6] = E >> 8 & 255, P[U + 7] = E & 255;
            }
            function h(P, U, L, E, H) {
              var ie,
                le = 0;
              for (ie = 0; ie < H; ie++) le |= P[U + ie] ^ L[E + ie];
              return (1 & le - 1 >>> 8) - 1;
            }
            function g(P, U, L, E) {
              return h(P, U, L, E, 16);
            }
            function b(P, U, L, E) {
              return h(P, U, L, E, 32);
            }
            function m(P, U, L, E) {
              for (var H = E[0] & 255 | (E[1] & 255) << 8 | (E[2] & 255) << 16 | (E[3] & 255) << 24, ie = L[0] & 255 | (L[1] & 255) << 8 | (L[2] & 255) << 16 | (L[3] & 255) << 24, le = L[4] & 255 | (L[5] & 255) << 8 | (L[6] & 255) << 16 | (L[7] & 255) << 24, me = L[8] & 255 | (L[9] & 255) << 8 | (L[10] & 255) << 16 | (L[11] & 255) << 24, Ee = L[12] & 255 | (L[13] & 255) << 8 | (L[14] & 255) << 16 | (L[15] & 255) << 24, We = E[4] & 255 | (E[5] & 255) << 8 | (E[6] & 255) << 16 | (E[7] & 255) << 24, Ne = U[0] & 255 | (U[1] & 255) << 8 | (U[2] & 255) << 16 | (U[3] & 255) << 24, Rt = U[4] & 255 | (U[5] & 255) << 8 | (U[6] & 255) << 16 | (U[7] & 255) << 24, Be = U[8] & 255 | (U[9] & 255) << 8 | (U[10] & 255) << 16 | (U[11] & 255) << 24, Ze = U[12] & 255 | (U[13] & 255) << 8 | (U[14] & 255) << 16 | (U[15] & 255) << 24, nt = E[8] & 255 | (E[9] & 255) << 8 | (E[10] & 255) << 16 | (E[11] & 255) << 24, ot = L[16] & 255 | (L[17] & 255) << 8 | (L[18] & 255) << 16 | (L[19] & 255) << 24, it = L[20] & 255 | (L[21] & 255) << 8 | (L[22] & 255) << 16 | (L[23] & 255) << 24, et = L[24] & 255 | (L[25] & 255) << 8 | (L[26] & 255) << 16 | (L[27] & 255) << 24, $e = L[28] & 255 | (L[29] & 255) << 8 | (L[30] & 255) << 16 | (L[31] & 255) << 24, tt = E[12] & 255 | (E[13] & 255) << 8 | (E[14] & 255) << 16 | (E[15] & 255) << 24, Ie = H, qe = ie, Ae = le, Me = me, je = Ee, Re = We, fe = Ne, he = Rt, we = Be, I = Ze, j = nt, K = ot, Q = it, te = et, Y = $e, ue = tt, F, pe = 0; pe < 20; pe += 2) F = Ie + Q | 0, je ^= F << 7 | F >>> 25, F = je + Ie | 0, we ^= F << 9 | F >>> 23, F = we + je | 0, Q ^= F << 13 | F >>> 19, F = Q + we | 0, Ie ^= F << 18 | F >>> 14, F = Re + qe | 0, I ^= F << 7 | F >>> 25, F = I + Re | 0, te ^= F << 9 | F >>> 23, F = te + I | 0, qe ^= F << 13 | F >>> 19, F = qe + te | 0, Re ^= F << 18 | F >>> 14, F = j + fe | 0, Y ^= F << 7 | F >>> 25, F = Y + j | 0, Ae ^= F << 9 | F >>> 23, F = Ae + Y | 0, fe ^= F << 13 | F >>> 19, F = fe + Ae | 0, j ^= F << 18 | F >>> 14, F = ue + K | 0, Me ^= F << 7 | F >>> 25, F = Me + ue | 0, he ^= F << 9 | F >>> 23, F = he + Me | 0, K ^= F << 13 | F >>> 19, F = K + he | 0, ue ^= F << 18 | F >>> 14, F = Ie + Me | 0, qe ^= F << 7 | F >>> 25, F = qe + Ie | 0, Ae ^= F << 9 | F >>> 23, F = Ae + qe | 0, Me ^= F << 13 | F >>> 19, F = Me + Ae | 0, Ie ^= F << 18 | F >>> 14, F = Re + je | 0, fe ^= F << 7 | F >>> 25, F = fe + Re | 0, he ^= F << 9 | F >>> 23, F = he + fe | 0, je ^= F << 13 | F >>> 19, F = je + he | 0, Re ^= F << 18 | F >>> 14, F = j + I | 0, K ^= F << 7 | F >>> 25, F = K + j | 0, we ^= F << 9 | F >>> 23, F = we + K | 0, I ^= F << 13 | F >>> 19, F = I + we | 0, j ^= F << 18 | F >>> 14, F = ue + Y | 0, Q ^= F << 7 | F >>> 25, F = Q + ue | 0, te ^= F << 9 | F >>> 23, F = te + Q | 0, Y ^= F << 13 | F >>> 19, F = Y + te | 0, ue ^= F << 18 | F >>> 14;
              Ie = Ie + H | 0, qe = qe + ie | 0, Ae = Ae + le | 0, Me = Me + me | 0, je = je + Ee | 0, Re = Re + We | 0, fe = fe + Ne | 0, he = he + Rt | 0, we = we + Be | 0, I = I + Ze | 0, j = j + nt | 0, K = K + ot | 0, Q = Q + it | 0, te = te + et | 0, Y = Y + $e | 0, ue = ue + tt | 0, P[0] = Ie >>> 0 & 255, P[1] = Ie >>> 8 & 255, P[2] = Ie >>> 16 & 255, P[3] = Ie >>> 24 & 255, P[4] = qe >>> 0 & 255, P[5] = qe >>> 8 & 255, P[6] = qe >>> 16 & 255, P[7] = qe >>> 24 & 255, P[8] = Ae >>> 0 & 255, P[9] = Ae >>> 8 & 255, P[10] = Ae >>> 16 & 255, P[11] = Ae >>> 24 & 255, P[12] = Me >>> 0 & 255, P[13] = Me >>> 8 & 255, P[14] = Me >>> 16 & 255, P[15] = Me >>> 24 & 255, P[16] = je >>> 0 & 255, P[17] = je >>> 8 & 255, P[18] = je >>> 16 & 255, P[19] = je >>> 24 & 255, P[20] = Re >>> 0 & 255, P[21] = Re >>> 8 & 255, P[22] = Re >>> 16 & 255, P[23] = Re >>> 24 & 255, P[24] = fe >>> 0 & 255, P[25] = fe >>> 8 & 255, P[26] = fe >>> 16 & 255, P[27] = fe >>> 24 & 255, P[28] = he >>> 0 & 255, P[29] = he >>> 8 & 255, P[30] = he >>> 16 & 255, P[31] = he >>> 24 & 255, P[32] = we >>> 0 & 255, P[33] = we >>> 8 & 255, P[34] = we >>> 16 & 255, P[35] = we >>> 24 & 255, P[36] = I >>> 0 & 255, P[37] = I >>> 8 & 255, P[38] = I >>> 16 & 255, P[39] = I >>> 24 & 255, P[40] = j >>> 0 & 255, P[41] = j >>> 8 & 255, P[42] = j >>> 16 & 255, P[43] = j >>> 24 & 255, P[44] = K >>> 0 & 255, P[45] = K >>> 8 & 255, P[46] = K >>> 16 & 255, P[47] = K >>> 24 & 255, P[48] = Q >>> 0 & 255, P[49] = Q >>> 8 & 255, P[50] = Q >>> 16 & 255, P[51] = Q >>> 24 & 255, P[52] = te >>> 0 & 255, P[53] = te >>> 8 & 255, P[54] = te >>> 16 & 255, P[55] = te >>> 24 & 255, P[56] = Y >>> 0 & 255, P[57] = Y >>> 8 & 255, P[58] = Y >>> 16 & 255, P[59] = Y >>> 24 & 255, P[60] = ue >>> 0 & 255, P[61] = ue >>> 8 & 255, P[62] = ue >>> 16 & 255, P[63] = ue >>> 24 & 255;
            }
            function _(P, U, L, E) {
              for (var H = E[0] & 255 | (E[1] & 255) << 8 | (E[2] & 255) << 16 | (E[3] & 255) << 24, ie = L[0] & 255 | (L[1] & 255) << 8 | (L[2] & 255) << 16 | (L[3] & 255) << 24, le = L[4] & 255 | (L[5] & 255) << 8 | (L[6] & 255) << 16 | (L[7] & 255) << 24, me = L[8] & 255 | (L[9] & 255) << 8 | (L[10] & 255) << 16 | (L[11] & 255) << 24, Ee = L[12] & 255 | (L[13] & 255) << 8 | (L[14] & 255) << 16 | (L[15] & 255) << 24, We = E[4] & 255 | (E[5] & 255) << 8 | (E[6] & 255) << 16 | (E[7] & 255) << 24, Ne = U[0] & 255 | (U[1] & 255) << 8 | (U[2] & 255) << 16 | (U[3] & 255) << 24, Rt = U[4] & 255 | (U[5] & 255) << 8 | (U[6] & 255) << 16 | (U[7] & 255) << 24, Be = U[8] & 255 | (U[9] & 255) << 8 | (U[10] & 255) << 16 | (U[11] & 255) << 24, Ze = U[12] & 255 | (U[13] & 255) << 8 | (U[14] & 255) << 16 | (U[15] & 255) << 24, nt = E[8] & 255 | (E[9] & 255) << 8 | (E[10] & 255) << 16 | (E[11] & 255) << 24, ot = L[16] & 255 | (L[17] & 255) << 8 | (L[18] & 255) << 16 | (L[19] & 255) << 24, it = L[20] & 255 | (L[21] & 255) << 8 | (L[22] & 255) << 16 | (L[23] & 255) << 24, et = L[24] & 255 | (L[25] & 255) << 8 | (L[26] & 255) << 16 | (L[27] & 255) << 24, $e = L[28] & 255 | (L[29] & 255) << 8 | (L[30] & 255) << 16 | (L[31] & 255) << 24, tt = E[12] & 255 | (E[13] & 255) << 8 | (E[14] & 255) << 16 | (E[15] & 255) << 24, Ie = H, qe = ie, Ae = le, Me = me, je = Ee, Re = We, fe = Ne, he = Rt, we = Be, I = Ze, j = nt, K = ot, Q = it, te = et, Y = $e, ue = tt, F, pe = 0; pe < 20; pe += 2) F = Ie + Q | 0, je ^= F << 7 | F >>> 25, F = je + Ie | 0, we ^= F << 9 | F >>> 23, F = we + je | 0, Q ^= F << 13 | F >>> 19, F = Q + we | 0, Ie ^= F << 18 | F >>> 14, F = Re + qe | 0, I ^= F << 7 | F >>> 25, F = I + Re | 0, te ^= F << 9 | F >>> 23, F = te + I | 0, qe ^= F << 13 | F >>> 19, F = qe + te | 0, Re ^= F << 18 | F >>> 14, F = j + fe | 0, Y ^= F << 7 | F >>> 25, F = Y + j | 0, Ae ^= F << 9 | F >>> 23, F = Ae + Y | 0, fe ^= F << 13 | F >>> 19, F = fe + Ae | 0, j ^= F << 18 | F >>> 14, F = ue + K | 0, Me ^= F << 7 | F >>> 25, F = Me + ue | 0, he ^= F << 9 | F >>> 23, F = he + Me | 0, K ^= F << 13 | F >>> 19, F = K + he | 0, ue ^= F << 18 | F >>> 14, F = Ie + Me | 0, qe ^= F << 7 | F >>> 25, F = qe + Ie | 0, Ae ^= F << 9 | F >>> 23, F = Ae + qe | 0, Me ^= F << 13 | F >>> 19, F = Me + Ae | 0, Ie ^= F << 18 | F >>> 14, F = Re + je | 0, fe ^= F << 7 | F >>> 25, F = fe + Re | 0, he ^= F << 9 | F >>> 23, F = he + fe | 0, je ^= F << 13 | F >>> 19, F = je + he | 0, Re ^= F << 18 | F >>> 14, F = j + I | 0, K ^= F << 7 | F >>> 25, F = K + j | 0, we ^= F << 9 | F >>> 23, F = we + K | 0, I ^= F << 13 | F >>> 19, F = I + we | 0, j ^= F << 18 | F >>> 14, F = ue + Y | 0, Q ^= F << 7 | F >>> 25, F = Q + ue | 0, te ^= F << 9 | F >>> 23, F = te + Q | 0, Y ^= F << 13 | F >>> 19, F = Y + te | 0, ue ^= F << 18 | F >>> 14;
              P[0] = Ie >>> 0 & 255, P[1] = Ie >>> 8 & 255, P[2] = Ie >>> 16 & 255, P[3] = Ie >>> 24 & 255, P[4] = Re >>> 0 & 255, P[5] = Re >>> 8 & 255, P[6] = Re >>> 16 & 255, P[7] = Re >>> 24 & 255, P[8] = j >>> 0 & 255, P[9] = j >>> 8 & 255, P[10] = j >>> 16 & 255, P[11] = j >>> 24 & 255, P[12] = ue >>> 0 & 255, P[13] = ue >>> 8 & 255, P[14] = ue >>> 16 & 255, P[15] = ue >>> 24 & 255, P[16] = fe >>> 0 & 255, P[17] = fe >>> 8 & 255, P[18] = fe >>> 16 & 255, P[19] = fe >>> 24 & 255, P[20] = he >>> 0 & 255, P[21] = he >>> 8 & 255, P[22] = he >>> 16 & 255, P[23] = he >>> 24 & 255, P[24] = we >>> 0 & 255, P[25] = we >>> 8 & 255, P[26] = we >>> 16 & 255, P[27] = we >>> 24 & 255, P[28] = I >>> 0 & 255, P[29] = I >>> 8 & 255, P[30] = I >>> 16 & 255, P[31] = I >>> 24 & 255;
            }
            function N(P, U, L, E) {
              m(P, U, L, E);
            }
            function O(P, U, L, E) {
              _(P, U, L, E);
            }
            var y = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            function w(P, U, L, E, H, ie, le) {
              var me = new Uint8Array(16),
                Ee = new Uint8Array(64),
                We,
                Ne;
              for (Ne = 0; Ne < 16; Ne++) me[Ne] = 0;
              for (Ne = 0; Ne < 8; Ne++) me[Ne] = ie[Ne];
              for (; H >= 64;) {
                for (N(Ee, me, le, y), Ne = 0; Ne < 64; Ne++) P[U + Ne] = L[E + Ne] ^ Ee[Ne];
                for (We = 1, Ne = 8; Ne < 16; Ne++) We = We + (me[Ne] & 255) | 0, me[Ne] = We & 255, We >>>= 8;
                H -= 64, U += 64, E += 64;
              }
              if (H > 0) for (N(Ee, me, le, y), Ne = 0; Ne < H; Ne++) P[U + Ne] = L[E + Ne] ^ Ee[Ne];
              return 0;
            }
            function A(P, U, L, E, H) {
              var ie = new Uint8Array(16),
                le = new Uint8Array(64),
                me,
                Ee;
              for (Ee = 0; Ee < 16; Ee++) ie[Ee] = 0;
              for (Ee = 0; Ee < 8; Ee++) ie[Ee] = E[Ee];
              for (; L >= 64;) {
                for (N(le, ie, H, y), Ee = 0; Ee < 64; Ee++) P[U + Ee] = le[Ee];
                for (me = 1, Ee = 8; Ee < 16; Ee++) me = me + (ie[Ee] & 255) | 0, ie[Ee] = me & 255, me >>>= 8;
                L -= 64, U += 64;
              }
              if (L > 0) for (N(le, ie, H, y), Ee = 0; Ee < L; Ee++) P[U + Ee] = le[Ee];
              return 0;
            }
            function R(P, U, L, E, H) {
              var ie = new Uint8Array(32);
              O(ie, E, H, y);
              for (var le = new Uint8Array(8), me = 0; me < 8; me++) le[me] = E[me + 16];
              return A(P, U, L, le, ie);
            }
            function T(P, U, L, E, H, ie, le) {
              var me = new Uint8Array(32);
              O(me, ie, le, y);
              for (var Ee = new Uint8Array(8), We = 0; We < 8; We++) Ee[We] = ie[We + 16];
              return w(P, U, L, E, H, Ee, me);
            }
            var D = function (P) {
              this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
              var U, L, E, H, ie, le, me, Ee;
              U = P[0] & 255 | (P[1] & 255) << 8, this.r[0] = U & 8191, L = P[2] & 255 | (P[3] & 255) << 8, this.r[1] = (U >>> 13 | L << 3) & 8191, E = P[4] & 255 | (P[5] & 255) << 8, this.r[2] = (L >>> 10 | E << 6) & 7939, H = P[6] & 255 | (P[7] & 255) << 8, this.r[3] = (E >>> 7 | H << 9) & 8191, ie = P[8] & 255 | (P[9] & 255) << 8, this.r[4] = (H >>> 4 | ie << 12) & 255, this.r[5] = ie >>> 1 & 8190, le = P[10] & 255 | (P[11] & 255) << 8, this.r[6] = (ie >>> 14 | le << 2) & 8191, me = P[12] & 255 | (P[13] & 255) << 8, this.r[7] = (le >>> 11 | me << 5) & 8065, Ee = P[14] & 255 | (P[15] & 255) << 8, this.r[8] = (me >>> 8 | Ee << 8) & 8191, this.r[9] = Ee >>> 5 & 127, this.pad[0] = P[16] & 255 | (P[17] & 255) << 8, this.pad[1] = P[18] & 255 | (P[19] & 255) << 8, this.pad[2] = P[20] & 255 | (P[21] & 255) << 8, this.pad[3] = P[22] & 255 | (P[23] & 255) << 8, this.pad[4] = P[24] & 255 | (P[25] & 255) << 8, this.pad[5] = P[26] & 255 | (P[27] & 255) << 8, this.pad[6] = P[28] & 255 | (P[29] & 255) << 8, this.pad[7] = P[30] & 255 | (P[31] & 255) << 8;
            };
            D.prototype.blocks = function (P, U, L) {
              for (var E = this.fin ? 0 : 2048, H, ie, le, me, Ee, We, Ne, Rt, Be, Ze, nt, ot, it, et, $e, tt, Ie, qe, Ae, Me = this.h[0], je = this.h[1], Re = this.h[2], fe = this.h[3], he = this.h[4], we = this.h[5], I = this.h[6], j = this.h[7], K = this.h[8], Q = this.h[9], te = this.r[0], Y = this.r[1], ue = this.r[2], F = this.r[3], pe = this.r[4], ge = this.r[5], ve = this.r[6], xe = this.r[7], De = this.r[8], He = this.r[9]; L >= 16;) H = P[U + 0] & 255 | (P[U + 1] & 255) << 8, Me += H & 8191, ie = P[U + 2] & 255 | (P[U + 3] & 255) << 8, je += (H >>> 13 | ie << 3) & 8191, le = P[U + 4] & 255 | (P[U + 5] & 255) << 8, Re += (ie >>> 10 | le << 6) & 8191, me = P[U + 6] & 255 | (P[U + 7] & 255) << 8, fe += (le >>> 7 | me << 9) & 8191, Ee = P[U + 8] & 255 | (P[U + 9] & 255) << 8, he += (me >>> 4 | Ee << 12) & 8191, we += Ee >>> 1 & 8191, We = P[U + 10] & 255 | (P[U + 11] & 255) << 8, I += (Ee >>> 14 | We << 2) & 8191, Ne = P[U + 12] & 255 | (P[U + 13] & 255) << 8, j += (We >>> 11 | Ne << 5) & 8191, Rt = P[U + 14] & 255 | (P[U + 15] & 255) << 8, K += (Ne >>> 8 | Rt << 8) & 8191, Q += Rt >>> 5 | E, Be = 0, Ze = Be, Ze += Me * te, Ze += je * (5 * He), Ze += Re * (5 * De), Ze += fe * (5 * xe), Ze += he * (5 * ve), Be = Ze >>> 13, Ze &= 8191, Ze += we * (5 * ge), Ze += I * (5 * pe), Ze += j * (5 * F), Ze += K * (5 * ue), Ze += Q * (5 * Y), Be += Ze >>> 13, Ze &= 8191, nt = Be, nt += Me * Y, nt += je * te, nt += Re * (5 * He), nt += fe * (5 * De), nt += he * (5 * xe), Be = nt >>> 13, nt &= 8191, nt += we * (5 * ve), nt += I * (5 * ge), nt += j * (5 * pe), nt += K * (5 * F), nt += Q * (5 * ue), Be += nt >>> 13, nt &= 8191, ot = Be, ot += Me * ue, ot += je * Y, ot += Re * te, ot += fe * (5 * He), ot += he * (5 * De), Be = ot >>> 13, ot &= 8191, ot += we * (5 * xe), ot += I * (5 * ve), ot += j * (5 * ge), ot += K * (5 * pe), ot += Q * (5 * F), Be += ot >>> 13, ot &= 8191, it = Be, it += Me * F, it += je * ue, it += Re * Y, it += fe * te, it += he * (5 * He), Be = it >>> 13, it &= 8191, it += we * (5 * De), it += I * (5 * xe), it += j * (5 * ve), it += K * (5 * ge), it += Q * (5 * pe), Be += it >>> 13, it &= 8191, et = Be, et += Me * pe, et += je * F, et += Re * ue, et += fe * Y, et += he * te, Be = et >>> 13, et &= 8191, et += we * (5 * He), et += I * (5 * De), et += j * (5 * xe), et += K * (5 * ve), et += Q * (5 * ge), Be += et >>> 13, et &= 8191, $e = Be, $e += Me * ge, $e += je * pe, $e += Re * F, $e += fe * ue, $e += he * Y, Be = $e >>> 13, $e &= 8191, $e += we * te, $e += I * (5 * He), $e += j * (5 * De), $e += K * (5 * xe), $e += Q * (5 * ve), Be += $e >>> 13, $e &= 8191, tt = Be, tt += Me * ve, tt += je * ge, tt += Re * pe, tt += fe * F, tt += he * ue, Be = tt >>> 13, tt &= 8191, tt += we * Y, tt += I * te, tt += j * (5 * He), tt += K * (5 * De), tt += Q * (5 * xe), Be += tt >>> 13, tt &= 8191, Ie = Be, Ie += Me * xe, Ie += je * ve, Ie += Re * ge, Ie += fe * pe, Ie += he * F, Be = Ie >>> 13, Ie &= 8191, Ie += we * ue, Ie += I * Y, Ie += j * te, Ie += K * (5 * He), Ie += Q * (5 * De), Be += Ie >>> 13, Ie &= 8191, qe = Be, qe += Me * De, qe += je * xe, qe += Re * ve, qe += fe * ge, qe += he * pe, Be = qe >>> 13, qe &= 8191, qe += we * F, qe += I * ue, qe += j * Y, qe += K * te, qe += Q * (5 * He), Be += qe >>> 13, qe &= 8191, Ae = Be, Ae += Me * He, Ae += je * De, Ae += Re * xe, Ae += fe * ve, Ae += he * ge, Be = Ae >>> 13, Ae &= 8191, Ae += we * pe, Ae += I * F, Ae += j * ue, Ae += K * Y, Ae += Q * te, Be += Ae >>> 13, Ae &= 8191, Be = (Be << 2) + Be | 0, Be = Be + Ze | 0, Ze = Be & 8191, Be = Be >>> 13, nt += Be, Me = Ze, je = nt, Re = ot, fe = it, he = et, we = $e, I = tt, j = Ie, K = qe, Q = Ae, U += 16, L -= 16;
              this.h[0] = Me, this.h[1] = je, this.h[2] = Re, this.h[3] = fe, this.h[4] = he, this.h[5] = we, this.h[6] = I, this.h[7] = j, this.h[8] = K, this.h[9] = Q;
            }, D.prototype.finish = function (P, U) {
              var L = new Uint16Array(10),
                E,
                H,
                ie,
                le;
              if (this.leftover) {
                for (le = this.leftover, this.buffer[le++] = 1; le < 16; le++) this.buffer[le] = 0;
                this.fin = 1, this.blocks(this.buffer, 0, 16);
              }
              for (E = this.h[1] >>> 13, this.h[1] &= 8191, le = 2; le < 10; le++) this.h[le] += E, E = this.h[le] >>> 13, this.h[le] &= 8191;
              for (this.h[0] += E * 5, E = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += E, E = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += E, L[0] = this.h[0] + 5, E = L[0] >>> 13, L[0] &= 8191, le = 1; le < 10; le++) L[le] = this.h[le] + E, E = L[le] >>> 13, L[le] &= 8191;
              for (L[9] -= 8192, H = (E ^ 1) - 1, le = 0; le < 10; le++) L[le] &= H;
              for (H = ~H, le = 0; le < 10; le++) this.h[le] = this.h[le] & H | L[le];
              for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, ie = this.h[0] + this.pad[0], this.h[0] = ie & 65535, le = 1; le < 8; le++) ie = (this.h[le] + this.pad[le] | 0) + (ie >>> 16) | 0, this.h[le] = ie & 65535;
              P[U + 0] = this.h[0] >>> 0 & 255, P[U + 1] = this.h[0] >>> 8 & 255, P[U + 2] = this.h[1] >>> 0 & 255, P[U + 3] = this.h[1] >>> 8 & 255, P[U + 4] = this.h[2] >>> 0 & 255, P[U + 5] = this.h[2] >>> 8 & 255, P[U + 6] = this.h[3] >>> 0 & 255, P[U + 7] = this.h[3] >>> 8 & 255, P[U + 8] = this.h[4] >>> 0 & 255, P[U + 9] = this.h[4] >>> 8 & 255, P[U + 10] = this.h[5] >>> 0 & 255, P[U + 11] = this.h[5] >>> 8 & 255, P[U + 12] = this.h[6] >>> 0 & 255, P[U + 13] = this.h[6] >>> 8 & 255, P[U + 14] = this.h[7] >>> 0 & 255, P[U + 15] = this.h[7] >>> 8 & 255;
            }, D.prototype.update = function (P, U, L) {
              var E, H;
              if (this.leftover) {
                for (H = 16 - this.leftover, H > L && (H = L), E = 0; E < H; E++) this.buffer[this.leftover + E] = P[U + E];
                if (L -= H, U += H, this.leftover += H, this.leftover < 16) return;
                this.blocks(this.buffer, 0, 16), this.leftover = 0;
              }
              if (L >= 16 && (H = L - L % 16, this.blocks(P, U, H), U += H, L -= H), L) {
                for (E = 0; E < L; E++) this.buffer[this.leftover + E] = P[U + E];
                this.leftover += L;
              }
            };
            function M(P, U, L, E, H, ie) {
              var le = new D(ie);
              return le.update(L, E, H), le.finish(P, U), 0;
            }
            function q(P, U, L, E, H, ie) {
              var le = new Uint8Array(16);
              return M(le, 0, L, E, H, ie), g(P, U, le, 0);
            }
            function W(P, U, L, E, H) {
              var ie;
              if (L < 32) return -1;
              for (T(P, 0, U, 0, L, E, H), M(P, 16, P, 32, L - 32, P), ie = 0; ie < 16; ie++) P[ie] = 0;
              return 0;
            }
            function x(P, U, L, E, H) {
              var ie,
                le = new Uint8Array(32);
              if (L < 32 || (R(le, 0, 32, E, H), q(U, 16, U, 32, L - 32, le) !== 0)) return -1;
              for (T(P, 0, U, 0, L, E, H), ie = 0; ie < 32; ie++) P[ie] = 0;
              return 0;
            }
            function C(P, U) {
              var L;
              for (L = 0; L < 16; L++) P[L] = U[L] | 0;
            }
            function B(P) {
              var U,
                L,
                E = 1;
              for (U = 0; U < 16; U++) L = P[U] + E + 65535, E = Math.floor(L / 65536), P[U] = L - E * 65536;
              P[0] += E - 1 + 37 * (E - 1);
            }
            function X(P, U, L) {
              for (var E, H = ~(L - 1), ie = 0; ie < 16; ie++) E = H & (P[ie] ^ U[ie]), P[ie] ^= E, U[ie] ^= E;
            }
            function J(P, U) {
              var L,
                E,
                H,
                ie = t(),
                le = t();
              for (L = 0; L < 16; L++) le[L] = U[L];
              for (B(le), B(le), B(le), E = 0; E < 2; E++) {
                for (ie[0] = le[0] - 65517, L = 1; L < 15; L++) ie[L] = le[L] - 65535 - (ie[L - 1] >> 16 & 1), ie[L - 1] &= 65535;
                ie[15] = le[15] - 32767 - (ie[14] >> 16 & 1), H = ie[15] >> 16 & 1, ie[14] &= 65535, X(le, ie, 1 - H);
              }
              for (L = 0; L < 16; L++) P[2 * L] = le[L] & 255, P[2 * L + 1] = le[L] >> 8;
            }
            function V(P, U) {
              var L = new Uint8Array(32),
                E = new Uint8Array(32);
              return J(L, P), J(E, U), b(L, 0, E, 0);
            }
            function $(P) {
              var U = new Uint8Array(32);
              return J(U, P), U[0] & 1;
            }
            function se(P, U) {
              var L;
              for (L = 0; L < 16; L++) P[L] = U[2 * L] + (U[2 * L + 1] << 8);
              P[15] &= 32767;
            }
            function ne(P, U, L) {
              for (var E = 0; E < 16; E++) P[E] = U[E] + L[E];
            }
            function oe(P, U, L) {
              for (var E = 0; E < 16; E++) P[E] = U[E] - L[E];
            }
            function ye(P, U, L) {
              var E,
                H,
                ie = 0,
                le = 0,
                me = 0,
                Ee = 0,
                We = 0,
                Ne = 0,
                Rt = 0,
                Be = 0,
                Ze = 0,
                nt = 0,
                ot = 0,
                it = 0,
                et = 0,
                $e = 0,
                tt = 0,
                Ie = 0,
                qe = 0,
                Ae = 0,
                Me = 0,
                je = 0,
                Re = 0,
                fe = 0,
                he = 0,
                we = 0,
                I = 0,
                j = 0,
                K = 0,
                Q = 0,
                te = 0,
                Y = 0,
                ue = 0,
                F = L[0],
                pe = L[1],
                ge = L[2],
                ve = L[3],
                xe = L[4],
                De = L[5],
                He = L[6],
                Qe = L[7],
                Ye = L[8],
                st = L[9],
                Nt = L[10],
                Wt = L[11],
                on = L[12],
                Rn = L[13],
                bn = L[14],
                In = L[15];
              E = U[0], ie += E * F, le += E * pe, me += E * ge, Ee += E * ve, We += E * xe, Ne += E * De, Rt += E * He, Be += E * Qe, Ze += E * Ye, nt += E * st, ot += E * Nt, it += E * Wt, et += E * on, $e += E * Rn, tt += E * bn, Ie += E * In, E = U[1], le += E * F, me += E * pe, Ee += E * ge, We += E * ve, Ne += E * xe, Rt += E * De, Be += E * He, Ze += E * Qe, nt += E * Ye, ot += E * st, it += E * Nt, et += E * Wt, $e += E * on, tt += E * Rn, Ie += E * bn, qe += E * In, E = U[2], me += E * F, Ee += E * pe, We += E * ge, Ne += E * ve, Rt += E * xe, Be += E * De, Ze += E * He, nt += E * Qe, ot += E * Ye, it += E * st, et += E * Nt, $e += E * Wt, tt += E * on, Ie += E * Rn, qe += E * bn, Ae += E * In, E = U[3], Ee += E * F, We += E * pe, Ne += E * ge, Rt += E * ve, Be += E * xe, Ze += E * De, nt += E * He, ot += E * Qe, it += E * Ye, et += E * st, $e += E * Nt, tt += E * Wt, Ie += E * on, qe += E * Rn, Ae += E * bn, Me += E * In, E = U[4], We += E * F, Ne += E * pe, Rt += E * ge, Be += E * ve, Ze += E * xe, nt += E * De, ot += E * He, it += E * Qe, et += E * Ye, $e += E * st, tt += E * Nt, Ie += E * Wt, qe += E * on, Ae += E * Rn, Me += E * bn, je += E * In, E = U[5], Ne += E * F, Rt += E * pe, Be += E * ge, Ze += E * ve, nt += E * xe, ot += E * De, it += E * He, et += E * Qe, $e += E * Ye, tt += E * st, Ie += E * Nt, qe += E * Wt, Ae += E * on, Me += E * Rn, je += E * bn, Re += E * In, E = U[6], Rt += E * F, Be += E * pe, Ze += E * ge, nt += E * ve, ot += E * xe, it += E * De, et += E * He, $e += E * Qe, tt += E * Ye, Ie += E * st, qe += E * Nt, Ae += E * Wt, Me += E * on, je += E * Rn, Re += E * bn, fe += E * In, E = U[7], Be += E * F, Ze += E * pe, nt += E * ge, ot += E * ve, it += E * xe, et += E * De, $e += E * He, tt += E * Qe, Ie += E * Ye, qe += E * st, Ae += E * Nt, Me += E * Wt, je += E * on, Re += E * Rn, fe += E * bn, he += E * In, E = U[8], Ze += E * F, nt += E * pe, ot += E * ge, it += E * ve, et += E * xe, $e += E * De, tt += E * He, Ie += E * Qe, qe += E * Ye, Ae += E * st, Me += E * Nt, je += E * Wt, Re += E * on, fe += E * Rn, he += E * bn, we += E * In, E = U[9], nt += E * F, ot += E * pe, it += E * ge, et += E * ve, $e += E * xe, tt += E * De, Ie += E * He, qe += E * Qe, Ae += E * Ye, Me += E * st, je += E * Nt, Re += E * Wt, fe += E * on, he += E * Rn, we += E * bn, I += E * In, E = U[10], ot += E * F, it += E * pe, et += E * ge, $e += E * ve, tt += E * xe, Ie += E * De, qe += E * He, Ae += E * Qe, Me += E * Ye, je += E * st, Re += E * Nt, fe += E * Wt, he += E * on, we += E * Rn, I += E * bn, j += E * In, E = U[11], it += E * F, et += E * pe, $e += E * ge, tt += E * ve, Ie += E * xe, qe += E * De, Ae += E * He, Me += E * Qe, je += E * Ye, Re += E * st, fe += E * Nt, he += E * Wt, we += E * on, I += E * Rn, j += E * bn, K += E * In, E = U[12], et += E * F, $e += E * pe, tt += E * ge, Ie += E * ve, qe += E * xe, Ae += E * De, Me += E * He, je += E * Qe, Re += E * Ye, fe += E * st, he += E * Nt, we += E * Wt, I += E * on, j += E * Rn, K += E * bn, Q += E * In, E = U[13], $e += E * F, tt += E * pe, Ie += E * ge, qe += E * ve, Ae += E * xe, Me += E * De, je += E * He, Re += E * Qe, fe += E * Ye, he += E * st, we += E * Nt, I += E * Wt, j += E * on, K += E * Rn, Q += E * bn, te += E * In, E = U[14], tt += E * F, Ie += E * pe, qe += E * ge, Ae += E * ve, Me += E * xe, je += E * De, Re += E * He, fe += E * Qe, he += E * Ye, we += E * st, I += E * Nt, j += E * Wt, K += E * on, Q += E * Rn, te += E * bn, Y += E * In, E = U[15], Ie += E * F, qe += E * pe, Ae += E * ge, Me += E * ve, je += E * xe, Re += E * De, fe += E * He, he += E * Qe, we += E * Ye, I += E * st, j += E * Nt, K += E * Wt, Q += E * on, te += E * Rn, Y += E * bn, ue += E * In, ie += 38 * qe, le += 38 * Ae, me += 38 * Me, Ee += 38 * je, We += 38 * Re, Ne += 38 * fe, Rt += 38 * he, Be += 38 * we, Ze += 38 * I, nt += 38 * j, ot += 38 * K, it += 38 * Q, et += 38 * te, $e += 38 * Y, tt += 38 * ue, H = 1, E = ie + H + 65535, H = Math.floor(E / 65536), ie = E - H * 65536, E = le + H + 65535, H = Math.floor(E / 65536), le = E - H * 65536, E = me + H + 65535, H = Math.floor(E / 65536), me = E - H * 65536, E = Ee + H + 65535, H = Math.floor(E / 65536), Ee = E - H * 65536, E = We + H + 65535, H = Math.floor(E / 65536), We = E - H * 65536, E = Ne + H + 65535, H = Math.floor(E / 65536), Ne = E - H * 65536, E = Rt + H + 65535, H = Math.floor(E / 65536), Rt = E - H * 65536, E = Be + H + 65535, H = Math.floor(E / 65536), Be = E - H * 65536, E = Ze + H + 65535, H = Math.floor(E / 65536), Ze = E - H * 65536, E = nt + H + 65535, H = Math.floor(E / 65536), nt = E - H * 65536, E = ot + H + 65535, H = Math.floor(E / 65536), ot = E - H * 65536, E = it + H + 65535, H = Math.floor(E / 65536), it = E - H * 65536, E = et + H + 65535, H = Math.floor(E / 65536), et = E - H * 65536, E = $e + H + 65535, H = Math.floor(E / 65536), $e = E - H * 65536, E = tt + H + 65535, H = Math.floor(E / 65536), tt = E - H * 65536, E = Ie + H + 65535, H = Math.floor(E / 65536), Ie = E - H * 65536, ie += H - 1 + 37 * (H - 1), H = 1, E = ie + H + 65535, H = Math.floor(E / 65536), ie = E - H * 65536, E = le + H + 65535, H = Math.floor(E / 65536), le = E - H * 65536, E = me + H + 65535, H = Math.floor(E / 65536), me = E - H * 65536, E = Ee + H + 65535, H = Math.floor(E / 65536), Ee = E - H * 65536, E = We + H + 65535, H = Math.floor(E / 65536), We = E - H * 65536, E = Ne + H + 65535, H = Math.floor(E / 65536), Ne = E - H * 65536, E = Rt + H + 65535, H = Math.floor(E / 65536), Rt = E - H * 65536, E = Be + H + 65535, H = Math.floor(E / 65536), Be = E - H * 65536, E = Ze + H + 65535, H = Math.floor(E / 65536), Ze = E - H * 65536, E = nt + H + 65535, H = Math.floor(E / 65536), nt = E - H * 65536, E = ot + H + 65535, H = Math.floor(E / 65536), ot = E - H * 65536, E = it + H + 65535, H = Math.floor(E / 65536), it = E - H * 65536, E = et + H + 65535, H = Math.floor(E / 65536), et = E - H * 65536, E = $e + H + 65535, H = Math.floor(E / 65536), $e = E - H * 65536, E = tt + H + 65535, H = Math.floor(E / 65536), tt = E - H * 65536, E = Ie + H + 65535, H = Math.floor(E / 65536), Ie = E - H * 65536, ie += H - 1 + 37 * (H - 1), P[0] = ie, P[1] = le, P[2] = me, P[3] = Ee, P[4] = We, P[5] = Ne, P[6] = Rt, P[7] = Be, P[8] = Ze, P[9] = nt, P[10] = ot, P[11] = it, P[12] = et, P[13] = $e, P[14] = tt, P[15] = Ie;
            }
            function Te(P, U) {
              ye(P, U, U);
            }
            function ae(P, U) {
              var L = t(),
                E;
              for (E = 0; E < 16; E++) L[E] = U[E];
              for (E = 253; E >= 0; E--) Te(L, L), E !== 2 && E !== 4 && ye(L, L, U);
              for (E = 0; E < 16; E++) P[E] = L[E];
            }
            function G(P, U) {
              var L = t(),
                E;
              for (E = 0; E < 16; E++) L[E] = U[E];
              for (E = 250; E >= 0; E--) Te(L, L), E !== 1 && ye(L, L, U);
              for (E = 0; E < 16; E++) P[E] = L[E];
            }
            function Z(P, U, L) {
              var E = new Uint8Array(32),
                H = new Float64Array(80),
                ie,
                le,
                me = t(),
                Ee = t(),
                We = t(),
                Ne = t(),
                Rt = t(),
                Be = t();
              for (le = 0; le < 31; le++) E[le] = U[le];
              for (E[31] = U[31] & 127 | 64, E[0] &= 248, se(H, L), le = 0; le < 16; le++) Ee[le] = H[le], Ne[le] = me[le] = We[le] = 0;
              for (me[0] = Ne[0] = 1, le = 254; le >= 0; --le) ie = E[le >>> 3] >>> (le & 7) & 1, X(me, Ee, ie), X(We, Ne, ie), ne(Rt, me, We), oe(me, me, We), ne(We, Ee, Ne), oe(Ee, Ee, Ne), Te(Ne, Rt), Te(Be, me), ye(me, We, me), ye(We, Ee, Rt), ne(Rt, me, We), oe(me, me, We), Te(Ee, me), oe(We, Ne, Be), ye(me, We, o), ne(me, me, Ne), ye(We, We, me), ye(me, Ne, Be), ye(Ne, Ee, H), Te(Ee, Rt), X(me, Ee, ie), X(We, Ne, ie);
              for (le = 0; le < 16; le++) H[le + 16] = me[le], H[le + 32] = We[le], H[le + 48] = Ee[le], H[le + 64] = Ne[le];
              var Ze = H.subarray(32),
                nt = H.subarray(16);
              return ae(Ze, Ze), ye(nt, nt, Ze), J(P, nt), 0;
            }
            function S(P, U) {
              return Z(P, U, a);
            }
            function ee(P, U) {
              return r(U, 32), S(P, U);
            }
            function Ce(P, U, L) {
              var E = new Uint8Array(32);
              return Z(E, L, U), O(P, i, E, y);
            }
            var Oe = W,
              Xe = x;
            function Ve(P, U, L, E, H, ie) {
              var le = new Uint8Array(32);
              return Ce(le, H, ie), Oe(P, U, L, E, le);
            }
            function at(P, U, L, E, H, ie) {
              var le = new Uint8Array(32);
              return Ce(le, H, ie), Xe(P, U, L, E, le);
            }
            var ht = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
            function Et(P, U, L, E) {
              for (var H = new Int32Array(16), ie = new Int32Array(16), le, me, Ee, We, Ne, Rt, Be, Ze, nt, ot, it, et, $e, tt, Ie, qe, Ae, Me, je, Re, fe, he, we, I, j, K, Q = P[0], te = P[1], Y = P[2], ue = P[3], F = P[4], pe = P[5], ge = P[6], ve = P[7], xe = U[0], De = U[1], He = U[2], Qe = U[3], Ye = U[4], st = U[5], Nt = U[6], Wt = U[7], on = 0; E >= 128;) {
                for (je = 0; je < 16; je++) Re = 8 * je + on, H[je] = L[Re + 0] << 24 | L[Re + 1] << 16 | L[Re + 2] << 8 | L[Re + 3], ie[je] = L[Re + 4] << 24 | L[Re + 5] << 16 | L[Re + 6] << 8 | L[Re + 7];
                for (je = 0; je < 80; je++) if (le = Q, me = te, Ee = Y, We = ue, Ne = F, Rt = pe, Be = ge, Ze = ve, nt = xe, ot = De, it = He, et = Qe, $e = Ye, tt = st, Ie = Nt, qe = Wt, fe = ve, he = Wt, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = (F >>> 14 | Ye << 18) ^ (F >>> 18 | Ye << 14) ^ (Ye >>> 9 | F << 23), he = (Ye >>> 14 | F << 18) ^ (Ye >>> 18 | F << 14) ^ (F >>> 9 | Ye << 23), we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, fe = F & pe ^ ~F & ge, he = Ye & st ^ ~Ye & Nt, we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, fe = ht[je * 2], he = ht[je * 2 + 1], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, fe = H[je % 16], he = ie[je % 16], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, Ae = j & 65535 | K << 16, Me = we & 65535 | I << 16, fe = Ae, he = Me, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = (Q >>> 28 | xe << 4) ^ (xe >>> 2 | Q << 30) ^ (xe >>> 7 | Q << 25), he = (xe >>> 28 | Q << 4) ^ (Q >>> 2 | xe << 30) ^ (Q >>> 7 | xe << 25), we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, fe = Q & te ^ Q & Y ^ te & Y, he = xe & De ^ xe & He ^ De & He, we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, Ze = j & 65535 | K << 16, qe = we & 65535 | I << 16, fe = We, he = et, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = Ae, he = Me, we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, We = j & 65535 | K << 16, et = we & 65535 | I << 16, te = le, Y = me, ue = Ee, F = We, pe = Ne, ge = Rt, ve = Be, Q = Ze, De = nt, He = ot, Qe = it, Ye = et, st = $e, Nt = tt, Wt = Ie, xe = qe, je % 16 === 15) for (Re = 0; Re < 16; Re++) fe = H[Re], he = ie[Re], we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = H[(Re + 9) % 16], he = ie[(Re + 9) % 16], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, Ae = H[(Re + 1) % 16], Me = ie[(Re + 1) % 16], fe = (Ae >>> 1 | Me << 31) ^ (Ae >>> 8 | Me << 24) ^ Ae >>> 7, he = (Me >>> 1 | Ae << 31) ^ (Me >>> 8 | Ae << 24) ^ (Me >>> 7 | Ae << 25), we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, Ae = H[(Re + 14) % 16], Me = ie[(Re + 14) % 16], fe = (Ae >>> 19 | Me << 13) ^ (Me >>> 29 | Ae << 3) ^ Ae >>> 6, he = (Me >>> 19 | Ae << 13) ^ (Ae >>> 29 | Me << 3) ^ (Me >>> 6 | Ae << 26), we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, H[Re] = j & 65535 | K << 16, ie[Re] = we & 65535 | I << 16;
                fe = Q, he = xe, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[0], he = U[0], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[0] = Q = j & 65535 | K << 16, U[0] = xe = we & 65535 | I << 16, fe = te, he = De, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[1], he = U[1], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[1] = te = j & 65535 | K << 16, U[1] = De = we & 65535 | I << 16, fe = Y, he = He, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[2], he = U[2], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[2] = Y = j & 65535 | K << 16, U[2] = He = we & 65535 | I << 16, fe = ue, he = Qe, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[3], he = U[3], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[3] = ue = j & 65535 | K << 16, U[3] = Qe = we & 65535 | I << 16, fe = F, he = Ye, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[4], he = U[4], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[4] = F = j & 65535 | K << 16, U[4] = Ye = we & 65535 | I << 16, fe = pe, he = st, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[5], he = U[5], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[5] = pe = j & 65535 | K << 16, U[5] = st = we & 65535 | I << 16, fe = ge, he = Nt, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[6], he = U[6], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[6] = ge = j & 65535 | K << 16, U[6] = Nt = we & 65535 | I << 16, fe = ve, he = Wt, we = he & 65535, I = he >>> 16, j = fe & 65535, K = fe >>> 16, fe = P[7], he = U[7], we += he & 65535, I += he >>> 16, j += fe & 65535, K += fe >>> 16, I += we >>> 16, j += I >>> 16, K += j >>> 16, P[7] = ve = j & 65535 | K << 16, U[7] = Wt = we & 65535 | I << 16, on += 128, E -= 128;
              }
              return E;
            }
            function vt(P, U, L) {
              var E = new Int32Array(8),
                H = new Int32Array(8),
                ie = new Uint8Array(256),
                le,
                me = L;
              for (E[0] = 1779033703, E[1] = 3144134277, E[2] = 1013904242, E[3] = 2773480762, E[4] = 1359893119, E[5] = 2600822924, E[6] = 528734635, E[7] = 1541459225, H[0] = 4089235720, H[1] = 2227873595, H[2] = 4271175723, H[3] = 1595750129, H[4] = 2917565137, H[5] = 725511199, H[6] = 4215389547, H[7] = 327033209, Et(E, H, U, L), L %= 128, le = 0; le < L; le++) ie[le] = U[me - L + le];
              for (ie[L] = 128, L = 256 - 128 * (L < 112 ? 1 : 0), ie[L - 9] = 0, v(ie, L - 8, me / 536870912 | 0, me << 3), Et(E, H, ie, L), le = 0; le < 8; le++) v(P, 8 * le, E[le], H[le]);
              return 0;
            }
            function It(P, U) {
              var L = t(),
                E = t(),
                H = t(),
                ie = t(),
                le = t(),
                me = t(),
                Ee = t(),
                We = t(),
                Ne = t();
              oe(L, P[1], P[0]), oe(Ne, U[1], U[0]), ye(L, L, Ne), ne(E, P[0], P[1]), ne(Ne, U[0], U[1]), ye(E, E, Ne), ye(H, P[3], U[3]), ye(H, H, u), ye(ie, P[2], U[2]), ne(ie, ie, ie), oe(le, E, L), oe(me, ie, H), ne(Ee, ie, H), ne(We, E, L), ye(P[0], le, me), ye(P[1], We, Ee), ye(P[2], Ee, me), ye(P[3], le, We);
            }
            function yt(P, U, L) {
              var E;
              for (E = 0; E < 4; E++) X(P[E], U[E], L);
            }
            function ut(P, U) {
              var L = t(),
                E = t(),
                H = t();
              ae(H, U[2]), ye(L, U[0], H), ye(E, U[1], H), J(P, E), P[31] ^= $(L) << 7;
            }
            function rt(P, U, L) {
              var E, H;
              for (C(P[0], l), C(P[1], s), C(P[2], s), C(P[3], l), H = 255; H >= 0; --H) E = L[H / 8 | 0] >> (H & 7) & 1, yt(P, U, E), It(U, P), It(P, P), yt(P, U, E);
            }
            function pt(P, U) {
              var L = [t(), t(), t(), t()];
              C(L[0], f), C(L[1], d), C(L[2], s), ye(L[3], f, d), rt(P, L, U);
            }
            function Ct(P, U, L) {
              var E = new Uint8Array(64),
                H = [t(), t(), t(), t()],
                ie;
              for (L || r(U, 32), vt(E, U, 32), E[0] &= 248, E[31] &= 127, E[31] |= 64, pt(H, E), ut(P, H), ie = 0; ie < 32; ie++) U[ie + 32] = P[ie];
              return 0;
            }
            var Pe = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
            function Fe(P, U) {
              var L, E, H, ie;
              for (E = 63; E >= 32; --E) {
                for (L = 0, H = E - 32, ie = E - 12; H < ie; ++H) U[H] += L - 16 * U[E] * Pe[H - (E - 32)], L = Math.floor((U[H] + 128) / 256), U[H] -= L * 256;
                U[H] += L, U[E] = 0;
              }
              for (L = 0, H = 0; H < 32; H++) U[H] += L - (U[31] >> 4) * Pe[H], L = U[H] >> 8, U[H] &= 255;
              for (H = 0; H < 32; H++) U[H] -= L * Pe[H];
              for (E = 0; E < 32; E++) U[E + 1] += U[E] >> 8, P[E] = U[E] & 255;
            }
            function ke(P) {
              var U = new Float64Array(64),
                L;
              for (L = 0; L < 64; L++) U[L] = P[L];
              for (L = 0; L < 64; L++) P[L] = 0;
              Fe(P, U);
            }
            function ze(P, U, L, E) {
              var H = new Uint8Array(64),
                ie = new Uint8Array(64),
                le = new Uint8Array(64),
                me,
                Ee,
                We = new Float64Array(64),
                Ne = [t(), t(), t(), t()];
              vt(H, E, 32), H[0] &= 248, H[31] &= 127, H[31] |= 64;
              var Rt = L + 64;
              for (me = 0; me < L; me++) P[64 + me] = U[me];
              for (me = 0; me < 32; me++) P[32 + me] = H[32 + me];
              for (vt(le, P.subarray(32), L + 32), ke(le), pt(Ne, le), ut(P, Ne), me = 32; me < 64; me++) P[me] = E[me];
              for (vt(ie, P, L + 64), ke(ie), me = 0; me < 64; me++) We[me] = 0;
              for (me = 0; me < 32; me++) We[me] = le[me];
              for (me = 0; me < 32; me++) for (Ee = 0; Ee < 32; Ee++) We[me + Ee] += ie[me] * H[Ee];
              return Fe(P.subarray(32), We), Rt;
            }
            function Bt(P, U) {
              var L = t(),
                E = t(),
                H = t(),
                ie = t(),
                le = t(),
                me = t(),
                Ee = t();
              return C(P[2], s), se(P[1], U), Te(H, P[1]), ye(ie, H, c), oe(H, H, P[2]), ne(ie, P[2], ie), Te(le, ie), Te(me, le), ye(Ee, me, le), ye(L, Ee, H), ye(L, L, ie), G(L, L), ye(L, L, H), ye(L, L, ie), ye(L, L, ie), ye(P[0], L, ie), Te(E, P[0]), ye(E, E, ie), V(E, H) && ye(P[0], P[0], p), Te(E, P[0]), ye(E, E, ie), V(E, H) ? -1 : ($(P[0]) === U[31] >> 7 && oe(P[0], l, P[0]), ye(P[3], P[0], P[1]), 0);
            }
            function mt(P, U, L, E) {
              var H,
                ie = new Uint8Array(32),
                le = new Uint8Array(64),
                me = [t(), t(), t(), t()],
                Ee = [t(), t(), t(), t()];
              if (L < 64 || Bt(Ee, E)) return -1;
              for (H = 0; H < L; H++) P[H] = U[H];
              for (H = 0; H < 32; H++) P[H + 32] = E[H];
              if (vt(le, P, L), ke(le), rt(me, Ee, le), pt(Ee, U.subarray(32)), It(me, Ee), ut(ie, me), L -= 64, b(U, 0, ie, 0)) {
                for (H = 0; H < L; H++) P[H] = 0;
                return -1;
              }
              for (H = 0; H < L; H++) P[H] = U[H + 64];
              return L;
            }
            var Je = 32,
              Ke = 24,
              St = 32,
              Gt = 16,
              hn = 32,
              On = 32,
              An = 32,
              Gn = 32,
              mn = 32,
              ni = Ke,
              Di = St,
              rn = Gt,
              Lt = 64,
              Ht = 32,
              jt = 64,
              $t = 32,
              Qt = 64;
            e.lowlevel = {
              crypto_core_hsalsa20: O,
              crypto_stream_xor: T,
              crypto_stream: R,
              crypto_stream_salsa20_xor: w,
              crypto_stream_salsa20: A,
              crypto_onetimeauth: M,
              crypto_onetimeauth_verify: q,
              crypto_verify_16: g,
              crypto_verify_32: b,
              crypto_secretbox: W,
              crypto_secretbox_open: x,
              crypto_scalarmult: Z,
              crypto_scalarmult_base: S,
              crypto_box_beforenm: Ce,
              crypto_box_afternm: Oe,
              crypto_box: Ve,
              crypto_box_open: at,
              crypto_box_keypair: ee,
              crypto_hash: vt,
              crypto_sign: ze,
              crypto_sign_keypair: Ct,
              crypto_sign_open: mt,
              crypto_secretbox_KEYBYTES: Je,
              crypto_secretbox_NONCEBYTES: Ke,
              crypto_secretbox_ZEROBYTES: St,
              crypto_secretbox_BOXZEROBYTES: Gt,
              crypto_scalarmult_BYTES: hn,
              crypto_scalarmult_SCALARBYTES: On,
              crypto_box_PUBLICKEYBYTES: An,
              crypto_box_SECRETKEYBYTES: Gn,
              crypto_box_BEFORENMBYTES: mn,
              crypto_box_NONCEBYTES: ni,
              crypto_box_ZEROBYTES: Di,
              crypto_box_BOXZEROBYTES: rn,
              crypto_sign_BYTES: Lt,
              crypto_sign_PUBLICKEYBYTES: Ht,
              crypto_sign_SECRETKEYBYTES: jt,
              crypto_sign_SEEDBYTES: $t,
              crypto_hash_BYTES: Qt,
              gf: t,
              D: c,
              L: Pe,
              pack25519: J,
              unpack25519: se,
              M: ye,
              A: ne,
              S: Te,
              Z: oe,
              pow2523: G,
              add: It,
              set25519: C,
              modL: Fe,
              scalarmult: rt,
              scalarbase: pt
            };
            function Yt(P, U) {
              if (P.length !== Je) throw new Error("bad key size");
              if (U.length !== Ke) throw new Error("bad nonce size");
            }
            function ln(P, U) {
              if (P.length !== An) throw new Error("bad public key size");
              if (U.length !== Gn) throw new Error("bad secret key size");
            }
            function Ot() {
              for (var P = 0; P < arguments.length; P++) if (!(arguments[P] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
            }
            function At(P) {
              for (var U = 0; U < P.length; U++) P[U] = 0;
            }
            e.randomBytes = function (P) {
              var U = new Uint8Array(P);
              return r(U, P), U;
            }, e.secretbox = function (P, U, L) {
              Ot(P, U, L), Yt(L, U);
              for (var E = new Uint8Array(St + P.length), H = new Uint8Array(E.length), ie = 0; ie < P.length; ie++) E[ie + St] = P[ie];
              return W(H, E, E.length, U, L), H.subarray(Gt);
            }, e.secretbox.open = function (P, U, L) {
              Ot(P, U, L), Yt(L, U);
              for (var E = new Uint8Array(Gt + P.length), H = new Uint8Array(E.length), ie = 0; ie < P.length; ie++) E[ie + Gt] = P[ie];
              return E.length < 32 || x(H, E, E.length, U, L) !== 0 ? null : H.subarray(St);
            }, e.secretbox.keyLength = Je, e.secretbox.nonceLength = Ke, e.secretbox.overheadLength = Gt, e.scalarMult = function (P, U) {
              if (Ot(P, U), P.length !== On) throw new Error("bad n size");
              if (U.length !== hn) throw new Error("bad p size");
              var L = new Uint8Array(hn);
              return Z(L, P, U), L;
            }, e.scalarMult.base = function (P) {
              if (Ot(P), P.length !== On) throw new Error("bad n size");
              var U = new Uint8Array(hn);
              return S(U, P), U;
            }, e.scalarMult.scalarLength = On, e.scalarMult.groupElementLength = hn, e.box = function (P, U, L, E) {
              var H = e.box.before(L, E);
              return e.secretbox(P, U, H);
            }, e.box.before = function (P, U) {
              Ot(P, U), ln(P, U);
              var L = new Uint8Array(mn);
              return Ce(L, P, U), L;
            }, e.box.after = e.secretbox, e.box.open = function (P, U, L, E) {
              var H = e.box.before(L, E);
              return e.secretbox.open(P, U, H);
            }, e.box.open.after = e.secretbox.open, e.box.keyPair = function () {
              var P = new Uint8Array(An),
                U = new Uint8Array(Gn);
              return ee(P, U), {
                publicKey: P,
                secretKey: U
              };
            }, e.box.keyPair.fromSecretKey = function (P) {
              if (Ot(P), P.length !== Gn) throw new Error("bad secret key size");
              var U = new Uint8Array(An);
              return S(U, P), {
                publicKey: U,
                secretKey: new Uint8Array(P)
              };
            }, e.box.publicKeyLength = An, e.box.secretKeyLength = Gn, e.box.sharedKeyLength = mn, e.box.nonceLength = ni, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function (P, U) {
              if (Ot(P, U), U.length !== jt) throw new Error("bad secret key size");
              var L = new Uint8Array(Lt + P.length);
              return ze(L, P, P.length, U), L;
            }, e.sign.open = function (P, U) {
              if (Ot(P, U), U.length !== Ht) throw new Error("bad public key size");
              var L = new Uint8Array(P.length),
                E = mt(L, P, P.length, U);
              if (E < 0) return null;
              for (var H = new Uint8Array(E), ie = 0; ie < H.length; ie++) H[ie] = L[ie];
              return H;
            }, e.sign.detached = function (P, U) {
              for (var L = e.sign(P, U), E = new Uint8Array(Lt), H = 0; H < E.length; H++) E[H] = L[H];
              return E;
            }, e.sign.detached.verify = function (P, U, L) {
              if (Ot(P, U, L), U.length !== Lt) throw new Error("bad signature size");
              if (L.length !== Ht) throw new Error("bad public key size");
              var E = new Uint8Array(Lt + P.length),
                H = new Uint8Array(Lt + P.length),
                ie;
              for (ie = 0; ie < Lt; ie++) E[ie] = U[ie];
              for (ie = 0; ie < P.length; ie++) E[ie + Lt] = P[ie];
              return mt(H, E, E.length, L) >= 0;
            }, e.sign.keyPair = function () {
              var P = new Uint8Array(Ht),
                U = new Uint8Array(jt);
              return Ct(P, U), {
                publicKey: P,
                secretKey: U
              };
            }, e.sign.keyPair.fromSecretKey = function (P) {
              if (Ot(P), P.length !== jt) throw new Error("bad secret key size");
              for (var U = new Uint8Array(Ht), L = 0; L < U.length; L++) U[L] = P[32 + L];
              return {
                publicKey: U,
                secretKey: new Uint8Array(P)
              };
            }, e.sign.keyPair.fromSeed = function (P) {
              if (Ot(P), P.length !== $t) throw new Error("bad seed size");
              for (var U = new Uint8Array(Ht), L = new Uint8Array(jt), E = 0; E < 32; E++) L[E] = P[E];
              return Ct(U, L, !0), {
                publicKey: U,
                secretKey: L
              };
            }, e.sign.publicKeyLength = Ht, e.sign.secretKeyLength = jt, e.sign.seedLength = $t, e.sign.signatureLength = Lt, e.hash = function (P) {
              Ot(P);
              var U = new Uint8Array(Qt);
              return vt(U, P, P.length), U;
            }, e.hash.hashLength = Qt, e.verify = function (P, U) {
              return Ot(P, U), P.length === 0 || U.length === 0 || P.length !== U.length ? !1 : h(P, 0, U, 0, P.length) === 0;
            }, e.setPRNG = function (P) {
              r = P;
            }, function () {
              var P = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
              if (P && P.getRandomValues) {
                var U = 65536;
                e.setPRNG(function (L, E) {
                  var H,
                    ie = new Uint8Array(E);
                  for (H = 0; H < E; H += U) P.getRandomValues(ie.subarray(H, H + Math.min(E - H, U)));
                  for (H = 0; H < E; H++) L[H] = ie[H];
                  At(ie);
                });
              } else typeof Xo != "undefined" && (P = rd, P && P.randomBytes && e.setPRNG(function (L, E) {
                var H,
                  ie = P.randomBytes(E);
                for (H = 0; H < E; H++) L[H] = ie[H];
                At(ie);
              }));
            }();
          })(n.exports ? n.exports : self.nacl = self.nacl || {});
        }(nd)), nd.exports;
      }
      var Yc = {},
        Eu = {
          exports: {}
        },
        RE = Eu.exports,
        hv;
      function NE() {
        return hv || (hv = 1, function (n) {
          (function (e, t) {
            n.exports ? n.exports = t() : (e.nacl || (e.nacl = {}), e.nacl.util = t());
          })(RE, function () {
            var e = {};
            function t(r) {
              if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(r)) throw new TypeError("invalid encoding");
            }
            return e.decodeUTF8 = function (r) {
              if (typeof r != "string") throw new TypeError("expected string");
              var i,
                a = unescape(encodeURIComponent(r)),
                l = new Uint8Array(a.length);
              for (i = 0; i < a.length; i++) l[i] = a.charCodeAt(i);
              return l;
            }, e.encodeUTF8 = function (r) {
              var i,
                a = [];
              for (i = 0; i < r.length; i++) a.push(String.fromCharCode(r[i]));
              return decodeURIComponent(escape(a.join("")));
            }, typeof atob == "undefined" ? typeof Buffer.from != "undefined" ? (e.encodeBase64 = function (r) {
              return Buffer.from(r).toString("base64");
            }, e.decodeBase64 = function (r) {
              return t(r), new Uint8Array(Array.prototype.slice.call(Buffer.from(r, "base64"), 0));
            }) : (e.encodeBase64 = function (r) {
              return new Buffer(r).toString("base64");
            }, e.decodeBase64 = function (r) {
              return t(r), new Uint8Array(Array.prototype.slice.call(new Buffer(r, "base64"), 0));
            }) : (e.encodeBase64 = function (r) {
              var i,
                a = [],
                l = r.length;
              for (i = 0; i < l; i++) a.push(String.fromCharCode(r[i]));
              return btoa(a.join(""));
            }, e.decodeBase64 = function (r) {
              t(r);
              var i,
                a = atob(r),
                l = new Uint8Array(a.length);
              for (i = 0; i < a.length; i++) l[i] = a.charCodeAt(i);
              return l;
            }), e;
          });
        }(Eu)), Eu.exports;
      }
      function SE(n, e) {
        if (n.length >= 255) throw new TypeError("Alphabet too long");
        for (var t = new Uint8Array(256), r = 0; r < t.length; r++) t[r] = 255;
        for (var i = 0; i < n.length; i++) {
          var a = n.charAt(i),
            l = a.charCodeAt(0);
          if (t[l] !== 255) throw new TypeError(a + " is ambiguous");
          t[l] = i;
        }
        var s = n.length,
          o = n.charAt(0),
          c = Math.log(s) / Math.log(256),
          u = Math.log(256) / Math.log(s);
        function f(v) {
          if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
          if (v.length === 0) return "";
          for (var h = 0, g = 0, b = 0, m = v.length; b !== m && v[b] === 0;) b++, h++;
          for (var _ = (m - b) * u + 1 >>> 0, N = new Uint8Array(_); b !== m;) {
            for (var O = v[b], y = 0, w = _ - 1; (O !== 0 || y < g) && w !== -1; w--, y++) O += 256 * N[w] >>> 0, N[w] = O % s >>> 0, O = O / s >>> 0;
            if (O !== 0) throw new Error("Non-zero carry");
            g = y, b++;
          }
          for (var A = _ - g; A !== _ && N[A] === 0;) A++;
          for (var R = o.repeat(h); A < _; ++A) R += n.charAt(N[A]);
          return R;
        }
        function d(v) {
          if (typeof v != "string") throw new TypeError("Expected String");
          if (v.length === 0) return new Uint8Array();
          var h = 0;
          if (v[h] !== " ") {
            for (var g = 0, b = 0; v[h] === o;) g++, h++;
            for (var m = (v.length - h) * c + 1 >>> 0, _ = new Uint8Array(m); v[h];) {
              var N = t[v.charCodeAt(h)];
              if (N === 255) return;
              for (var O = 0, y = m - 1; (N !== 0 || O < b) && y !== -1; y--, O++) N += s * _[y] >>> 0, _[y] = N % 256 >>> 0, N = N / 256 >>> 0;
              if (N !== 0) throw new Error("Non-zero carry");
              b = O, h++;
            }
            if (v[h] !== " ") {
              for (var w = m - b; w !== m && _[w] === 0;) w++;
              for (var A = new Uint8Array(g + (m - w)), R = g; w !== m;) A[R++] = _[w++];
              return A;
            }
          }
        }
        function p(v) {
          var h = d(v);
          if (h) return h;
          throw new Error(`Non-${e} character`);
        }
        return {
          encode: f,
          decodeUnsafe: d,
          decode: p
        };
      }
      var TE = SE,
        DE = TE;
      const pv = new Uint8Array(0),
        PE = n => n.reduce((e, t) => e + t.toString(16).padStart(2, "0"), ""),
        IE = n => {
          const e = n.match(/../g);
          return e ? new Uint8Array(e.map(t => parseInt(t, 16))) : pv;
        },
        gv = (n, e) => {
          if (n === e) return !0;
          if (n.byteLength !== e.byteLength) return !1;
          for (let t = 0; t < n.byteLength; t++) if (n[t] !== e[t]) return !1;
          return !0;
        },
        Ra = n => {
          if (n instanceof Uint8Array && n.constructor.name === "Uint8Array") return n;
          if (n instanceof ArrayBuffer) return new Uint8Array(n);
          if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
          throw new Error("Unknown type, must be binary type");
        },
        BE = n => n instanceof ArrayBuffer || ArrayBuffer.isView(n),
        vv = n => new TextEncoder().encode(n),
        yv = n => new TextDecoder().decode(n),
        kE = Object.freeze(Object.defineProperty({
          __proto__: null,
          coerce: Ra,
          empty: pv,
          equals: gv,
          fromHex: IE,
          fromString: vv,
          isBinary: BE,
          toHex: PE,
          toString: yv
        }, Symbol.toStringTag, {
          value: "Module"
        }));
      class ME {
        constructor(e, t, r) {
          this.name = e, this.prefix = t, this.baseEncode = r;
        }
        encode(e) {
          if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
          throw Error("Unknown type, must be binary type");
        }
      }
      class KE {
        constructor(e, t, r) {
          this.name = e, this.prefix = t, this.baseDecode = r;
        }
        decode(e) {
          if (typeof e == "string") switch (e[0]) {
            case this.prefix:
              return this.baseDecode(e.slice(1));
            default:
              throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          } else throw Error("Can only multibase decode strings");
        }
        or(e) {
          const t = {
            [this.prefix]: this,
            ...(e.decoders || {
              [e.prefix]: e
            })
          };
          return new id(t);
        }
      }
      class id {
        constructor(e) {
          this.decoders = e;
        }
        or(e) {
          const t = e.decoders || {
            [e.prefix]: e
          };
          return new id({
            ...this.decoders,
            ...t
          });
        }
        decode(e) {
          const t = e[0],
            r = this.decoders[t];
          if (r) return r.decode(e);
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
      class LE {
        constructor(e, t, r, i) {
          this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = i, this.encoder = new ME(e, t, r), this.decoder = new KE(e, t, i);
        }
        encode(e) {
          return this.encoder.encode(e);
        }
        decode(e) {
          return this.decoder.decode(e);
        }
      }
      const od = ({
          name: n,
          prefix: e,
          encode: t,
          decode: r
        }) => new LE(n, e, t, r),
        Zc = ({
          prefix: n,
          name: e,
          alphabet: t
        }) => {
          const {
            encode: r,
            decode: i
          } = DE(t, e);
          return od({
            prefix: n,
            name: e,
            encode: r,
            decode: a => Ra(i(a))
          });
        },
        UE = (n, e, t, r) => {
          const i = {};
          for (let u = 0; u < e.length; ++u) i[e[u]] = u;
          let a = n.length;
          for (; n[a - 1] === "=";) --a;
          const l = new Uint8Array(a * t / 8 | 0);
          let s = 0,
            o = 0,
            c = 0;
          for (let u = 0; u < a; ++u) {
            const f = i[n[u]];
            if (f === void 0) throw new SyntaxError(`Non-${r} character`);
            o = o << t | f, s += t, s >= 8 && (s -= 8, l[c++] = 255 & o >> s);
          }
          if (s >= t || 255 & o << 8 - s) throw new SyntaxError("Unexpected end of data");
          return l;
        },
        FE = (n, e, t) => {
          const r = e[e.length - 1] === "=",
            i = (1 << t) - 1;
          let a = "",
            l = 0,
            s = 0;
          for (let o = 0; o < n.length; ++o) for (s = s << 8 | n[o], l += 8; l > t;) l -= t, a += e[i & s >> l];
          if (l && (a += e[i & s << t - l]), r) for (; a.length * t & 7;) a += "=";
          return a;
        },
        Dn = ({
          name: n,
          prefix: e,
          bitsPerChar: t,
          alphabet: r
        }) => od({
          prefix: e,
          name: n,
          encode(i) {
            return FE(i, r, t);
          },
          decode(i) {
            return UE(i, r, t, n);
          }
        }),
        HE = od({
          prefix: "\0",
          name: "identity",
          encode: n => yv(n),
          decode: n => vv(n)
        }),
        jE = Object.freeze(Object.defineProperty({
          __proto__: null,
          identity: HE
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        WE = Dn({
          prefix: "0",
          name: "base2",
          alphabet: "01",
          bitsPerChar: 1
        }),
        XE = Object.freeze(Object.defineProperty({
          __proto__: null,
          base2: WE
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        qE = Dn({
          prefix: "7",
          name: "base8",
          alphabet: "01234567",
          bitsPerChar: 3
        }),
        JE = Object.freeze(Object.defineProperty({
          __proto__: null,
          base8: qE
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        GE = Zc({
          prefix: "9",
          name: "base10",
          alphabet: "0123456789"
        }),
        VE = Object.freeze(Object.defineProperty({
          __proto__: null,
          base10: GE
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        zE = Dn({
          prefix: "f",
          name: "base16",
          alphabet: "0123456789abcdef",
          bitsPerChar: 4
        }),
        $E = Dn({
          prefix: "F",
          name: "base16upper",
          alphabet: "0123456789ABCDEF",
          bitsPerChar: 4
        }),
        QE = Object.freeze(Object.defineProperty({
          __proto__: null,
          base16: zE,
          base16upper: $E
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        el = Dn({
          prefix: "b",
          name: "base32",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567",
          bitsPerChar: 5
        }),
        YE = Dn({
          prefix: "B",
          name: "base32upper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          bitsPerChar: 5
        }),
        ZE = Dn({
          prefix: "c",
          name: "base32pad",
          alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
          bitsPerChar: 5
        }),
        eC = Dn({
          prefix: "C",
          name: "base32padupper",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
          bitsPerChar: 5
        }),
        tC = Dn({
          prefix: "v",
          name: "base32hex",
          alphabet: "0123456789abcdefghijklmnopqrstuv",
          bitsPerChar: 5
        }),
        nC = Dn({
          prefix: "V",
          name: "base32hexupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          bitsPerChar: 5
        }),
        rC = Dn({
          prefix: "t",
          name: "base32hexpad",
          alphabet: "0123456789abcdefghijklmnopqrstuv=",
          bitsPerChar: 5
        }),
        iC = Dn({
          prefix: "T",
          name: "base32hexpadupper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
          bitsPerChar: 5
        }),
        oC = Dn({
          prefix: "h",
          name: "base32z",
          alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
          bitsPerChar: 5
        }),
        sC = Object.freeze(Object.defineProperty({
          __proto__: null,
          base32: el,
          base32hex: tC,
          base32hexpad: rC,
          base32hexpadupper: iC,
          base32hexupper: nC,
          base32pad: ZE,
          base32padupper: eC,
          base32upper: YE,
          base32z: oC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        aC = Zc({
          prefix: "k",
          name: "base36",
          alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
        }),
        cC = Zc({
          prefix: "K",
          name: "base36upper",
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        }),
        lC = Object.freeze(Object.defineProperty({
          __proto__: null,
          base36: aC,
          base36upper: cC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        di = Zc({
          name: "base58btc",
          prefix: "z",
          alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        }),
        uC = Zc({
          name: "base58flickr",
          prefix: "Z",
          alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
        }),
        fC = Object.freeze(Object.defineProperty({
          __proto__: null,
          base58btc: di,
          base58flickr: uC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        dC = Dn({
          prefix: "m",
          name: "base64",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          bitsPerChar: 6
        }),
        hC = Dn({
          prefix: "M",
          name: "base64pad",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          bitsPerChar: 6
        }),
        pC = Dn({
          prefix: "u",
          name: "base64url",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          bitsPerChar: 6
        }),
        gC = Dn({
          prefix: "U",
          name: "base64urlpad",
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          bitsPerChar: 6
        }),
        vC = Object.freeze(Object.defineProperty({
          __proto__: null,
          base64: dC,
          base64pad: hC,
          base64url: pC,
          base64urlpad: gC
        }, Symbol.toStringTag, {
          value: "Module"
        }));
      var yC = bv,
        mv = 128,
        mC = -128,
        bC = Math.pow(2, 31);
      function bv(n, e, t) {
        e = e || [], t = t || 0;
        for (var r = t; n >= bC;) e[t++] = n & 255 | mv, n /= 128;
        for (; n & mC;) e[t++] = n & 255 | mv, n >>>= 7;
        return e[t] = n | 0, bv.bytes = t - r + 1, e;
      }
      var wC = sd,
        xC = 128,
        wv = 127;
      function sd(n, r) {
        var t = 0,
          r = r || 0,
          i = 0,
          a = r,
          l,
          s = n.length;
        do {
          if (a >= s) throw sd.bytes = 0, new RangeError("Could not decode varint");
          l = n[a++], t += i < 28 ? (l & wv) << i : (l & wv) * Math.pow(2, i), i += 7;
        } while (l >= xC);
        return sd.bytes = a - r, t;
      }
      var _C = Math.pow(2, 7),
        EC = Math.pow(2, 14),
        CC = Math.pow(2, 21),
        OC = Math.pow(2, 28),
        AC = Math.pow(2, 35),
        RC = Math.pow(2, 42),
        NC = Math.pow(2, 49),
        SC = Math.pow(2, 56),
        TC = Math.pow(2, 63),
        DC = function (n) {
          return n < _C ? 1 : n < EC ? 2 : n < CC ? 3 : n < OC ? 4 : n < AC ? 5 : n < RC ? 6 : n < NC ? 7 : n < SC ? 8 : n < TC ? 9 : 10;
        },
        PC = {
          encode: yC,
          decode: wC,
          encodingLength: DC
        },
        Cu = PC;
      const Ou = n => [Cu.decode(n), Cu.decode.bytes],
        tl = (n, e, t = 0) => (Cu.encode(n, e, t), e),
        nl = n => Cu.encodingLength(n),
        IC = Object.freeze(Object.defineProperty({
          __proto__: null,
          decode: Ou,
          encodeTo: tl,
          encodingLength: nl
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        ad = (n, e) => {
          const t = e.byteLength,
            r = nl(n),
            i = r + nl(t),
            a = new Uint8Array(i + t);
          return tl(n, a, 0), tl(t, a, r), a.set(e, i), new Au(n, t, e, a);
        },
        xv = n => {
          const e = Ra(n),
            [t, r] = Ou(e),
            [i, a] = Ou(e.subarray(r)),
            l = e.subarray(r + a);
          if (l.byteLength !== i) throw new Error("Incorrect length");
          return new Au(t, i, l, e);
        },
        _v = (n, e) => n === e ? !0 : n.code === e.code && n.size === e.size && gv(n.bytes, e.bytes);
      class Au {
        constructor(e, t, r, i) {
          this.code = e, this.size = t, this.digest = r, this.bytes = i;
        }
      }
      const BC = Object.freeze(Object.defineProperty({
          __proto__: null,
          Digest: Au,
          create: ad,
          decode: xv,
          equals: _v
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        Ru = ({
          name: n,
          code: e,
          encode: t
        }) => new Ev(n, e, t);
      class Ev {
        constructor(e, t, r) {
          this.name = e, this.code = t, this.encode = r;
        }
        async digest(e) {
          if (e instanceof Uint8Array) {
            const t = await this.encode(e);
            return ad(this.code, t);
          } else throw Error("Unknown type, must be binary type");
        }
      }
      const kC = Object.freeze(Object.defineProperty({
          __proto__: null,
          Hasher: Ev,
          from: Ru
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        Cv = n => async e => new Uint8Array(await crypto.subtle.digest(n, e)),
        MC = Ru({
          name: "sha2-256",
          code: 18,
          encode: Cv("SHA-256")
        }),
        KC = Ru({
          name: "sha2-512",
          code: 19,
          encode: Cv("SHA-512")
        }),
        LC = Object.freeze(Object.defineProperty({
          __proto__: null,
          sha256: MC,
          sha512: KC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        UC = Ru({
          name: "identity",
          code: 0,
          encode: n => Ra(n)
        }),
        FC = Object.freeze(Object.defineProperty({
          __proto__: null,
          identity: UC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        Ov = n => Ra(n),
        {
          name: HC,
          code: jC,
          encode: WC,
          decode: XC
        } = {
          name: "raw",
          code: 85,
          decode: Ov,
          encode: Ov
        },
        qC = Object.freeze(Object.defineProperty({
          __proto__: null,
          code: jC,
          decode: XC,
          encode: WC,
          name: HC
        }, Symbol.toStringTag, {
          value: "Module"
        })),
        {
          name: JC,
          code: GC,
          encode: VC,
          decode: zC
        } = {
          name: "json",
          code: 512,
          encode: n => new TextEncoder().encode(JSON.stringify(n)),
          decode: n => JSON.parse(new TextDecoder().decode(n))
        },
        $C = Object.freeze(Object.defineProperty({
          __proto__: null,
          code: GC,
          decode: zC,
          encode: VC,
          name: JC
        }, Symbol.toStringTag, {
          value: "Module"
        }));
      class kn {
        constructor(e, t, r, i) {
          this.code = t, this.version = e, this.multihash = r, this.bytes = i, this.byteOffset = i.byteOffset, this.byteLength = i.byteLength, this.asCID = this, this._baseCache = new Map(), Object.defineProperties(this, {
            byteOffset: Su,
            byteLength: Su,
            code: Nu,
            version: Nu,
            multihash: Nu,
            bytes: Nu,
            _baseCache: Su,
            asCID: Su
          });
        }
        toV0() {
          switch (this.version) {
            case 0:
              return this;
            default:
              {
                const {
                  code: e,
                  multihash: t
                } = this;
                if (e !== rl) throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                if (t.code !== eO) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                return kn.createV0(t);
              }
          }
        }
        toV1() {
          switch (this.version) {
            case 0:
              {
                const {
                    code: e,
                    digest: t
                  } = this.multihash,
                  r = ad(e, t);
                return kn.createV1(this.code, r);
              }
            case 1:
              return this;
            default:
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
        equals(e) {
          return e && this.code === e.code && this.version === e.version && _v(this.multihash, e.multihash);
        }
        toString(e) {
          const {
            bytes: t,
            version: r,
            _baseCache: i
          } = this;
          switch (r) {
            case 0:
              return YC(t, i, e || di.encoder);
            default:
              return ZC(t, i, e || el.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(e) {
          return nO(/^0\.0/, rO), !!(e && (e[Rv] || e.asCID === e));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(e) {
          if (e instanceof kn) return e;
          if (e != null && e.asCID === e) {
            const {
              version: t,
              code: r,
              multihash: i,
              bytes: a
            } = e;
            return new kn(t, r, i, a || Av(t, r, i.bytes));
          } else if (e != null && e[Rv] === !0) {
            const {
                version: t,
                multihash: r,
                code: i
              } = e,
              a = xv(r);
            return kn.create(t, i, a);
          } else return null;
        }
        static create(e, t, r) {
          if (typeof t != "number") throw new Error("String codecs are no longer supported");
          switch (e) {
            case 0:
              {
                if (t !== rl) throw new Error(`Version 0 CID must use dag-pb (code: ${rl}) block encoding`);
                return new kn(e, t, r, r.bytes);
              }
            case 1:
              {
                const i = Av(e, t, r.bytes);
                return new kn(e, t, r, i);
              }
            default:
              throw new Error("Invalid version");
          }
        }
        static createV0(e) {
          return kn.create(0, rl, e);
        }
        static createV1(e, t) {
          return kn.create(1, e, t);
        }
        static decode(e) {
          const [t, r] = kn.decodeFirst(e);
          if (r.length) throw new Error("Incorrect length");
          return t;
        }
        static decodeFirst(e) {
          const t = kn.inspectBytes(e),
            r = t.size - t.multihashSize,
            i = Ra(e.subarray(r, r + t.multihashSize));
          if (i.byteLength !== t.multihashSize) throw new Error("Incorrect length");
          const a = i.subarray(t.multihashSize - t.digestSize),
            l = new Au(t.multihashCode, t.digestSize, a, i);
          return [t.version === 0 ? kn.createV0(l) : kn.createV1(t.codec, l), e.subarray(t.size)];
        }
        static inspectBytes(e) {
          let t = 0;
          const r = () => {
            const [f, d] = Ou(e.subarray(t));
            return t += d, f;
          };
          let i = r(),
            a = rl;
          if (i === 18 ? (i = 0, t = 0) : i === 1 && (a = r()), i !== 0 && i !== 1) throw new RangeError(`Invalid CID version ${i}`);
          const l = t,
            s = r(),
            o = r(),
            c = t + o,
            u = c - l;
          return {
            version: i,
            codec: a,
            multihashCode: s,
            digestSize: o,
            multihashSize: u,
            size: c
          };
        }
        static parse(e, t) {
          const [r, i] = QC(e, t),
            a = kn.decode(i);
          return a._baseCache.set(r, e), a;
        }
      }
      const QC = (n, e) => {
          switch (n[0]) {
            case "Q":
              {
                const t = e || di;
                return [di.prefix, t.decode(`${di.prefix}${n}`)];
              }
            case di.prefix:
              {
                const t = e || di;
                return [di.prefix, t.decode(n)];
              }
            case el.prefix:
              {
                const t = e || el;
                return [el.prefix, t.decode(n)];
              }
            default:
              {
                if (e == null) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                return [n[0], e.decode(n)];
              }
          }
        },
        YC = (n, e, t) => {
          const {
            prefix: r
          } = t;
          if (r !== di.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`);
          const i = e.get(r);
          if (i == null) {
            const a = t.encode(n).slice(1);
            return e.set(r, a), a;
          } else return i;
        },
        ZC = (n, e, t) => {
          const {
              prefix: r
            } = t,
            i = e.get(r);
          if (i == null) {
            const a = t.encode(n);
            return e.set(r, a), a;
          } else return i;
        },
        rl = 112,
        eO = 18,
        Av = (n, e, t) => {
          const r = nl(n),
            i = r + nl(e),
            a = new Uint8Array(i + t.byteLength);
          return tl(n, a, 0), tl(e, a, r), a.set(t, i), a;
        },
        Rv = Symbol.for("@ipld/js-cid/CID"),
        Nu = {
          writable: !1,
          configurable: !1,
          enumerable: !0
        },
        Su = {
          writable: !1,
          enumerable: !1,
          configurable: !1
        },
        tO = "0.0.0-dev",
        nO = (n, e) => {
          if (n.test(tO)) console.warn(e);else throw new Error(e);
        },
        rO = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
        cd = {
          ...jE,
          ...XE,
          ...JE,
          ...VE,
          ...QE,
          ...sC,
          ...lC,
          ...fC,
          ...vC
        },
        iO = {
          ...LC,
          ...FC
        },
        oO = Object.freeze(Object.defineProperty({
          __proto__: null,
          CID: kn,
          bases: cd,
          bytes: kE,
          codecs: {
            raw: qC,
            json: $C
          },
          digest: BC,
          hasher: kC,
          hashes: iO,
          varint: IC
        }, Symbol.toStringTag, {
          value: "Module"
        }));
      function sO(n = 0) {
        return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(n) : new Uint8Array(n);
      }
      function Nv(n, e, t, r) {
        return {
          name: n,
          prefix: e,
          encoder: {
            name: n,
            prefix: e,
            encode: t
          },
          decoder: {
            decode: r
          }
        };
      }
      const Sv = Nv("utf8", "u", n => "u" + new TextDecoder("utf8").decode(n), n => new TextEncoder().encode(n.substring(1))),
        ld = Nv("ascii", "a", n => {
          let e = "a";
          for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
          return e;
        }, n => {
          n = n.substring(1);
          const e = sO(n.length);
          for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
          return e;
        }),
        aO = {
          utf8: Sv,
          "utf-8": Sv,
          hex: cd.base16,
          latin1: ld,
          ascii: ld,
          binary: ld,
          ...cd
        };
      function cO(n, e = "utf8") {
        const t = aO[e];
        if (!t) throw new Error(`Unsupported encoding "${e}"`);
        return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1);
      }
      const lO = $0(Object.freeze(Object.defineProperty({
        __proto__: null,
        toString: cO
      }, Symbol.toStringTag, {
        value: "Module"
      })));
      var ud = {},
        dt = {},
        fd = {},
        Tv;
      function uO() {
        return Tv || (Tv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          function e(s, o) {
            var c = s >>> 16 & 65535,
              u = s & 65535,
              f = o >>> 16 & 65535,
              d = o & 65535;
            return u * d + (c * d + u * f << 16 >>> 0) | 0;
          }
          n.mul = Math.imul || e;
          function t(s, o) {
            return s + o | 0;
          }
          n.add = t;
          function r(s, o) {
            return s - o | 0;
          }
          n.sub = r;
          function i(s, o) {
            return s << o | s >>> 32 - o;
          }
          n.rotl = i;
          function a(s, o) {
            return s << 32 - o | s >>> o;
          }
          n.rotr = a;
          function l(s) {
            return typeof s == "number" && isFinite(s) && Math.floor(s) === s;
          }
          n.isInteger = Number.isInteger || l, n.MAX_SAFE_INTEGER = 9007199254740991, n.isSafeInteger = function (s) {
            return n.isInteger(s) && s >= -n.MAX_SAFE_INTEGER && s <= n.MAX_SAFE_INTEGER;
          };
        }(fd)), fd;
      }
      var Dv;
      function dd() {
        if (Dv) return dt;
        Dv = 1, Object.defineProperty(dt, "__esModule", {
          value: !0
        });
        var n = uO();
        function e(x, C) {
          return C === void 0 && (C = 0), (x[C + 0] << 8 | x[C + 1]) << 16 >> 16;
        }
        dt.readInt16BE = e;
        function t(x, C) {
          return C === void 0 && (C = 0), (x[C + 0] << 8 | x[C + 1]) >>> 0;
        }
        dt.readUint16BE = t;
        function r(x, C) {
          return C === void 0 && (C = 0), (x[C + 1] << 8 | x[C]) << 16 >> 16;
        }
        dt.readInt16LE = r;
        function i(x, C) {
          return C === void 0 && (C = 0), (x[C + 1] << 8 | x[C]) >>> 0;
        }
        dt.readUint16LE = i;
        function a(x, C, B) {
          return C === void 0 && (C = new Uint8Array(2)), B === void 0 && (B = 0), C[B + 0] = x >>> 8, C[B + 1] = x >>> 0, C;
        }
        dt.writeUint16BE = a, dt.writeInt16BE = a;
        function l(x, C, B) {
          return C === void 0 && (C = new Uint8Array(2)), B === void 0 && (B = 0), C[B + 0] = x >>> 0, C[B + 1] = x >>> 8, C;
        }
        dt.writeUint16LE = l, dt.writeInt16LE = l;
        function s(x, C) {
          return C === void 0 && (C = 0), x[C] << 24 | x[C + 1] << 16 | x[C + 2] << 8 | x[C + 3];
        }
        dt.readInt32BE = s;
        function o(x, C) {
          return C === void 0 && (C = 0), (x[C] << 24 | x[C + 1] << 16 | x[C + 2] << 8 | x[C + 3]) >>> 0;
        }
        dt.readUint32BE = o;
        function c(x, C) {
          return C === void 0 && (C = 0), x[C + 3] << 24 | x[C + 2] << 16 | x[C + 1] << 8 | x[C];
        }
        dt.readInt32LE = c;
        function u(x, C) {
          return C === void 0 && (C = 0), (x[C + 3] << 24 | x[C + 2] << 16 | x[C + 1] << 8 | x[C]) >>> 0;
        }
        dt.readUint32LE = u;
        function f(x, C, B) {
          return C === void 0 && (C = new Uint8Array(4)), B === void 0 && (B = 0), C[B + 0] = x >>> 24, C[B + 1] = x >>> 16, C[B + 2] = x >>> 8, C[B + 3] = x >>> 0, C;
        }
        dt.writeUint32BE = f, dt.writeInt32BE = f;
        function d(x, C, B) {
          return C === void 0 && (C = new Uint8Array(4)), B === void 0 && (B = 0), C[B + 0] = x >>> 0, C[B + 1] = x >>> 8, C[B + 2] = x >>> 16, C[B + 3] = x >>> 24, C;
        }
        dt.writeUint32LE = d, dt.writeInt32LE = d;
        function p(x, C) {
          C === void 0 && (C = 0);
          var B = s(x, C),
            X = s(x, C + 4);
          return B * 4294967296 + X - (X >> 31) * 4294967296;
        }
        dt.readInt64BE = p;
        function v(x, C) {
          C === void 0 && (C = 0);
          var B = o(x, C),
            X = o(x, C + 4);
          return B * 4294967296 + X;
        }
        dt.readUint64BE = v;
        function h(x, C) {
          C === void 0 && (C = 0);
          var B = c(x, C),
            X = c(x, C + 4);
          return X * 4294967296 + B - (B >> 31) * 4294967296;
        }
        dt.readInt64LE = h;
        function g(x, C) {
          C === void 0 && (C = 0);
          var B = u(x, C),
            X = u(x, C + 4);
          return X * 4294967296 + B;
        }
        dt.readUint64LE = g;
        function b(x, C, B) {
          return C === void 0 && (C = new Uint8Array(8)), B === void 0 && (B = 0), f(x / 4294967296 >>> 0, C, B), f(x >>> 0, C, B + 4), C;
        }
        dt.writeUint64BE = b, dt.writeInt64BE = b;
        function m(x, C, B) {
          return C === void 0 && (C = new Uint8Array(8)), B === void 0 && (B = 0), d(x >>> 0, C, B), d(x / 4294967296 >>> 0, C, B + 4), C;
        }
        dt.writeUint64LE = m, dt.writeInt64LE = m;
        function _(x, C, B) {
          if (B === void 0 && (B = 0), x % 8 !== 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
          if (x / 8 > C.length - B) throw new Error("readUintBE: array is too short for the given bitLength");
          for (var X = 0, J = 1, V = x / 8 + B - 1; V >= B; V--) X += C[V] * J, J *= 256;
          return X;
        }
        dt.readUintBE = _;
        function N(x, C, B) {
          if (B === void 0 && (B = 0), x % 8 !== 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
          if (x / 8 > C.length - B) throw new Error("readUintLE: array is too short for the given bitLength");
          for (var X = 0, J = 1, V = B; V < B + x / 8; V++) X += C[V] * J, J *= 256;
          return X;
        }
        dt.readUintLE = N;
        function O(x, C, B, X) {
          if (B === void 0 && (B = new Uint8Array(x / 8)), X === void 0 && (X = 0), x % 8 !== 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
          if (!n.isSafeInteger(C)) throw new Error("writeUintBE value must be an integer");
          for (var J = 1, V = x / 8 + X - 1; V >= X; V--) B[V] = C / J & 255, J *= 256;
          return B;
        }
        dt.writeUintBE = O;
        function y(x, C, B, X) {
          if (B === void 0 && (B = new Uint8Array(x / 8)), X === void 0 && (X = 0), x % 8 !== 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
          if (!n.isSafeInteger(C)) throw new Error("writeUintLE value must be an integer");
          for (var J = 1, V = X; V < X + x / 8; V++) B[V] = C / J & 255, J *= 256;
          return B;
        }
        dt.writeUintLE = y;
        function w(x, C) {
          C === void 0 && (C = 0);
          var B = new DataView(x.buffer, x.byteOffset, x.byteLength);
          return B.getFloat32(C);
        }
        dt.readFloat32BE = w;
        function A(x, C) {
          C === void 0 && (C = 0);
          var B = new DataView(x.buffer, x.byteOffset, x.byteLength);
          return B.getFloat32(C, !0);
        }
        dt.readFloat32LE = A;
        function R(x, C) {
          C === void 0 && (C = 0);
          var B = new DataView(x.buffer, x.byteOffset, x.byteLength);
          return B.getFloat64(C);
        }
        dt.readFloat64BE = R;
        function T(x, C) {
          C === void 0 && (C = 0);
          var B = new DataView(x.buffer, x.byteOffset, x.byteLength);
          return B.getFloat64(C, !0);
        }
        dt.readFloat64LE = T;
        function D(x, C, B) {
          C === void 0 && (C = new Uint8Array(4)), B === void 0 && (B = 0);
          var X = new DataView(C.buffer, C.byteOffset, C.byteLength);
          return X.setFloat32(B, x), C;
        }
        dt.writeFloat32BE = D;
        function M(x, C, B) {
          C === void 0 && (C = new Uint8Array(4)), B === void 0 && (B = 0);
          var X = new DataView(C.buffer, C.byteOffset, C.byteLength);
          return X.setFloat32(B, x, !0), C;
        }
        dt.writeFloat32LE = M;
        function q(x, C, B) {
          C === void 0 && (C = new Uint8Array(8)), B === void 0 && (B = 0);
          var X = new DataView(C.buffer, C.byteOffset, C.byteLength);
          return X.setFloat64(B, x), C;
        }
        dt.writeFloat64BE = q;
        function W(x, C, B) {
          C === void 0 && (C = new Uint8Array(8)), B === void 0 && (B = 0);
          var X = new DataView(C.buffer, C.byteOffset, C.byteLength);
          return X.setFloat64(B, x, !0), C;
        }
        return dt.writeFloat64LE = W, dt;
      }
      var Tu = {},
        Pv;
      function il() {
        if (Pv) return Tu;
        Pv = 1, Object.defineProperty(Tu, "__esModule", {
          value: !0
        });
        function n(e) {
          for (var t = 0; t < e.length; t++) e[t] = 0;
          return e;
        }
        return Tu.wipe = n, Tu;
      }
      var Iv;
      function fO() {
        return Iv || (Iv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          var e = dd(),
            t = il();
          n.DIGEST_LENGTH = 32, n.BLOCK_SIZE = 64;
          var r = function () {
            function s() {
              this.digestLength = n.DIGEST_LENGTH, this.blockSize = n.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
            }
            return s.prototype._initState = function () {
              this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
            }, s.prototype.reset = function () {
              return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
            }, s.prototype.clean = function () {
              t.wipe(this._buffer), t.wipe(this._temp), this.reset();
            }, s.prototype.update = function (o, c) {
              if (c === void 0 && (c = o.length), this._finished) throw new Error("SHA256: can't update because hash was finished.");
              var u = 0;
              if (this._bytesHashed += c, this._bufferLength > 0) {
                for (; this._bufferLength < this.blockSize && c > 0;) this._buffer[this._bufferLength++] = o[u++], c--;
                this._bufferLength === this.blockSize && (a(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
              }
              for (c >= this.blockSize && (u = a(this._temp, this._state, o, u, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = o[u++], c--;
              return this;
            }, s.prototype.finish = function (o) {
              if (!this._finished) {
                var c = this._bytesHashed,
                  u = this._bufferLength,
                  f = c / 536870912 | 0,
                  d = c << 3,
                  p = c % 64 < 56 ? 64 : 128;
                this._buffer[u] = 128;
                for (var v = u + 1; v < p - 8; v++) this._buffer[v] = 0;
                e.writeUint32BE(f, this._buffer, p - 8), e.writeUint32BE(d, this._buffer, p - 4), a(this._temp, this._state, this._buffer, 0, p), this._finished = !0;
              }
              for (var v = 0; v < this.digestLength / 4; v++) e.writeUint32BE(this._state[v], o, v * 4);
              return this;
            }, s.prototype.digest = function () {
              var o = new Uint8Array(this.digestLength);
              return this.finish(o), o;
            }, s.prototype.saveState = function () {
              if (this._finished) throw new Error("SHA256: cannot save finished state");
              return {
                state: new Int32Array(this._state),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
              };
            }, s.prototype.restoreState = function (o) {
              return this._state.set(o.state), this._bufferLength = o.bufferLength, o.buffer && this._buffer.set(o.buffer), this._bytesHashed = o.bytesHashed, this._finished = !1, this;
            }, s.prototype.cleanSavedState = function (o) {
              t.wipe(o.state), o.buffer && t.wipe(o.buffer), o.bufferLength = 0, o.bytesHashed = 0;
            }, s;
          }();
          n.SHA256 = r;
          var i = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
          function a(s, o, c, u, f) {
            for (; f >= 64;) {
              for (var d = o[0], p = o[1], v = o[2], h = o[3], g = o[4], b = o[5], m = o[6], _ = o[7], N = 0; N < 16; N++) {
                var O = u + N * 4;
                s[N] = e.readUint32BE(c, O);
              }
              for (var N = 16; N < 64; N++) {
                var y = s[N - 2],
                  w = (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10;
                y = s[N - 15];
                var A = (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3;
                s[N] = (w + s[N - 7] | 0) + (A + s[N - 16] | 0);
              }
              for (var N = 0; N < 64; N++) {
                var w = (((g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & b ^ ~g & m) | 0) + (_ + (i[N] + s[N] | 0) | 0) | 0,
                  A = ((d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10)) + (d & p ^ d & v ^ p & v) | 0;
                _ = m, m = b, b = g, g = h + w | 0, h = v, v = p, p = d, d = w + A | 0;
              }
              o[0] += d, o[1] += p, o[2] += v, o[3] += h, o[4] += g, o[5] += b, o[6] += m, o[7] += _, u += 64, f -= 64;
            }
            return u;
          }
          function l(s) {
            var o = new r();
            o.update(s);
            var c = o.digest();
            return o.clean(), c;
          }
          n.hash = l;
        }(ud)), ud;
      }
      var ol = {},
        rr = {},
        qo = {},
        Du = {
          exports: {}
        },
        Bv;
      function dO() {
        return Bv || (Bv = 1, function (n, e) {
          var t = typeof globalThis != "undefined" && globalThis || typeof self != "undefined" && self || typeof qt != "undefined" && qt,
            r = function () {
              function a() {
                this.fetch = !1, this.DOMException = t.DOMException;
              }
              return a.prototype = t, new a();
            }();
          (function (a) {
            (function (l) {
              var s = typeof a != "undefined" && a || typeof self != "undefined" && self || typeof qt != "undefined" && qt || {},
                o = {
                  searchParams: "URLSearchParams" in s,
                  iterable: "Symbol" in s && "iterator" in Symbol,
                  blob: "FileReader" in s && "Blob" in s && function () {
                    try {
                      return new Blob(), !0;
                    } catch {
                      return !1;
                    }
                  }(),
                  formData: "FormData" in s,
                  arrayBuffer: "ArrayBuffer" in s
                };
              function c(x) {
                return x && DataView.prototype.isPrototypeOf(x);
              }
              if (o.arrayBuffer) var u = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                f = ArrayBuffer.isView || function (x) {
                  return x && u.indexOf(Object.prototype.toString.call(x)) > -1;
                };
              function d(x) {
                if (typeof x != "string" && (x = String(x)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(x) || x === "") throw new TypeError('Invalid character in header field name: "' + x + '"');
                return x.toLowerCase();
              }
              function p(x) {
                return typeof x != "string" && (x = String(x)), x;
              }
              function v(x) {
                var C = {
                  next: function () {
                    var B = x.shift();
                    return {
                      done: B === void 0,
                      value: B
                    };
                  }
                };
                return o.iterable && (C[Symbol.iterator] = function () {
                  return C;
                }), C;
              }
              function h(x) {
                this.map = {}, x instanceof h ? x.forEach(function (C, B) {
                  this.append(B, C);
                }, this) : Array.isArray(x) ? x.forEach(function (C) {
                  if (C.length != 2) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + C.length);
                  this.append(C[0], C[1]);
                }, this) : x && Object.getOwnPropertyNames(x).forEach(function (C) {
                  this.append(C, x[C]);
                }, this);
              }
              h.prototype.append = function (x, C) {
                x = d(x), C = p(C);
                var B = this.map[x];
                this.map[x] = B ? B + ", " + C : C;
              }, h.prototype.delete = function (x) {
                delete this.map[d(x)];
              }, h.prototype.get = function (x) {
                return x = d(x), this.has(x) ? this.map[x] : null;
              }, h.prototype.has = function (x) {
                return this.map.hasOwnProperty(d(x));
              }, h.prototype.set = function (x, C) {
                this.map[d(x)] = p(C);
              }, h.prototype.forEach = function (x, C) {
                for (var B in this.map) this.map.hasOwnProperty(B) && x.call(C, this.map[B], B, this);
              }, h.prototype.keys = function () {
                var x = [];
                return this.forEach(function (C, B) {
                  x.push(B);
                }), v(x);
              }, h.prototype.values = function () {
                var x = [];
                return this.forEach(function (C) {
                  x.push(C);
                }), v(x);
              }, h.prototype.entries = function () {
                var x = [];
                return this.forEach(function (C, B) {
                  x.push([B, C]);
                }), v(x);
              }, o.iterable && (h.prototype[Symbol.iterator] = h.prototype.entries);
              function g(x) {
                if (!x._noBody) {
                  if (x.bodyUsed) return Promise.reject(new TypeError("Already read"));
                  x.bodyUsed = !0;
                }
              }
              function b(x) {
                return new Promise(function (C, B) {
                  x.onload = function () {
                    C(x.result);
                  }, x.onerror = function () {
                    B(x.error);
                  };
                });
              }
              function m(x) {
                var C = new FileReader(),
                  B = b(C);
                return C.readAsArrayBuffer(x), B;
              }
              function _(x) {
                var C = new FileReader(),
                  B = b(C),
                  X = /charset=([A-Za-z0-9_-]+)/.exec(x.type),
                  J = X ? X[1] : "utf-8";
                return C.readAsText(x, J), B;
              }
              function N(x) {
                for (var C = new Uint8Array(x), B = new Array(C.length), X = 0; X < C.length; X++) B[X] = String.fromCharCode(C[X]);
                return B.join("");
              }
              function O(x) {
                if (x.slice) return x.slice(0);
                var C = new Uint8Array(x.byteLength);
                return C.set(new Uint8Array(x)), C.buffer;
              }
              function y() {
                return this.bodyUsed = !1, this._initBody = function (x) {
                  this.bodyUsed = this.bodyUsed, this._bodyInit = x, x ? typeof x == "string" ? this._bodyText = x : o.blob && Blob.prototype.isPrototypeOf(x) ? this._bodyBlob = x : o.formData && FormData.prototype.isPrototypeOf(x) ? this._bodyFormData = x : o.searchParams && URLSearchParams.prototype.isPrototypeOf(x) ? this._bodyText = x.toString() : o.arrayBuffer && o.blob && c(x) ? (this._bodyArrayBuffer = O(x.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(x) || f(x)) ? this._bodyArrayBuffer = O(x) : this._bodyText = x = Object.prototype.toString.call(x) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof x == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o.searchParams && URLSearchParams.prototype.isPrototypeOf(x) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
                }, o.blob && (this.blob = function () {
                  var x = g(this);
                  if (x) return x;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                  return Promise.resolve(new Blob([this._bodyText]));
                }), this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var x = g(this);
                    return x || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer));
                  } else {
                    if (o.blob) return this.blob().then(m);
                    throw new Error("could not read as ArrayBuffer");
                  }
                }, this.text = function () {
                  var x = g(this);
                  if (x) return x;
                  if (this._bodyBlob) return _(this._bodyBlob);
                  if (this._bodyArrayBuffer) return Promise.resolve(N(this._bodyArrayBuffer));
                  if (this._bodyFormData) throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }, o.formData && (this.formData = function () {
                  return this.text().then(T);
                }), this.json = function () {
                  return this.text().then(JSON.parse);
                }, this;
              }
              var w = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
              function A(x) {
                var C = x.toUpperCase();
                return w.indexOf(C) > -1 ? C : x;
              }
              function R(x, C) {
                if (!(this instanceof R)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                C = C || {};
                var B = C.body;
                if (x instanceof R) {
                  if (x.bodyUsed) throw new TypeError("Already read");
                  this.url = x.url, this.credentials = x.credentials, C.headers || (this.headers = new h(x.headers)), this.method = x.method, this.mode = x.mode, this.signal = x.signal, !B && x._bodyInit != null && (B = x._bodyInit, x.bodyUsed = !0);
                } else this.url = String(x);
                if (this.credentials = C.credentials || this.credentials || "same-origin", (C.headers || !this.headers) && (this.headers = new h(C.headers)), this.method = A(C.method || this.method || "GET"), this.mode = C.mode || this.mode || null, this.signal = C.signal || this.signal || function () {
                  if ("AbortController" in s) {
                    var V = new AbortController();
                    return V.signal;
                  }
                }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && B) throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(B), (this.method === "GET" || this.method === "HEAD") && (C.cache === "no-store" || C.cache === "no-cache")) {
                  var X = /([?&])_=[^&]*/;
                  if (X.test(this.url)) this.url = this.url.replace(X, "$1_=" + new Date().getTime());else {
                    var J = /\?/;
                    this.url += (J.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
                  }
                }
              }
              R.prototype.clone = function () {
                return new R(this, {
                  body: this._bodyInit
                });
              };
              function T(x) {
                var C = new FormData();
                return x.trim().split("&").forEach(function (B) {
                  if (B) {
                    var X = B.split("="),
                      J = X.shift().replace(/\+/g, " "),
                      V = X.join("=").replace(/\+/g, " ");
                    C.append(decodeURIComponent(J), decodeURIComponent(V));
                  }
                }), C;
              }
              function D(x) {
                var C = new h(),
                  B = x.replace(/\r?\n[\t ]+/g, " ");
                return B.split("\r").map(function (X) {
                  return X.indexOf(`
`) === 0 ? X.substr(1, X.length) : X;
                }).forEach(function (X) {
                  var J = X.split(":"),
                    V = J.shift().trim();
                  if (V) {
                    var $ = J.join(":").trim();
                    try {
                      C.append(V, $);
                    } catch (se) {
                      console.warn("Response " + se.message);
                    }
                  }
                }), C;
              }
              y.call(R.prototype);
              function M(x, C) {
                if (!(this instanceof M)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                if (C || (C = {}), this.type = "default", this.status = C.status === void 0 ? 200 : C.status, this.status < 200 || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                this.ok = this.status >= 200 && this.status < 300, this.statusText = C.statusText === void 0 ? "" : "" + C.statusText, this.headers = new h(C.headers), this.url = C.url || "", this._initBody(x);
              }
              y.call(M.prototype), M.prototype.clone = function () {
                return new M(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new h(this.headers),
                  url: this.url
                });
              }, M.error = function () {
                var x = new M(null, {
                  status: 200,
                  statusText: ""
                });
                return x.ok = !1, x.status = 0, x.type = "error", x;
              };
              var q = [301, 302, 303, 307, 308];
              M.redirect = function (x, C) {
                if (q.indexOf(C) === -1) throw new RangeError("Invalid status code");
                return new M(null, {
                  status: C,
                  headers: {
                    location: x
                  }
                });
              }, l.DOMException = s.DOMException;
              try {
                new l.DOMException();
              } catch {
                l.DOMException = function (C, B) {
                  this.message = C, this.name = B;
                  var X = Error(C);
                  this.stack = X.stack;
                }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException;
              }
              function W(x, C) {
                return new Promise(function (B, X) {
                  var J = new R(x, C);
                  if (J.signal && J.signal.aborted) return X(new l.DOMException("Aborted", "AbortError"));
                  var V = new XMLHttpRequest();
                  function $() {
                    V.abort();
                  }
                  V.onload = function () {
                    var oe = {
                      statusText: V.statusText,
                      headers: D(V.getAllResponseHeaders() || "")
                    };
                    J.url.indexOf("file://") === 0 && (V.status < 200 || V.status > 599) ? oe.status = 200 : oe.status = V.status, oe.url = "responseURL" in V ? V.responseURL : oe.headers.get("X-Request-URL");
                    var ye = "response" in V ? V.response : V.responseText;
                    setTimeout(function () {
                      B(new M(ye, oe));
                    }, 0);
                  }, V.onerror = function () {
                    setTimeout(function () {
                      X(new TypeError("Network request failed"));
                    }, 0);
                  }, V.ontimeout = function () {
                    setTimeout(function () {
                      X(new TypeError("Network request timed out"));
                    }, 0);
                  }, V.onabort = function () {
                    setTimeout(function () {
                      X(new l.DOMException("Aborted", "AbortError"));
                    }, 0);
                  };
                  function se(oe) {
                    try {
                      return oe === "" && s.location.href ? s.location.href : oe;
                    } catch {
                      return oe;
                    }
                  }
                  if (V.open(J.method, se(J.url), !0), J.credentials === "include" ? V.withCredentials = !0 : J.credentials === "omit" && (V.withCredentials = !1), "responseType" in V && (o.blob ? V.responseType = "blob" : o.arrayBuffer && (V.responseType = "arraybuffer")), C && typeof C.headers == "object" && !(C.headers instanceof h || s.Headers && C.headers instanceof s.Headers)) {
                    var ne = [];
                    Object.getOwnPropertyNames(C.headers).forEach(function (oe) {
                      ne.push(d(oe)), V.setRequestHeader(oe, p(C.headers[oe]));
                    }), J.headers.forEach(function (oe, ye) {
                      ne.indexOf(ye) === -1 && V.setRequestHeader(ye, oe);
                    });
                  } else J.headers.forEach(function (oe, ye) {
                    V.setRequestHeader(ye, oe);
                  });
                  J.signal && (J.signal.addEventListener("abort", $), V.onreadystatechange = function () {
                    V.readyState === 4 && J.signal.removeEventListener("abort", $);
                  }), V.send(typeof J._bodyInit == "undefined" ? null : J._bodyInit);
                });
              }
              return W.polyfill = !0, s.fetch || (s.fetch = W, s.Headers = h, s.Request = R, s.Response = M), l.Headers = h, l.Request = R, l.Response = M, l.fetch = W, l;
            })({});
          })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
          var i = t.fetch ? t : r;
          e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, n.exports = e;
        }(Du, Du.exports)), Du.exports;
      }
      var vn = {},
        Jo = {},
        hd = {},
        pd = {},
        kv;
      function Mv() {
        return kv || (kv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.DEFAULT_ERROR = n.STANDARD_ERROR_MAP = n.SERVER_ERROR_CODE_RANGE = n.RESERVED_ERROR_CODES = n.SERVER_ERROR = n.INTERNAL_ERROR = n.INVALID_PARAMS = n.METHOD_NOT_FOUND = n.INVALID_REQUEST = n.PARSE_ERROR = n.OKX_CONNECT_ERROR_CODES = n.OKXConnectError = void 0;
          class e extends Error {
            constructor(a, l) {
              l == null && (l = t(a)), super(l), this.code = a, this.message = `${e.prefix} ${l ? `
` + l : ""}`, Object.setPrototypeOf(this, e.prototype);
            }
            toJSON() {
              return {
                message: this.message,
                code: this.code
              };
            }
          }
          n.OKXConnectError = e, e.prefix = "[OKX_CONNECT_SDK_ERROR]";
          function t(i) {
            return i == r.UNKNOWN_ERROR ? "unknown error" : i == r.BAD_REQUEST_ERROR ? "bad request error" : i == r.ALREADY_CONNECTED_ERROR ? "already connected error" : i == r.NOT_CONNECTED_ERROR ? "not connected error" : i == r.UNKNOWN_APP_ERROR ? "unknown app error" : i == r.USER_REJECTS_ERROR ? "user rejects error" : i == r.USER_REJECTS_ERROR_CAUSE_REGISTER ? "wallet address are registering" : i == r.METHOD_NOT_SUPPORTED ? "method not supported" : i == r.CONNECTION_ERROR ? "connect error" : i == r.CHAIN_NOT_SUPPORTED ? "chain not supported" : "unknown error";
          }
          var r;
          (function (i) {
            i[i.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", i[i.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", i[i.ALREADY_CONNECTED_ERROR = 11] = "ALREADY_CONNECTED_ERROR", i[i.NOT_CONNECTED_ERROR = 12] = "NOT_CONNECTED_ERROR", i[i.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", i[i.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", i[i.USER_REJECTS_ERROR_CAUSE_REGISTER = 301] = "USER_REJECTS_ERROR_CAUSE_REGISTER", i[i.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED", i[i.CHAIN_NOT_SUPPORTED = 500] = "CHAIN_NOT_SUPPORTED", i[i.WALLET_NOT_SUPPORTED = 600] = "WALLET_NOT_SUPPORTED", i[i.CONNECTION_ERROR = 700] = "CONNECTION_ERROR";
          })(r || (n.OKX_CONNECT_ERROR_CODES = r = {})), n.PARSE_ERROR = "PARSE_ERROR", n.INVALID_REQUEST = "INVALID_REQUEST", n.METHOD_NOT_FOUND = "METHOD_NOT_FOUND", n.INVALID_PARAMS = "INVALID_PARAMS", n.INTERNAL_ERROR = "INTERNAL_ERROR", n.SERVER_ERROR = "SERVER_ERROR", n.RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603], n.SERVER_ERROR_CODE_RANGE = [-32e3, -32099], n.STANDARD_ERROR_MAP = {
            [n.PARSE_ERROR]: {
              code: -32700,
              message: "Parse error"
            },
            [n.INVALID_REQUEST]: {
              code: -32600,
              message: "Invalid Request"
            },
            [n.METHOD_NOT_FOUND]: {
              code: -32601,
              message: "Method not found"
            },
            [n.INVALID_PARAMS]: {
              code: -32602,
              message: "Invalid params"
            },
            [n.INTERNAL_ERROR]: {
              code: -32603,
              message: "Internal error"
            },
            [n.SERVER_ERROR]: {
              code: -32e3,
              message: "Server error"
            }
          }, n.DEFAULT_ERROR = n.SERVER_ERROR;
        }(pd)), pd;
      }
      var Kv;
      function hO() {
        return Kv || (Kv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.OKX_CONNECT_ERROR_CODES = n.OKXConnectError = void 0;
          var e = Mv();
          Object.defineProperty(n, "OKXConnectError", {
            enumerable: !0,
            get: function () {
              return e.OKXConnectError;
            }
          }), Object.defineProperty(n, "OKX_CONNECT_ERROR_CODES", {
            enumerable: !0,
            get: function () {
              return e.OKX_CONNECT_ERROR_CODES;
            }
          });
        }(hd)), hd;
      }
      var en = {},
        Lv;
      function Uv() {
        if (Lv) return en;
        Lv = 1, Object.defineProperty(en, "__esModule", {
          value: !0
        }), en.NameSpaceKeyStarknet = en.NameSpaceKeyTron = en.NameSpaceKeyCosmos = en.NameSpaceKeyAptos = en.NameSpaceKeyBtc = en.NameSpaceKeySui = en.NameSpaceKeyTON = en.NameSpaceKeySOL = en.NameSpaceKeyEip155 = en.OpenAppLinkType = void 0;
        var n;
        return function (e) {
          e.UniversalLink = "universallink", e.DeepLink = "deeplink";
        }(n || (en.OpenAppLinkType = n = {})), en.NameSpaceKeyEip155 = "eip155", en.NameSpaceKeySOL = "solana", en.NameSpaceKeyTON = "ton", en.NameSpaceKeySui = "sui", en.NameSpaceKeyBtc = "btc", en.NameSpaceKeyAptos = "aptos", en.NameSpaceKeyCosmos = "cosmos", en.NameSpaceKeyTron = "tron", en.NameSpaceKeyStarknet = "starknet", en;
      }
      var gd = {},
        Fv;
      function vd() {
        return Fv || (Fv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.OKX_MINI_WALLET_NAME = n.OKX_APP_WALLET_NAME = n.stackDeepLink = n.tgwalletAppName = n.tgwalletName = n.tonConnectSdkVersion = n.standardDeeplink = n.downloadUrl = n.shortUniversalLink = n.standardUniversalLink = n.okxDeeplink = void 0, n.getTestTwaUrl = e, n.getTestTgTwaUrl = t, n.getBotNameAndAppName = r, n.okxDeeplink = "okx://web3", n.standardUniversalLink = typeof window != "undefined" && window.location.hostname.includes("okx.com") ? "https://link.okx.com/download" : "https://www.okx.com/download", n.shortUniversalLink = typeof window != "undefined" && window.location.hostname.includes("okx.com") ? "https://link.okx.com/ul/connect" : "https://www.okx.com/ul/connect", n.downloadUrl = "https://www.okx.com/download", n.standardDeeplink = `${n.okxDeeplink}/wallet/connect`, n.tonConnectSdkVersion = "1", n.tgwalletName = "OKX_WALLET_BOT", n.tgwalletAppName = "start", n.stackDeepLink = "okx://web3?stack=true";
          function e() {
            return window.okxTesttwaUrl;
          }
          function t() {
            return window.okxTestTgtwaUrl;
          }
          function r(i) {
            const l = new URL(i).pathname.split("/").filter(Boolean);
            if (l.length >= 2) {
              const s = l[0],
                o = l[1];
              return {
                botName: s,
                appName: o
              };
            }
          }
          n.OKX_APP_WALLET_NAME = "OKX Wallet", n.OKX_MINI_WALLET_NAME = "OKX Mini Wallet";
        }(gd)), gd;
      }
      var Go = {},
        cn = {},
        Hv;
      function pO() {
        if (Hv) return cn;
        Hv = 1;
        var n = cn && cn.__importDefault || function (R) {
          return R && R.__esModule ? R : {
            default: R
          };
        };
        Object.defineProperty(cn, "__esModule", {
          value: !0
        }), cn.isJsonRpcPayload = e, cn.isJsonRpcRequest = t, cn.isJsonRpcResponse = r, cn.isJsonRpcResult = i, cn.isJsonRpcError = a, cn.payloadId = f, cn.getBigIntRpcId = d, cn.formatJsonRpcRequest = p, cn.formatJsonRpcResult = v, cn.formatJsonRpcError = h, cn.isReservedErrorCode = g, cn.getError = b, cn.getErrorByCode = m, cn.formatErrorMessage = _, cn.isHttpUrl = y, cn.isWsUrl = w, cn.parseConnectionError = A;
        function e(R) {
          return typeof R == "object" && "id" in R && "jsonrpc" in R && R.jsonrpc === "2.0";
        }
        function t(R) {
          return e(R) && "method" in R;
        }
        function r(R) {
          return e(R) && (i(R) || a(R));
        }
        function i(R) {
          return "result" in R;
        }
        function a(R) {
          return "error" in R;
        }
        const l = Mv(),
          s = n(Qc());
        class o {
          constructor(T) {
            this.i = 1, T ? this.initialValue = s.default.randomBytes(T / 8)[0] : this.initialValue = 0;
          }
          getNextValue() {
            return this.initialValue + this.i++;
          }
        }
        const c = new o(8),
          u = new o(16);
        function f() {
          const R = Date.now() * 1e3,
            T = c.getNextValue();
          return R + T;
        }
        function d() {
          const R = BigInt(Date.now()) * BigInt(1e6),
            T = BigInt(u.getNextValue());
          return R + T;
        }
        function p(R, T, D) {
          return {
            id: D || f(),
            jsonrpc: "2.0",
            method: R,
            params: T
          };
        }
        function v(R, T) {
          return {
            id: R,
            jsonrpc: "2.0",
            result: T
          };
        }
        function h(R, T, D) {
          return {
            id: R,
            jsonrpc: "2.0",
            error: _(T, D)
          };
        }
        function g(R) {
          return l.RESERVED_ERROR_CODES.includes(R);
        }
        function b(R) {
          return Object.keys(l.STANDARD_ERROR_MAP).includes(R) ? l.STANDARD_ERROR_MAP[R] : l.STANDARD_ERROR_MAP[l.DEFAULT_ERROR];
        }
        function m(R) {
          const T = Object.values(l.STANDARD_ERROR_MAP).find(D => D.code === R);
          return T || l.STANDARD_ERROR_MAP[l.DEFAULT_ERROR];
        }
        function _(R, T) {
          return typeof R == "undefined" ? b(l.INTERNAL_ERROR) : (typeof R == "string" && (R = Object.assign(Object.assign({}, b(l.SERVER_ERROR)), {
            message: R
          })), typeof T != "undefined" && (R.data = T), g(R.code) && (R = m(R.code)), R);
        }
        function N(R) {
          const T = R.match(new RegExp(/^\w+:/, "gi"));
          if (!(!T || !T.length)) return T[0];
        }
        function O(R, T) {
          const D = N(R);
          return typeof D == "undefined" ? !1 : new RegExp(T).test(D);
        }
        function y(R) {
          return O(R, "^https?:");
        }
        function w(R) {
          return O(R, "^wss?:");
        }
        function A(R, T, D) {
          return R.message.includes("getaddrinfo ENOTFOUND") || R.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${D} RPC url at ${T}`) : R;
        }
        return cn;
      }
      var ir = {},
        yd = {
          exports: {}
        },
        jv;
      function Wi() {
        return jv || (jv = 1, function (n) {
          var e = Object.prototype.hasOwnProperty,
            t = "~";
          function r() {}
          Object.create && (r.prototype = Object.create(null), new r().__proto__ || (t = !1));
          function i(o, c, u) {
            this.fn = o, this.context = c, this.once = u || !1;
          }
          function a(o, c, u, f, d) {
            if (typeof u != "function") throw new TypeError("The listener must be a function");
            var p = new i(u, f || o, d),
              v = t ? t + c : c;
            return o._events[v] ? o._events[v].fn ? o._events[v] = [o._events[v], p] : o._events[v].push(p) : (o._events[v] = p, o._eventsCount++), o;
          }
          function l(o, c) {
            --o._eventsCount === 0 ? o._events = new r() : delete o._events[c];
          }
          function s() {
            this._events = new r(), this._eventsCount = 0;
          }
          s.prototype.eventNames = function () {
            var c = [],
              u,
              f;
            if (this._eventsCount === 0) return c;
            for (f in u = this._events) e.call(u, f) && c.push(t ? f.slice(1) : f);
            return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;
          }, s.prototype.listeners = function (c) {
            var u = t ? t + c : c,
              f = this._events[u];
            if (!f) return [];
            if (f.fn) return [f.fn];
            for (var d = 0, p = f.length, v = new Array(p); d < p; d++) v[d] = f[d].fn;
            return v;
          }, s.prototype.listenerCount = function (c) {
            var u = t ? t + c : c,
              f = this._events[u];
            return f ? f.fn ? 1 : f.length : 0;
          }, s.prototype.emit = function (c, u, f, d, p, v) {
            var h = t ? t + c : c;
            if (!this._events[h]) return !1;
            var g = this._events[h],
              b = arguments.length,
              m,
              _;
            if (g.fn) {
              switch (g.once && this.removeListener(c, g.fn, void 0, !0), b) {
                case 1:
                  return g.fn.call(g.context), !0;
                case 2:
                  return g.fn.call(g.context, u), !0;
                case 3:
                  return g.fn.call(g.context, u, f), !0;
                case 4:
                  return g.fn.call(g.context, u, f, d), !0;
                case 5:
                  return g.fn.call(g.context, u, f, d, p), !0;
                case 6:
                  return g.fn.call(g.context, u, f, d, p, v), !0;
              }
              for (_ = 1, m = new Array(b - 1); _ < b; _++) m[_ - 1] = arguments[_];
              g.fn.apply(g.context, m);
            } else {
              var N = g.length,
                O;
              for (_ = 0; _ < N; _++) switch (g[_].once && this.removeListener(c, g[_].fn, void 0, !0), b) {
                case 1:
                  g[_].fn.call(g[_].context);
                  break;
                case 2:
                  g[_].fn.call(g[_].context, u);
                  break;
                case 3:
                  g[_].fn.call(g[_].context, u, f);
                  break;
                case 4:
                  g[_].fn.call(g[_].context, u, f, d);
                  break;
                default:
                  if (!m) for (O = 1, m = new Array(b - 1); O < b; O++) m[O - 1] = arguments[O];
                  g[_].fn.apply(g[_].context, m);
              }
            }
            return !0;
          }, s.prototype.on = function (c, u, f) {
            return a(this, c, u, f, !1);
          }, s.prototype.once = function (c, u, f) {
            return a(this, c, u, f, !0);
          }, s.prototype.removeListener = function (c, u, f, d) {
            var p = t ? t + c : c;
            if (!this._events[p]) return this;
            if (!u) return l(this, p), this;
            var v = this._events[p];
            if (v.fn) v.fn === u && (!d || v.once) && (!f || v.context === f) && l(this, p);else {
              for (var h = 0, g = [], b = v.length; h < b; h++) (v[h].fn !== u || d && !v[h].once || f && v[h].context !== f) && g.push(v[h]);
              g.length ? this._events[p] = g.length === 1 ? g[0] : g : l(this, p);
            }
            return this;
          }, s.prototype.removeAllListeners = function (c) {
            var u;
            return c ? (u = t ? t + c : c, this._events[u] && l(this, u)) : (this._events = new r(), this._eventsCount = 0), this;
          }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = t, s.EventEmitter = s, n.exports = s;
        }(yd)), yd.exports;
      }
      var Wv;
      function gO() {
        if (Wv) return ir;
        Wv = 1;
        var n = ir && ir.__importDefault || function (l) {
          return l && l.__esModule ? l : {
            default: l
          };
        };
        Object.defineProperty(ir, "__esModule", {
          value: !0
        }), ir.IEngine = ir.ISignClient = ir.ISignClientEvents = ir.IEngineEvents = void 0;
        const e = n(Wi());
        class t extends e.default {
          constructor() {
            super();
          }
        }
        ir.IEngineEvents = t;
        class r extends e.default {
          constructor() {
            super();
          }
        }
        ir.ISignClientEvents = r;
        class i {
          constructor(s) {
            this.data = s;
          }
        }
        ir.ISignClient = i;
        class a {
          constructor(s) {
            this.client = s;
          }
        }
        return ir.IEngine = a, ir;
      }
      var md = {},
        sl = {},
        Xv;
      function vO() {
        if (Xv) return sl;
        Xv = 1, Object.defineProperty(sl, "__esModule", {
          value: !0
        }), sl.TONCHAIN = void 0;
        var n;
        return function (e) {
          e.MAINNET = "-239";
        }(n || (sl.TONCHAIN = n = {})), sl;
      }
      var al = {},
        qv;
      function yO() {
        if (qv) return al;
        qv = 1, Object.defineProperty(al, "__esModule", {
          value: !0
        }), al.CONNECT_ITEM_ERROR_CODES = void 0;
        var n;
        return function (e) {
          e[e.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", e[e.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
        }(n || (al.CONNECT_ITEM_ERROR_CODES = n = {})), al;
      }
      var Jv;
      function mO() {
        return Jv || (Jv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.CONNECT_ITEM_ERROR_CODES = n.TONCHAIN = void 0;
          var e = vO();
          Object.defineProperty(n, "TONCHAIN", {
            enumerable: !0,
            get: function () {
              return e.TONCHAIN;
            }
          });
          var t = yO();
          Object.defineProperty(n, "CONNECT_ITEM_ERROR_CODES", {
            enumerable: !0,
            get: function () {
              return t.CONNECT_ITEM_ERROR_CODES;
            }
          });
        }(md)), md;
      }
      var bd = {},
        Gv;
      function Pu() {
        return Gv || (Gv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.AptosAppleWalletName = n.AptosGoogleWalletName = n.OKXInjectWalletName = n.OKXMiniWalletName = n.OKXWalletName = void 0, n.creatOKXWalletInfo = e, n.creatOKXMiniAppWalletInfo = t, n.creatOKXInjectWalletInfo = r, n.OKXWalletName = "OKX Wallet", n.OKXMiniWalletName = "OKX Mini Wallet", n.OKXInjectWalletName = "OKX Inject Wallet", n.AptosGoogleWalletName = "Continue with Google", n.AptosAppleWalletName = "Continue with Apple";
          function e() {
            return {
              appName: "okxAppWallet",
              name: n.OKXWalletName,
              imageUrl: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png"
            };
          }
          function t() {
            return {
              appName: "okxMiniApp",
              name: n.OKXMiniWalletName,
              imageUrl: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png"
            };
          }
          function r() {
            return {
              appName: "okxInjectWallet",
              name: n.OKXInjectWalletName,
              imageUrl: ""
            };
          }
        }(bd)), bd;
      }
      var Vv;
      function bO() {
        return Vv || (Vv = 1, function (n) {
          var e = Go && Go.__createBinding || (Object.create ? function (a, l, s, o) {
              o === void 0 && (o = s);
              var c = Object.getOwnPropertyDescriptor(l, s);
              (!c || ("get" in c ? !l.__esModule : c.writable || c.configurable)) && (c = {
                enumerable: !0,
                get: function () {
                  return l[s];
                }
              }), Object.defineProperty(a, o, c);
            } : function (a, l, s, o) {
              o === void 0 && (o = s), a[o] = l[s];
            }),
            t = Go && Go.__exportStar || function (a, l) {
              for (var s in a) s !== "default" && !Object.prototype.hasOwnProperty.call(l, s) && e(l, a, s);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.ISignClientEvents = n.IEngine = n.IEngineEvents = n.ISignClient = n.getBigIntRpcId = n.formatJsonRpcRequest = n.isJsonRpcError = n.isJsonRpcResponse = n.parseConnectionError = n.isHttpUrl = n.formatJsonRpcError = void 0;
          var r = pO();
          Object.defineProperty(n, "formatJsonRpcError", {
            enumerable: !0,
            get: function () {
              return r.formatJsonRpcError;
            }
          }), Object.defineProperty(n, "isHttpUrl", {
            enumerable: !0,
            get: function () {
              return r.isHttpUrl;
            }
          }), Object.defineProperty(n, "parseConnectionError", {
            enumerable: !0,
            get: function () {
              return r.parseConnectionError;
            }
          }), Object.defineProperty(n, "isJsonRpcResponse", {
            enumerable: !0,
            get: function () {
              return r.isJsonRpcResponse;
            }
          }), Object.defineProperty(n, "isJsonRpcError", {
            enumerable: !0,
            get: function () {
              return r.isJsonRpcError;
            }
          }), Object.defineProperty(n, "formatJsonRpcRequest", {
            enumerable: !0,
            get: function () {
              return r.formatJsonRpcRequest;
            }
          }), Object.defineProperty(n, "getBigIntRpcId", {
            enumerable: !0,
            get: function () {
              return r.getBigIntRpcId;
            }
          });
          var i = gO();
          Object.defineProperty(n, "ISignClient", {
            enumerable: !0,
            get: function () {
              return i.ISignClient;
            }
          }), Object.defineProperty(n, "IEngineEvents", {
            enumerable: !0,
            get: function () {
              return i.IEngineEvents;
            }
          }), Object.defineProperty(n, "IEngine", {
            enumerable: !0,
            get: function () {
              return i.IEngine;
            }
          }), Object.defineProperty(n, "ISignClientEvents", {
            enumerable: !0,
            get: function () {
              return i.ISignClientEvents;
            }
          }), t(mO(), n), t(Pu(), n);
        }(Go)), Go;
      }
      var wd = {},
        zv;
      function wO() {
        return zv || (zv = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.NAMES_CHAINS = n.TON_CHAINS = n.COSMOS_CHAINS = n.APTOS_CHAINS = n.SUI_CHAINS = n.SOLANA_CHAINS = n.BTC_CHAINS = void 0;
          const e = Uv();
          n.BTC_CHAINS = {
            MAINNET: "btc:mainnet",
            FRACTAL: "fractal:mainnet"
          }, n.SOLANA_CHAINS = {
            MAINNET: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
            TESTNET: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
            SONIC_TESTNET: "sonic:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
          }, n.SUI_CHAINS = {
            MAINNET: "sui:mainnet"
          }, n.APTOS_CHAINS = {
            MAINNET: "aptos:mainnet",
            MOVEMENT_MAINNET: "movement:mainnet",
            MOVEMENT_TESTNET: "movement:testnet"
          }, n.COSMOS_CHAINS = {
            COSMOS_MAINNET: "cosmos:cosmoshub-4"
          }, n.TON_CHAINS = {
            MAINNET: "ton:-239"
          }, n.NAMES_CHAINS = {
            [e.NameSpaceKeyBtc]: Object.values(n.BTC_CHAINS),
            [e.NameSpaceKeySOL]: Object.values(n.SOLANA_CHAINS),
            [e.NameSpaceKeyTON]: Object.values(n.TON_CHAINS),
            [e.NameSpaceKeySui]: Object.values(n.SUI_CHAINS),
            [e.NameSpaceKeyAptos]: Object.values(n.APTOS_CHAINS),
            [e.NameSpaceKeyCosmos]: Object.values(n.COSMOS_CHAINS)
          };
        }(wd)), wd;
      }
      var $v;
      function Jt() {
        return $v || ($v = 1, function (n) {
          var e = Jo && Jo.__createBinding || (Object.create ? function (l, s, o, c) {
              c === void 0 && (c = o);
              var u = Object.getOwnPropertyDescriptor(s, o);
              (!u || ("get" in u ? !s.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function () {
                  return s[o];
                }
              }), Object.defineProperty(l, c, u);
            } : function (l, s, o, c) {
              c === void 0 && (c = o), l[c] = s[o];
            }),
            t = Jo && Jo.__exportStar || function (l, s) {
              for (var o in l) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && e(s, l, o);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.NAMES_CHAINS = n.TON_CHAINS = n.COSMOS_CHAINS = n.APTOS_CHAINS = n.SUI_CHAINS = n.SOLANA_CHAINS = n.BTC_CHAINS = n.shortUniversalLink = n.downloadUrl = n.okxDeeplink = n.tonConnectSdkVersion = n.standardDeeplink = n.standardUniversalLink = n.OpenAppLinkType = n.NameSpaceKeyStarknet = n.NameSpaceKeyTron = n.NameSpaceKeyCosmos = n.NameSpaceKeyAptos = n.NameSpaceKeyBtc = n.NameSpaceKeySui = n.NameSpaceKeyTON = n.NameSpaceKeySOL = n.NameSpaceKeyEip155 = void 0, t(hO(), n);
          var r = Uv();
          Object.defineProperty(n, "NameSpaceKeyEip155", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyEip155;
            }
          }), Object.defineProperty(n, "NameSpaceKeySOL", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeySOL;
            }
          }), Object.defineProperty(n, "NameSpaceKeyTON", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyTON;
            }
          }), Object.defineProperty(n, "NameSpaceKeySui", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeySui;
            }
          }), Object.defineProperty(n, "NameSpaceKeyBtc", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyBtc;
            }
          }), Object.defineProperty(n, "NameSpaceKeyAptos", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyAptos;
            }
          }), Object.defineProperty(n, "NameSpaceKeyCosmos", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyCosmos;
            }
          }), Object.defineProperty(n, "NameSpaceKeyTron", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyTron;
            }
          }), Object.defineProperty(n, "NameSpaceKeyStarknet", {
            enumerable: !0,
            get: function () {
              return r.NameSpaceKeyStarknet;
            }
          }), Object.defineProperty(n, "OpenAppLinkType", {
            enumerable: !0,
            get: function () {
              return r.OpenAppLinkType;
            }
          });
          var i = vd();
          Object.defineProperty(n, "standardUniversalLink", {
            enumerable: !0,
            get: function () {
              return i.standardUniversalLink;
            }
          }), Object.defineProperty(n, "standardDeeplink", {
            enumerable: !0,
            get: function () {
              return i.standardDeeplink;
            }
          }), Object.defineProperty(n, "tonConnectSdkVersion", {
            enumerable: !0,
            get: function () {
              return i.tonConnectSdkVersion;
            }
          }), Object.defineProperty(n, "okxDeeplink", {
            enumerable: !0,
            get: function () {
              return i.okxDeeplink;
            }
          }), Object.defineProperty(n, "downloadUrl", {
            enumerable: !0,
            get: function () {
              return i.downloadUrl;
            }
          }), Object.defineProperty(n, "shortUniversalLink", {
            enumerable: !0,
            get: function () {
              return i.shortUniversalLink;
            }
          }), t(bO(), n);
          var a = wO();
          Object.defineProperty(n, "BTC_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.BTC_CHAINS;
            }
          }), Object.defineProperty(n, "SOLANA_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.SOLANA_CHAINS;
            }
          }), Object.defineProperty(n, "SUI_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.SUI_CHAINS;
            }
          }), Object.defineProperty(n, "APTOS_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.APTOS_CHAINS;
            }
          }), Object.defineProperty(n, "COSMOS_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.COSMOS_CHAINS;
            }
          }), Object.defineProperty(n, "TON_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.TON_CHAINS;
            }
          }), Object.defineProperty(n, "NAMES_CHAINS", {
            enumerable: !0,
            get: function () {
              return a.NAMES_CHAINS;
            }
          });
        }(Jo)), Jo;
      }
      var Wr = {},
        gr = {},
        cl = {
          exports: {}
        },
        xO = cl.exports,
        Qv;
      function _O() {
        return Qv || (Qv = 1, function (n, e) {
          (function (t, r) {
            var i = "1.0.40",
              a = "",
              l = "?",
              s = "function",
              o = "undefined",
              c = "object",
              u = "string",
              f = "major",
              d = "model",
              p = "name",
              v = "type",
              h = "vendor",
              g = "version",
              b = "architecture",
              m = "console",
              _ = "mobile",
              N = "tablet",
              O = "smarttv",
              y = "wearable",
              w = "embedded",
              A = 500,
              R = "Amazon",
              T = "Apple",
              D = "ASUS",
              M = "BlackBerry",
              q = "Browser",
              W = "Chrome",
              x = "Edge",
              C = "Firefox",
              B = "Google",
              X = "Huawei",
              J = "LG",
              V = "Microsoft",
              $ = "Motorola",
              se = "Opera",
              ne = "Samsung",
              oe = "Sharp",
              ye = "Sony",
              Te = "Xiaomi",
              ae = "Zebra",
              G = "Facebook",
              Z = "Chromium OS",
              S = "Mac OS",
              ee = " Browser",
              Ce = function (Pe, Fe) {
                var ke = {};
                for (var ze in Pe) Fe[ze] && Fe[ze].length % 2 === 0 ? ke[ze] = Fe[ze].concat(Pe[ze]) : ke[ze] = Pe[ze];
                return ke;
              },
              Oe = function (Pe) {
                for (var Fe = {}, ke = 0; ke < Pe.length; ke++) Fe[Pe[ke].toUpperCase()] = Pe[ke];
                return Fe;
              },
              Xe = function (Pe, Fe) {
                return typeof Pe === u ? Ve(Fe).indexOf(Ve(Pe)) !== -1 : !1;
              },
              Ve = function (Pe) {
                return Pe.toLowerCase();
              },
              at = function (Pe) {
                return typeof Pe === u ? Pe.replace(/[^\d\.]/g, a).split(".")[0] : r;
              },
              ht = function (Pe, Fe) {
                if (typeof Pe === u) return Pe = Pe.replace(/^\s\s*/, a), typeof Fe === o ? Pe : Pe.substring(0, A);
              },
              Et = function (Pe, Fe) {
                for (var ke = 0, ze, Bt, mt, Je, Ke, St; ke < Fe.length && !Ke;) {
                  var Gt = Fe[ke],
                    hn = Fe[ke + 1];
                  for (ze = Bt = 0; ze < Gt.length && !Ke && Gt[ze];) if (Ke = Gt[ze++].exec(Pe), Ke) for (mt = 0; mt < hn.length; mt++) St = Ke[++Bt], Je = hn[mt], typeof Je === c && Je.length > 0 ? Je.length === 2 ? typeof Je[1] == s ? this[Je[0]] = Je[1].call(this, St) : this[Je[0]] = Je[1] : Je.length === 3 ? typeof Je[1] === s && !(Je[1].exec && Je[1].test) ? this[Je[0]] = St ? Je[1].call(this, St, Je[2]) : r : this[Je[0]] = St ? St.replace(Je[1], Je[2]) : r : Je.length === 4 && (this[Je[0]] = St ? Je[3].call(this, St.replace(Je[1], Je[2])) : r) : this[Je] = St || r;
                  ke += 2;
                }
              },
              vt = function (Pe, Fe) {
                for (var ke in Fe) if (typeof Fe[ke] === c && Fe[ke].length > 0) {
                  for (var ze = 0; ze < Fe[ke].length; ze++) if (Xe(Fe[ke][ze], Pe)) return ke === l ? r : ke;
                } else if (Xe(Fe[ke], Pe)) return ke === l ? r : ke;
                return Fe.hasOwnProperty("*") ? Fe["*"] : Pe;
              },
              It = {
                "1.0": "/8",
                "1.2": "/1",
                "1.3": "/3",
                "2.0": "/412",
                "2.0.2": "/416",
                "2.0.3": "/417",
                "2.0.4": "/419",
                "?": "/"
              },
              yt = {
                ME: "4.90",
                "NT 3.11": "NT3.51",
                "NT 4.0": "NT4.0",
                2e3: "NT 5.0",
                XP: ["NT 5.1", "NT 5.2"],
                Vista: "NT 6.0",
                7: "NT 6.1",
                8: "NT 6.2",
                "8.1": "NT 6.3",
                10: ["NT 6.4", "NT 10.0"],
                RT: "ARM"
              },
              ut = {
                browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [g, [p, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [g, [p, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [p, g], [/opios[\/ ]+([\w\.]+)/i], [g, [p, se + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [g, [p, se + " GX"]], [/\bopr\/([\w\.]+)/i], [g, [p, se]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [g, [p, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [g, [p, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [p, g], [/quark(?:pc)?\/([-\w\.]+)/i], [g, [p, "Quark"]], [/\bddg\/([\w\.]+)/i], [g, [p, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [g, [p, "UC" + q]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [g, [p, "WeChat"]], [/konqueror\/([\w\.]+)/i], [g, [p, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [g, [p, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [g, [p, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [g, [p, "Smart Lenovo " + q]], [/(avast|avg)\/([\w\.]+)/i], [[p, /(.+)/, "$1 Secure " + q], g], [/\bfocus\/([\w\.]+)/i], [g, [p, C + " Focus"]], [/\bopt\/([\w\.]+)/i], [g, [p, se + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [g, [p, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [g, [p, "Dolphin"]], [/coast\/([\w\.]+)/i], [g, [p, se + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [g, [p, "MIUI" + ee]], [/fxios\/([\w\.-]+)/i], [g, [p, C]], [/\bqihoobrowser\/?([\w\.]*)/i], [g, [p, "360"]], [/\b(qq)\/([\w\.]+)/i], [[p, /(.+)/, "$1Browser"], g], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[p, /(.+)/, "$1" + ee], g], [/samsungbrowser\/([\w\.]+)/i], [g, [p, ne + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [g, [p, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[p, "Sogou Mobile"], g], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [p, g], [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i], [p], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [g, p], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[p, G], g], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [p, g], [/\bgsa\/([\w\.]+) .*safari\//i], [g, [p, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [g, [p, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [g, [p, W + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[p, W + " WebView"], g], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [g, [p, "Android " + q]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [p, g], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [g, [p, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [g, p], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [p, [g, vt, It]], [/(webkit|khtml)\/([\w\.]+)/i], [p, g], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[p, "Netscape"], g], [/(wolvic|librewolf)\/([\w\.]+)/i], [p, g], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [g, [p, C + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [p, [g, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [p, [g, /master.|lts./, ""]]],
                cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[b, "amd64"]], [/(ia32(?=;))/i], [[b, Ve]], [/((?:i[346]|x)86)[;\)]/i], [[b, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[b, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[b, "armhf"]], [/windows (ce|mobile); ppc;/i], [[b, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[b, /ower/, a, Ve]], [/(sun4\w)[;\)]/i], [[b, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[b, Ve]]],
                device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d, [h, ne], [v, N]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [d, [h, ne], [v, _]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [d, [h, T], [v, _]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d, [h, T], [v, N]], [/(macintosh);/i], [d, [h, T]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d, [h, oe], [v, _]], [/(?:honor)([-\w ]+)[;\)]/i], [d, [h, "Honor"], [v, _]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d, [h, X], [v, N]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d, [h, X], [v, _]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i], [[d, /_/g, " "], [h, Te], [v, _]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d, /_/g, " "], [h, Te], [v, N]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d, [h, "OPPO"], [v, _]], [/\b(opd2\d{3}a?) bui/i], [d, [h, "OPPO"], [v, N]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d, [h, "Vivo"], [v, _]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [d, [h, "Realme"], [v, _]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d, [h, $], [v, _]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d, [h, $], [v, N]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d, [h, J], [v, N]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d, [h, J], [v, _]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d, [h, "Lenovo"], [v, N]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d, /_/g, " "], [h, "Nokia"], [v, _]], [/(pixel c)\b/i], [d, [h, B], [v, N]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d, [h, B], [v, _]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d, [h, ye], [v, _]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d, "Xperia Tablet"], [h, ye], [v, N]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d, [h, "OnePlus"], [v, _]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d, [h, R], [v, N]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d, /(.+)/g, "Fire Phone $1"], [h, R], [v, _]], [/(playbook);[-\w\),; ]+(rim)/i], [d, h, [v, N]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d, [h, M], [v, _]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d, [h, D], [v, N]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d, [h, D], [v, _]], [/(nexus 9)/i], [d, [h, "HTC"], [v, N]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h, [d, /_/g, " "], [v, _]], [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [d, [h, "TCL"], [v, N]], [/(itel) ((\w+))/i], [[h, Ve], d, [v, vt, {
                  tablet: ["p10001l", "w7001"],
                  "*": "mobile"
                }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d, [h, "Acer"], [v, N]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d, [h, "Meizu"], [v, _]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [d, [h, "Ulefone"], [v, _]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [d, [h, "Energizer"], [v, _]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [d, [h, "Cat"], [v, _]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [d, [h, "Smartfren"], [v, _]], [/droid.+; (a(?:015|06[35]|142p?))/i], [d, [h, "Nothing"], [v, _]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h, d, [v, _]], [/(imo) (tab \w+)/i, /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h, d, [v, N]], [/(surface duo)/i], [d, [h, V], [v, N]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d, [h, "Fairphone"], [v, _]], [/(u304aa)/i], [d, [h, "AT&T"], [v, _]], [/\bsie-(\w*)/i], [d, [h, "Siemens"], [v, _]], [/\b(rct\w+) b/i], [d, [h, "RCA"], [v, N]], [/\b(venue[\d ]{2,7}) b/i], [d, [h, "Dell"], [v, N]], [/\b(q(?:mv|ta)\w+) b/i], [d, [h, "Verizon"], [v, N]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d, [h, "Barnes & Noble"], [v, N]], [/\b(tm\d{3}\w+) b/i], [d, [h, "NuVision"], [v, N]], [/\b(k88) b/i], [d, [h, "ZTE"], [v, N]], [/\b(nx\d{3}j) b/i], [d, [h, "ZTE"], [v, _]], [/\b(gen\d{3}) b.+49h/i], [d, [h, "Swiss"], [v, _]], [/\b(zur\d{3}) b/i], [d, [h, "Swiss"], [v, N]], [/\b((zeki)?tb.*\b) b/i], [d, [h, "Zeki"], [v, N]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h, "Dragon Touch"], d, [v, N]], [/\b(ns-?\w{0,9}) b/i], [d, [h, "Insignia"], [v, N]], [/\b((nxa|next)-?\w{0,9}) b/i], [d, [h, "NextBook"], [v, N]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h, "Voice"], d, [v, _]], [/\b(lvtel\-)?(v1[12]) b/i], [[h, "LvTel"], d, [v, _]], [/\b(ph-1) /i], [d, [h, "Essential"], [v, _]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d, [h, "Envizen"], [v, N]], [/\b(trio[-\w\. ]+) b/i], [d, [h, "MachSpeed"], [v, N]], [/\btu_(1491) b/i], [d, [h, "Rotor"], [v, N]], [/(shield[\w ]+) b/i], [d, [h, "Nvidia"], [v, N]], [/(sprint) (\w+)/i], [h, d, [v, _]], [/(kin\.[onetw]{3})/i], [[d, /\./g, " "], [h, V], [v, _]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d, [h, ae], [v, N]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d, [h, ae], [v, _]], [/smart-tv.+(samsung)/i], [h, [v, O]], [/hbbtv.+maple;(\d+)/i], [[d, /^/, "SmartTV"], [h, ne], [v, O]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h, J], [v, O]], [/(apple) ?tv/i], [h, [d, T + " TV"], [v, O]], [/crkey/i], [[d, W + "cast"], [h, B], [v, O]], [/droid.+aft(\w+)( bui|\))/i], [d, [h, R], [v, O]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d, [h, oe], [v, O]], [/(bravia[\w ]+)( bui|\))/i], [d, [h, ye], [v, O]], [/(mitv-\w{5}) bui/i], [d, [h, Te], [v, O]], [/Hbbtv.*(technisat) (.*);/i], [h, d, [v, O]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h, ht], [d, ht], [v, O]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[v, O]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h, d, [v, m]], [/droid.+; (shield) bui/i], [d, [h, "Nvidia"], [v, m]], [/(playstation [345portablevi]+)/i], [d, [h, ye], [v, m]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d, [h, V], [v, m]], [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i], [d, [h, ne], [v, y]], [/((pebble))app/i], [h, d, [v, y]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d, [h, T], [v, y]], [/droid.+; (glass) \d/i], [d, [h, B], [v, y]], [/droid.+; (wt63?0{2,3})\)/i], [d, [h, ae], [v, y]], [/droid.+; (glass) \d/i], [d, [h, B], [v, y]], [/(pico) (4|neo3(?: link|pro)?)/i], [h, d, [v, y]], [/; (quest( \d| pro)?)/i], [d, [h, G], [v, y]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h, [v, w]], [/(aeobc)\b/i], [d, [h, R], [v, w]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [d, [v, _]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d, [v, N]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[v, N]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[v, _]], [/(android[-\w\. ]{0,9});.+buil/i], [d, [h, "Generic"]]],
                engine: [[/windows.+ edge\/([\w\.]+)/i], [g, [p, x + "HTML"]], [/(arkweb)\/([\w\.]+)/i], [p, g], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [g, [p, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [p, g], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [g, p]],
                os: [[/microsoft (windows) (vista|xp)/i], [p, g], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [p, [g, vt, yt]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[g, vt, yt], [p, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[g, /_/g, "."], [p, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[p, S], [g, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [g, p], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [p, g], [/\(bb(10);/i], [g, [p, M]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [g, [p, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [g, [p, C + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [g, [p, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [g, [p, "watchOS"]], [/crkey\/([\d\.]+)/i], [g, [p, W + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[p, Z], g], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [p, g], [/(sunos) ?([\w\.\d]*)/i], [[p, "Solaris"], g], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [p, g]]
              },
              rt = function (Pe, Fe) {
                if (typeof Pe === c && (Fe = Pe, Pe = r), !(this instanceof rt)) return new rt(Pe, Fe).getResult();
                var ke = typeof t !== o && t.navigator ? t.navigator : r,
                  ze = Pe || (ke && ke.userAgent ? ke.userAgent : a),
                  Bt = ke && ke.userAgentData ? ke.userAgentData : r,
                  mt = Fe ? Ce(ut, Fe) : ut,
                  Je = ke && ke.userAgent == ze;
                return this.getBrowser = function () {
                  var Ke = {};
                  return Ke[p] = r, Ke[g] = r, Et.call(Ke, ze, mt.browser), Ke[f] = at(Ke[g]), Je && ke && ke.brave && typeof ke.brave.isBrave == s && (Ke[p] = "Brave"), Ke;
                }, this.getCPU = function () {
                  var Ke = {};
                  return Ke[b] = r, Et.call(Ke, ze, mt.cpu), Ke;
                }, this.getDevice = function () {
                  var Ke = {};
                  return Ke[h] = r, Ke[d] = r, Ke[v] = r, Et.call(Ke, ze, mt.device), Je && !Ke[v] && Bt && Bt.mobile && (Ke[v] = _), Je && Ke[d] == "Macintosh" && ke && typeof ke.standalone !== o && ke.maxTouchPoints && ke.maxTouchPoints > 2 && (Ke[d] = "iPad", Ke[v] = N), Ke;
                }, this.getEngine = function () {
                  var Ke = {};
                  return Ke[p] = r, Ke[g] = r, Et.call(Ke, ze, mt.engine), Ke;
                }, this.getOS = function () {
                  var Ke = {};
                  return Ke[p] = r, Ke[g] = r, Et.call(Ke, ze, mt.os), Je && !Ke[p] && Bt && Bt.platform && Bt.platform != "Unknown" && (Ke[p] = Bt.platform.replace(/chrome os/i, Z).replace(/macos/i, S)), Ke;
                }, this.getResult = function () {
                  return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                  };
                }, this.getUA = function () {
                  return ze;
                }, this.setUA = function (Ke) {
                  return ze = typeof Ke === u && Ke.length > A ? ht(Ke, A) : Ke, this;
                }, this.setUA(ze), this;
              };
            rt.VERSION = i, rt.BROWSER = Oe([p, g, f]), rt.CPU = Oe([b]), rt.DEVICE = Oe([d, h, v, m, _, O, N, y, w]), rt.ENGINE = rt.OS = Oe([p, g]), n.exports && (e = n.exports = rt), e.UAParser = rt;
            var pt = typeof t !== o && (t.jQuery || t.Zepto);
            if (pt && !pt.ua) {
              var Ct = new rt();
              pt.ua = Ct.getResult(), pt.ua.get = function () {
                return Ct.getUA();
              }, pt.ua.set = function (Pe) {
                Ct.setUA(Pe);
                var Fe = Ct.getResult();
                for (var ke in Fe) pt.ua[ke] = Fe[ke];
              };
            }
          })(typeof window == "object" ? window : xO);
        }(cl, cl.exports)), cl.exports;
      }
      var Yv;
      function xd() {
        if (Yv) return gr;
        Yv = 1;
        var n = gr && gr.__importDefault || function (f) {
          return f && f.__esModule ? f : {
            default: f
          };
        };
        Object.defineProperty(gr, "__esModule", {
          value: !0
        }), gr.openLink = i, gr.openLinkBlank = a, gr.openDeeplinkWithFallback = l, gr.isMobileUserAgent = s, gr.getUserAgent = o, gr.isOS = c, gr.isBrowser = u;
        const e = n(_O()),
          t = yn(),
          r = Iu();
        function i(f, d = "_self") {
          (0, t.logDebug)("openLink", f, d), window.open(f, d, "noopener noreferrer");
        }
        function a(f) {
          i(f, "_blank");
        }
        function l(f, d) {
          const p = () => {
              u("safari") || c("android") && u("firefox") || d();
            },
            v = setTimeout(() => p(), 500);
          window.addEventListener("blur", () => clearTimeout(v), {
            once: !0
          }), c("android") && (0, r.inTg)() ? i(f, "_blank") : i(f, "_self");
        }
        function s() {
          let f = !1;
          return function (d) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(d) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(d.slice(0, 4))) && (f = !0);
          }(navigator.userAgent || navigator.vendor || window.opera), f;
        }
        function o() {
          var f, d, p;
          const v = new e.default().getResult(),
            h = (f = v.os.name) === null || f === void 0 ? void 0 : f.toLowerCase(),
            g = (d = v.device.model) === null || d === void 0 ? void 0 : d.toLowerCase();
          let b;
          switch (!0) {
            case g === "ipad":
              b = "ipad";
              break;
            case h === "ios":
              b = "ios";
              break;
            case h === "android":
              b = "android";
              break;
            case h === "mac os":
              b = "macos";
              break;
            case h === "linux":
              b = "linux";
              break;
            case h == null ? void 0 : h.includes("windows"):
              b = "windows";
              break;
          }
          const m = (p = v.browser.name) === null || p === void 0 ? void 0 : p.toLowerCase();
          let _;
          switch (!0) {
            case m === "chrome":
              _ = "chrome";
              break;
            case m === "firefox":
              _ = "firefox";
              break;
            case m == null ? void 0 : m.includes("safari"):
              _ = "safari";
              break;
            case m == null ? void 0 : m.includes("opera"):
              _ = "opera";
              break;
          }
          return {
            os: b,
            browser: _
          };
        }
        function c(...f) {
          return f.includes(o().os);
        }
        function u(...f) {
          return f.includes(o().browser);
        }
        return gr;
      }
      var Zv;
      function Iu() {
        if (Zv) return Wr;
        Zv = 1;
        var n, e, t, r, i, a, l;
        Object.defineProperty(Wr, "__esModule", {
          value: !0
        }), Wr.isTmaPlatform = v, Wr.isInTMA = h, Wr.inTg = g, Wr.isInTelegramBrowser = b, Wr.sendExpand = m, Wr.sendOpenTelegramLink = _, Wr.versionCompare = R;
        const s = ll(),
          o = yn(),
          c = Jt(),
          u = xd();
        let f = {};
        try {
          let D = location.hash.toString();
          f = y(D);
        } catch {}
        let d = "unknown";
        if (f != null && f.tgWebAppPlatform && (d = (n = f.tgWebAppPlatform) !== null && n !== void 0 ? n : "unknown"), d === "unknown") {
          const D = (0, s.getWindow)();
          d = (r = (t = (e = D == null ? void 0 : D.Telegram) === null || e === void 0 ? void 0 : e.WebApp) === null || t === void 0 ? void 0 : t.platform) !== null && r !== void 0 ? r : "unknown";
        }
        let p = "6.0";
        if (f != null && f.tgWebAppVersion && (p = f.tgWebAppVersion), !p) {
          const D = (0, s.getWindow)();
          p = (l = (a = (i = D == null ? void 0 : D.Telegram) === null || i === void 0 ? void 0 : i.WebApp) === null || a === void 0 ? void 0 : a.version) !== null && l !== void 0 ? l : "6.0";
        }
        function v(...D) {
          return D.includes(d);
        }
        function h() {
          var D;
          return d !== "unknown" || !!(!((D = (0, s.getWindow)()) === null || D === void 0) && D.TelegramWebviewProxy);
        }
        function g() {
          return b() || h();
        }
        function b() {
          var D;
          const M = !!(!((D = (0, s.getWindow)()) === null || D === void 0) && D.TelegramWebview);
          return (h() || M) && d === "unknown";
        }
        function m() {
          O("web_app_expand", {});
        }
        function _(D, M) {
          const q = new URL(D);
          if (q.protocol !== "http:" && q.protocol !== "https:") {
            if (M) return M();
            throw new c.OKXConnectError(c.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Url protocol is not supported: ${q}`);
          }
          if (q.hostname !== "t.me") {
            if (M) return M();
            throw new c.OKXConnectError(c.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Url host is not supported: ${q}`);
          }
          const W = q.pathname + q.search;
          N() || T("6.1") ? O("web_app_open_tg_link", {
            path_full: W
          }) : (0, u.openLinkBlank)("https://t.me" + W);
        }
        function N() {
          try {
            const D = (0, s.getWindow)();
            return D ? D.parent != null && D !== D.parent : !1;
          } catch {
            return !1;
          }
        }
        function O(D, M) {
          try {
            const q = (0, s.getWindow)();
            if (!q) throw new c.OKXConnectError(c.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Can't post event to parent window: window is not defined");
            if (q.TelegramWebviewProxy !== void 0) (0, o.logDebug)("postEvent", D, M), q.TelegramWebviewProxy.postEvent(D, JSON.stringify(M));else if (q.external && "notify" in q.external) (0, o.logDebug)("postEvent", D, M), q.external.notify(JSON.stringify({
              eventType: D,
              eventData: M
            }));else if (N()) {
              const W = "*",
                x = JSON.stringify({
                  eventType: D,
                  eventData: M
                });
              (0, o.logDebug)("postEvent", D, M), q.parent.postMessage(x, W);
            } else throw new c.OKXConnectError(c.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Can't post event to TMA");
          } catch (q) {
            (0, o.logError)(`Can't post event to parent window: ${q}`);
          }
        }
        function y(D) {
          D = D.replace(/^#/, "");
          let M = {};
          if (!D.length) return M;
          if (D.indexOf("=") < 0 && D.indexOf("?") < 0) return M._path = w(D), M;
          let q = D.indexOf("?");
          if (q >= 0) {
            let x = D.substr(0, q);
            M._path = w(x), D = D.substr(q + 1);
          }
          let W = A(D);
          for (let x in W) M[x] = W[x];
          return M;
        }
        function w(D) {
          try {
            return D = D.replace(/\+/g, "%20"), decodeURIComponent(D);
          } catch {
            return D;
          }
        }
        function A(D) {
          let M = {};
          if (!D.length) return M;
          let q = D.split("&"),
            W,
            x,
            C,
            B;
          for (W = 0; W < q.length; W++) x = q[W].split("="), C = w(x[0]), B = x[1] == null ? null : w(x[1]), M[C] = B;
          return M;
        }
        function R(D, M) {
          typeof D != "string" && (D = ""), typeof M != "string" && (M = "");
          let q = D.replace(/^\s+|\s+$/g, "").split("."),
            W = M.replace(/^\s+|\s+$/g, "").split("."),
            x,
            C,
            B,
            X;
          for (x = Math.max(q.length, W.length), C = 0; C < x; C++) if (B = parseInt(q[C]) || 0, X = parseInt(W[C]) || 0, B !== X) return B > X ? 1 : -1;
          return 0;
        }
        function T(D) {
          return R(p, D) >= 0;
        }
        return Wr;
      }
      var ey;
      function ll() {
        if (ey) return vn;
        ey = 1;
        var n, e, t, r;
        Object.defineProperty(vn, "__esModule", {
          value: !0
        }), vn.removeUrlLastSlash = u, vn.addPathToUrl = f, vn.getUniversalLink = d, vn.openOKXDeeplink = p, vn.openOKXDeeplinkWithFallback = v, vn.getWindow = h, vn.isTelegramUrl = g, vn.encodeTelegramUrlParameters = b, vn.encodeConnectParams = m, vn.encodeTWAConnectURLParams = _, vn.getAppWalletDeepLink = N, vn.getAppWalletShortDeepLink = O, vn.getTelegramWalletTWAUrl = y, vn.openOKXTMAWalletlinkWithFallback = w, vn.isInTMA = q, vn.isInTelegramBrowser = W, vn.getOKXLink = x;
        const i = Jt(),
          a = yn(),
          l = vd(),
          s = vr(),
          o = Iu(),
          c = zc();
        function u(C) {
          return C.slice(-1) === "/" ? C.slice(0, -1) : C;
        }
        function f(C, B) {
          return u(C) + "/" + B;
        }
        function d(C, B = !1) {
          console.log("getUniversalLink deeplinkUrl:", C, ", useStandardUniversalLink:", B);
          const X = encodeURIComponent(C);
          return console.log("getUniversalLink standardUniversalLink:", i.standardUniversalLink), console.log("getUniversalLink standardUniversalLink:", `${i.standardUniversalLink}?deeplink=${X}`), `${i.standardUniversalLink}?deeplink=${X}`;
        }
        function p(C, B, X) {
          v(C, B, X, !1);
        }
        function v(C, B, X, J = !0) {
          var V;
          const $ = !!(!((V = h()) === null || V === void 0) && V.TelegramWebviewProxy);
          console.log("openOKXDeeplinkWithFallback fullUrl:", B);
          let se = !1;
          const ne = 3e3;
          i.standardUniversalLink, console.log("openOKXDeeplinkWithFallback standardUniversalLink:", i.standardUniversalLink);
          let oe = null,
            ye = () => {
              console.log("fallbackToDownloadPage :empty");
            },
            Te = !1;
          if (X === i.OpenAppLinkType.UniversalLink ? Te = (0, s.isInIOSChrome)() || (0, s.isInIOSLine)() || (0, s.isInIOSLark)() || (0, s.isInIOSWeChat)() : Te = $ === !1 && (0, s.isIos)(), J && ((0, s.isIos)() ? Te && (ye = () => {
            console.log("windowOpen --> fallbackToDownloadPage --", se), se || (console.log("windowOpen --> fallbackToDownloadPage universal link"), window.open(B, "_self"));
          }) : ye = () => {
            se || (oe ? oe.open(B, "_self") : window.open(B, "_blank"));
          }), !(0, s.isIos)() || Te) {
            if ($ ? oe = window.open(C, "_blank") : (console.log("windowOpen --> deeplinkUrl"), window.location.href = C), J) {
              setTimeout(ye, ne);
              let ae = 0,
                G = setInterval(() => {
                  ae++, console.log("windowOpen --> interval:", ae, document.hidden, document.visibilityState), document.hidden && (se = !0), (ae > 10 || document.hidden) && (clearInterval(G), console.log("windowOpen :cleat: ${count}"));
                }, 200);
              window.addEventListener("blur", () => {
                console.log("windowOpen :blur"), se = !0;
              }, {
                once: !0
              }), document.addEventListener("visibilitychange", () => {
                console.log("windowOpen :visibilitychange:", document.visibilityState), document.visibilityState === "hidden" && (se = !0);
              });
            }
          } else $ ? window.open(B, "_blank") : (console.log("windowOpen[before]: ", Date.now()), window != null && window.okxLogDebug ? window.open(B, "_blank") : window.open(B, "_self"), console.log("windowOpen[after]: ", Date.now()));
        }
        function h() {
          if (typeof window != "undefined") return window;
        }
        function g(C) {
          if (!C) return !1;
          const B = new URL(C);
          return B.protocol === "tg:" || B.hostname === "t.me";
        }
        function b(C) {
          let B = C;
          return B = B.replace(/\./g, "%2E"), B = B.replace(/-/g, "%2D"), B = B.replace(/_/g, "%5F"), B = B.replace(/&/g, "-"), B = B.replace(/=/g, "__"), B = B.replace(/%/g, "--"), B;
        }
        function m(C) {
          let B = Object.assign(Object.assign({}, C), {
            protocolVersion: c.CONNECT_PROTOCOL_VER
          });
          const X = JSON.stringify(B);
          (0, a.logDebug)("url encodeConnectParams connectRequestStr ", X);
          const J = new TextEncoder().encode(X),
            V = btoa(String.fromCharCode(...J));
          return (0, a.logDebug)("url encodeConnectParams base64Encoded ", V), V;
        }
        function _(C) {
          const B = JSON.stringify({
            topic: C.topic,
            clientId: C.clientId
          });
          (0, a.logDebug)("url encodeConnectParams connectRequestStr", B);
          const X = new TextEncoder().encode(B);
          return btoa(String.fromCharCode(...X));
        }
        function N(C) {
          return `${i.standardDeeplink}?param=${C}`;
        }
        function O(C, B) {
          return `${l.shortUniversalLink}?topic=${C}${(0, s.getLastSixMd5Hash)(B)}`;
        }
        function y(C, B) {
          let X = {
            okxconnect: "",
            redirect: "",
            extraparams: "",
            fromtg: !1
          };
          C && (X.okxconnect = C), B && (X.redirect = B), q() ? X.fromtg = !0 : X.fromtg = !1, (0, a.logDebug)("getTelegramWalletTWAUrl redirect:", X.redirect);
          let J = JSON.stringify(X);
          const V = new TextEncoder().encode(J),
            $ = btoa(String.fromCharCode(...V)),
            se = (0, s.toSafeBase64FromBase64)($);
          if ((0, a.logDebug)("[TWA] open link:", X, $), C || B) {
            if (q()) return (0, l.getTestTgTwaUrl)() ? `${(0, l.getTestTgTwaUrl)()}?startapp=${se}` : `https://t.me/${l.tgwalletName}/start?startapp=${se}`;
            if ((0, l.getTestTwaUrl)()) return `${(0, l.getTestTwaUrl)()}?tgWebAppStartParam=${se}`;
            if ((0, l.getTestTgTwaUrl)()) {
              let ne = (0, l.getBotNameAndAppName)((0, l.getTestTgTwaUrl)());
              if (ne) {
                let {
                  botName: oe,
                  appName: ye
                } = ne;
                return `tg://resolve?domain=${oe}&appname=${ye}&startapp=${se}`;
              }
              return `tg://resolve?domain=${l.tgwalletName}&appname=${l.tgwalletAppName}&startapp=${se}`;
            } else return `tg://resolve?domain=${l.tgwalletName}&appname=${l.tgwalletAppName}&startapp=${se}`;
          }
          if (q()) return (0, l.getTestTgTwaUrl)() ? `${(0, l.getTestTgTwaUrl)()}` : `https://t.me/${l.tgwalletName}/start`;
          if ((0, l.getTestTwaUrl)()) return `${(0, l.getTestTwaUrl)()}`;
          if ((0, l.getTestTgTwaUrl)()) {
            let ne = (0, l.getBotNameAndAppName)((0, l.getTestTgTwaUrl)());
            if (ne) {
              let {
                botName: oe,
                appName: ye
              } = ne;
              return `tg://resolve?domain=${oe}&appname=${ye}`;
            }
            return `tg://resolve?domain=${l.tgwalletName}&appname=${l.tgwalletAppName}`;
          } else return `tg://resolve?domain=${l.tgwalletName}&appname=${l.tgwalletAppName}`;
        }
        function w(C) {
          var B, X, J, V, $;
          (0, a.logDebug)("[TWA] open link:", C, "isInTMA ==> ", q()), q() ? !((X = (B = h()) === null || B === void 0 ? void 0 : B.Telegram) === null || X === void 0) && X.WebApp ? ($ = (V = (J = h()) === null || J === void 0 ? void 0 : J.Telegram) === null || V === void 0 ? void 0 : V.WebApp) === null || $ === void 0 || $.openTelegramLink(C) : (0, o.sendOpenTelegramLink)(C) : (0, l.getTestTwaUrl)() ? window.open(C, "_blank") : window.open(C, "_self");
        }
        function A(C) {
          try {
            return C = C.replace(/\+/g, "%20"), decodeURIComponent(C);
          } catch {
            return C;
          }
        }
        function R(C) {
          let B = {};
          if (!C.length) return B;
          let X = C.split("&"),
            J,
            V,
            $,
            se;
          for (J = 0; J < X.length; J++) V = X[J].split("="), $ = A(V[0]), se = V[1] == null ? null : A(V[1]), B[$] = se;
          return B;
        }
        function T(C) {
          C = C.replace(/^#/, "");
          let B = {};
          if (!C.length) return B;
          if (C.indexOf("=") < 0 && C.indexOf("?") < 0) return B._path = A(C), B;
          let X = C.indexOf("?");
          if (X >= 0) {
            let V = C.substr(0, X);
            B._path = A(V), C = C.substr(X + 1);
          }
          let J = R(C);
          for (let V in J) B[V] = J[V];
          return B;
        }
        let D = {};
        try {
          let C = location.hash.toString();
          D = T(C);
        } catch {}
        let M = "unknown";
        if (D != null && D.tgWebAppPlatform && (M = (n = D.tgWebAppPlatform) !== null && n !== void 0 ? n : "unknown"), M === "unknown") {
          const C = h();
          M = (r = (t = (e = C == null ? void 0 : C.Telegram) === null || e === void 0 ? void 0 : e.WebApp) === null || t === void 0 ? void 0 : t.platform) !== null && r !== void 0 ? r : "unknown";
        }
        function q() {
          var C;
          return M !== "unknown" || !!(!((C = h()) === null || C === void 0) && C.TelegramWebviewProxy);
        }
        function W() {
          var C;
          const B = !!(!((C = h()) === null || C === void 0) && C.TelegramWebview);
          return (q() || B) && M === "unknown";
        }
        function x(C, B = !1, X) {
          if ((0, a.logDebug)(`url  getOKXLink() called connectRequest==> ${JSON.stringify(C)}  useMini=> ${B}  tmaReturnUrl==> ${X}`), B) return C ? {
            universalLink: y(_(C), X != null ? X : "back")
          } : {
            universalLink: y(void 0, X != null ? X : "back")
          };
          {
            let J = C ? `${i.standardDeeplink}?param=${m(C)}` : i.standardDeeplink;
            return (0, s.useShortLink)() ? {
              universalLink: C ? O(C.topic, C.clientId) : l.shortUniversalLink,
              deepLink: J
            } : {
              universalLink: d(J),
              deepLink: J
            };
          }
        }
        return vn;
      }
      var Vo = {},
        zo = {},
        ty;
      function EO() {
        if (ty) return zo;
        ty = 1;
        var n = zo && zo.__awaiter || function (r, i, a, l) {
          function s(o) {
            return o instanceof a ? o : new a(function (c) {
              c(o);
            });
          }
          return new (a || (a = Promise))(function (o, c) {
            function u(p) {
              try {
                d(l.next(p));
              } catch (v) {
                c(v);
              }
            }
            function f(p) {
              try {
                d(l.throw(p));
              } catch (v) {
                c(v);
              }
            }
            function d(p) {
              p.done ? o(p.value) : s(p.value).then(u, f);
            }
            d((l = l.apply(r, i || [])).next());
          });
        };
        Object.defineProperty(zo, "__esModule", {
          value: !0
        }), zo.callForSuccess = e, zo.delay = t;
        function e(r, i) {
          return n(this, void 0, void 0, function* () {
            var a, l;
            const s = (a = i == null ? void 0 : i.attempts) !== null && a !== void 0 ? a : 3,
              o = (l = i == null ? void 0 : i.delayMs) !== null && l !== void 0 ? l : 800;
            if (typeof r != "function") throw new Error(`Expected a function, got ${typeof r}`);
            let c = 0,
              u;
            for (; c < s;) try {
              return yield r();
            } catch (f) {
              u = f, c++, c < s && (yield t(o));
            }
            throw u;
          });
        }
        function t(r, i) {
          return n(this, void 0, void 0, function* () {
            return new Promise((a, l) => {
              var s, o;
              if (!((s = i == null ? void 0 : i.signal) === null || s === void 0) && s.aborted) {
                l(new Error("Delay aborted"));
                return;
              }
              const c = setTimeout(() => a(), r);
              (o = i == null ? void 0 : i.signal) === null || o === void 0 || o.addEventListener("abort", () => {
                clearTimeout(c), l(new Error("Delay aborted"));
              });
            });
          });
        }
        return zo;
      }
      var bt = {},
        ny;
      function CO() {
        return ny || (ny = 1, Object.defineProperty(bt, "__esModule", {
          value: !0
        }), bt.Report_WalletType_Key = bt.Report_OKXConnectSDK_RequestError_Log = bt.Report_OKXConnectSDK_RequestSuccess_Log = bt.Report_OKXConnectSDK_RequestStart_Log = bt.Report_OKXConnectSDKExtension_ConnectDapp_Button_Click = bt.Report_OKXConnectSDKExtension_Module_Retry_Click = bt.Report_ConnectDapp_ConnectAndSign_Click = bt.Report_Proceed_QRCode_Click = bt.Report_ChooseType_Download_Click = bt.Report_ChooseType_ConnectWallet_Click = bt.Report_Proceed_Retry_Click = bt.Report_OKXConnectSDKExtension_ConnectDapp_ConnectSuccess_View = bt.Report_OKXConnectSDKExtension_ConnectDapp_Page_View = bt.Report_ChooseType_ConnectWallet_View = bt.Report_Loading_ConnectWallet_View = bt.Report_Proceed_QRCode_View = bt.Report_Proceed_Proceed_View = void 0, bt.Report_Proceed_Proceed_View = "OKXConnectSDK_Proceed_Proceed_View", bt.Report_Proceed_QRCode_View = "OKXConnectSDK_Proceed_QRCode_View", bt.Report_Loading_ConnectWallet_View = "OKXConnectSDK_Loading_ConnectWallet_View", bt.Report_ChooseType_ConnectWallet_View = "OKXConnectSDK_ChooseType_ConnectWallet_View", bt.Report_OKXConnectSDKExtension_ConnectDapp_Page_View = "OKXConnectSDKExtension_ConnectDapp_Page_View", bt.Report_OKXConnectSDKExtension_ConnectDapp_ConnectSuccess_View = "OKXConnectSDKExtension_ConnectDapp_ConnectSuccess_View", bt.Report_Proceed_Retry_Click = "OKXConnectSDK_Proceed_Retry_Click", bt.Report_ChooseType_ConnectWallet_Click = "OKXConnectSDK_ChooseType_ConnectWallet_Click", bt.Report_ChooseType_Download_Click = "OKXConnectSDK_ChooseType_Download_Click", bt.Report_Proceed_QRCode_Click = "OKXConnectSDK_Proceed_QRCode_Click", bt.Report_ConnectDapp_ConnectAndSign_Click = "OKXConnectSDK_ConnectDapp_ConnectAndSign_Click", bt.Report_OKXConnectSDKExtension_Module_Retry_Click = "OKXConnectSDKExtension_Module_Retry_Click", bt.Report_OKXConnectSDKExtension_ConnectDapp_Button_Click = "OKXConnectSDKExtension_ConnectDapp_Button_Click", bt.Report_OKXConnectSDK_RequestStart_Log = "Report_OKXConnectSDK_RequestStart_View", bt.Report_OKXConnectSDK_RequestSuccess_Log = "Report_OKXConnectSDK_RequestSuccess_View", bt.Report_OKXConnectSDK_RequestError_Log = "Report_OKXConnectSDK_RequestError_View", bt.Report_WalletType_Key = "wallet_type"), bt;
      }
      var Bu = {},
        ry;
      function OO() {
        if (ry) return Bu;
        ry = 1, Object.defineProperty(Bu, "__esModule", {
          value: !0
        }), Bu.checkMetaData = e;
        const n = Jt();
        function e(t) {
          if (!t) throw new n.OKXConnectError(n.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "You have to specify a `dappMetaData`in the options.");
          if (!t.name) throw new n.OKXConnectError(n.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "dappName is required");
          return !0;
        }
        return Bu;
      }
      var iy;
      function tn() {
        return iy || (iy = 1, function (n) {
          var e = Vo && Vo.__createBinding || (Object.create ? function (d, p, v, h) {
              h === void 0 && (h = v);
              var g = Object.getOwnPropertyDescriptor(p, v);
              (!g || ("get" in g ? !p.__esModule : g.writable || g.configurable)) && (g = {
                enumerable: !0,
                get: function () {
                  return p[v];
                }
              }), Object.defineProperty(d, h, g);
            } : function (d, p, v, h) {
              h === void 0 && (h = v), d[h] = p[v];
            }),
            t = Vo && Vo.__exportStar || function (d, p) {
              for (var v in d) v !== "default" && !Object.prototype.hasOwnProperty.call(p, v) && e(p, d, v);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.getNamespaceKeyByChain = n.chainName2IdMap = n.replaceChainIdToChainName = n.replaceChainNameToChainId = n.checkMetaData = n.versionCompare = n.isBrowser = n.isOS = n.isMobileUserAgent = n.openDeeplinkWithFallback = n.openLinkBlank = n.openLink = n.getChainId = n.useShortLink = n.toSafeBase64FromBase64 = n.isValidObject = n.isIos = n.base64decode = n.base64encode = n.splitToUint8Arrays = n.concatUint8Arrays = n.toHexString = n.hexToByteArray = n.getOKXLink = n.getAppWalletShortDeepLink = n.encodeTWAConnectURLParams = n.encodeConnectParams = n.openOKXTMAWalletlinkWithFallback = n.getTelegramWalletTWAUrl = n.getAppWalletDeepLink = n.encodeTelegramUrlParameters = n.isTelegramUrl = n.openOKXDeeplinkWithFallback = n.openOKXDeeplink = n.getUniversalLink = n.safeJsonStringify = n.safeJsonParse = n.getDefaultReporter = n.reportEvent = n.reportLog = n.logWarning = n.logError = n.logDebug = n.callForSuccess = void 0;
          var r = EO();
          Object.defineProperty(n, "callForSuccess", {
            enumerable: !0,
            get: function () {
              return r.callForSuccess;
            }
          });
          var i = yn();
          Object.defineProperty(n, "logDebug", {
            enumerable: !0,
            get: function () {
              return i.logDebug;
            }
          }), Object.defineProperty(n, "logError", {
            enumerable: !0,
            get: function () {
              return i.logError;
            }
          }), Object.defineProperty(n, "logWarning", {
            enumerable: !0,
            get: function () {
              return i.logWarning;
            }
          }), Object.defineProperty(n, "reportLog", {
            enumerable: !0,
            get: function () {
              return i.reportLog;
            }
          }), Object.defineProperty(n, "reportEvent", {
            enumerable: !0,
            get: function () {
              return i.reportEvent;
            }
          }), Object.defineProperty(n, "getDefaultReporter", {
            enumerable: !0,
            get: function () {
              return i.getDefaultReporter;
            }
          }), t(CO(), n), t(ku(), n);
          var a = $o();
          Object.defineProperty(n, "safeJsonParse", {
            enumerable: !0,
            get: function () {
              return a.safeJsonParse;
            }
          }), Object.defineProperty(n, "safeJsonStringify", {
            enumerable: !0,
            get: function () {
              return a.safeJsonStringify;
            }
          });
          var l = ll();
          Object.defineProperty(n, "getUniversalLink", {
            enumerable: !0,
            get: function () {
              return l.getUniversalLink;
            }
          }), Object.defineProperty(n, "openOKXDeeplink", {
            enumerable: !0,
            get: function () {
              return l.openOKXDeeplink;
            }
          }), Object.defineProperty(n, "openOKXDeeplinkWithFallback", {
            enumerable: !0,
            get: function () {
              return l.openOKXDeeplinkWithFallback;
            }
          }), Object.defineProperty(n, "isTelegramUrl", {
            enumerable: !0,
            get: function () {
              return l.isTelegramUrl;
            }
          }), Object.defineProperty(n, "encodeTelegramUrlParameters", {
            enumerable: !0,
            get: function () {
              return l.encodeTelegramUrlParameters;
            }
          }), Object.defineProperty(n, "getAppWalletDeepLink", {
            enumerable: !0,
            get: function () {
              return l.getAppWalletDeepLink;
            }
          }), Object.defineProperty(n, "getTelegramWalletTWAUrl", {
            enumerable: !0,
            get: function () {
              return l.getTelegramWalletTWAUrl;
            }
          }), Object.defineProperty(n, "openOKXTMAWalletlinkWithFallback", {
            enumerable: !0,
            get: function () {
              return l.openOKXTMAWalletlinkWithFallback;
            }
          }), Object.defineProperty(n, "encodeConnectParams", {
            enumerable: !0,
            get: function () {
              return l.encodeConnectParams;
            }
          }), Object.defineProperty(n, "encodeTWAConnectURLParams", {
            enumerable: !0,
            get: function () {
              return l.encodeTWAConnectURLParams;
            }
          }), Object.defineProperty(n, "getAppWalletShortDeepLink", {
            enumerable: !0,
            get: function () {
              return l.getAppWalletShortDeepLink;
            }
          }), Object.defineProperty(n, "getOKXLink", {
            enumerable: !0,
            get: function () {
              return l.getOKXLink;
            }
          });
          var s = vr();
          Object.defineProperty(n, "hexToByteArray", {
            enumerable: !0,
            get: function () {
              return s.hexToByteArray;
            }
          }), Object.defineProperty(n, "toHexString", {
            enumerable: !0,
            get: function () {
              return s.toHexString;
            }
          }), Object.defineProperty(n, "concatUint8Arrays", {
            enumerable: !0,
            get: function () {
              return s.concatUint8Arrays;
            }
          }), Object.defineProperty(n, "splitToUint8Arrays", {
            enumerable: !0,
            get: function () {
              return s.splitToUint8Arrays;
            }
          }), Object.defineProperty(n, "base64encode", {
            enumerable: !0,
            get: function () {
              return s.base64encode;
            }
          }), Object.defineProperty(n, "base64decode", {
            enumerable: !0,
            get: function () {
              return s.base64decode;
            }
          }), Object.defineProperty(n, "isIos", {
            enumerable: !0,
            get: function () {
              return s.isIos;
            }
          }), Object.defineProperty(n, "isValidObject", {
            enumerable: !0,
            get: function () {
              return s.isValidObject;
            }
          }), Object.defineProperty(n, "toSafeBase64FromBase64", {
            enumerable: !0,
            get: function () {
              return s.toSafeBase64FromBase64;
            }
          }), Object.defineProperty(n, "useShortLink", {
            enumerable: !0,
            get: function () {
              return s.useShortLink;
            }
          }), Object.defineProperty(n, "getChainId", {
            enumerable: !0,
            get: function () {
              return s.getChainId;
            }
          });
          var o = xd();
          Object.defineProperty(n, "openLink", {
            enumerable: !0,
            get: function () {
              return o.openLink;
            }
          }), Object.defineProperty(n, "openLinkBlank", {
            enumerable: !0,
            get: function () {
              return o.openLinkBlank;
            }
          }), Object.defineProperty(n, "openDeeplinkWithFallback", {
            enumerable: !0,
            get: function () {
              return o.openDeeplinkWithFallback;
            }
          }), Object.defineProperty(n, "isMobileUserAgent", {
            enumerable: !0,
            get: function () {
              return o.isMobileUserAgent;
            }
          }), Object.defineProperty(n, "isOS", {
            enumerable: !0,
            get: function () {
              return o.isOS;
            }
          }), Object.defineProperty(n, "isBrowser", {
            enumerable: !0,
            get: function () {
              return o.isBrowser;
            }
          });
          var c = Iu();
          Object.defineProperty(n, "versionCompare", {
            enumerable: !0,
            get: function () {
              return c.versionCompare;
            }
          });
          var u = OO();
          Object.defineProperty(n, "checkMetaData", {
            enumerable: !0,
            get: function () {
              return u.checkMetaData;
            }
          });
          var f = vr();
          Object.defineProperty(n, "replaceChainNameToChainId", {
            enumerable: !0,
            get: function () {
              return f.replaceChainNameToChainId;
            }
          }), Object.defineProperty(n, "replaceChainIdToChainName", {
            enumerable: !0,
            get: function () {
              return f.replaceChainIdToChainName;
            }
          }), Object.defineProperty(n, "chainName2IdMap", {
            enumerable: !0,
            get: function () {
              return f.chainName2IdMap;
            }
          }), Object.defineProperty(n, "getNamespaceKeyByChain", {
            enumerable: !0,
            get: function () {
              return f.getNamespaceKeyByChain;
            }
          });
        }(Vo)), Vo;
      }
      var _d = {
        exports: {}
      }; /*!
         localForage -- Offline Storage, Improved
         Version 1.10.0
         https://localforage.github.io/localForage
         (c) 2013-2017 Mozilla, Apache License 2.0
         */
      var oy;
      function Ed() {
        return oy || (oy = 1, function (n, e) {
          (function (t) {
            n.exports = t();
          })(function () {
            return function t(r, i, a) {
              function l(c, u) {
                if (!i[c]) {
                  if (!r[c]) {
                    var f = typeof Xo == "function" && Xo;
                    if (!u && f) return f(c, !0);
                    if (s) return s(c, !0);
                    var d = new Error("Cannot find module '" + c + "'");
                    throw d.code = "MODULE_NOT_FOUND", d;
                  }
                  var p = i[c] = {
                    exports: {}
                  };
                  r[c][0].call(p.exports, function (v) {
                    var h = r[c][1][v];
                    return l(h || v);
                  }, p, p.exports, t, r, i, a);
                }
                return i[c].exports;
              }
              for (var s = typeof Xo == "function" && Xo, o = 0; o < a.length; o++) l(a[o]);
              return l;
            }({
              1: [function (t, r, i) {
                (function (a) {
                  var l = a.MutationObserver || a.WebKitMutationObserver,
                    s;
                  if (l) {
                    var o = 0,
                      c = new l(v),
                      u = a.document.createTextNode("");
                    c.observe(u, {
                      characterData: !0
                    }), s = function () {
                      u.data = o = ++o % 2;
                    };
                  } else if (!a.setImmediate && typeof a.MessageChannel != "undefined") {
                    var f = new a.MessageChannel();
                    f.port1.onmessage = v, s = function () {
                      f.port2.postMessage(0);
                    };
                  } else "document" in a && "onreadystatechange" in a.document.createElement("script") ? s = function () {
                    var g = a.document.createElement("script");
                    g.onreadystatechange = function () {
                      v(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
                    }, a.document.documentElement.appendChild(g);
                  } : s = function () {
                    setTimeout(v, 0);
                  };
                  var d,
                    p = [];
                  function v() {
                    d = !0;
                    for (var g, b, m = p.length; m;) {
                      for (b = p, p = [], g = -1; ++g < m;) b[g]();
                      m = p.length;
                    }
                    d = !1;
                  }
                  r.exports = h;
                  function h(g) {
                    p.push(g) === 1 && !d && s();
                  }
                }).call(this, typeof qt != "undefined" ? qt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
              }, {}],
              2: [function (t, r, i) {
                var a = t(1);
                function l() {}
                var s = {},
                  o = ["REJECTED"],
                  c = ["FULFILLED"],
                  u = ["PENDING"];
                r.exports = f;
                function f(O) {
                  if (typeof O != "function") throw new TypeError("resolver must be a function");
                  this.state = u, this.queue = [], this.outcome = void 0, O !== l && h(this, O);
                }
                f.prototype.catch = function (O) {
                  return this.then(null, O);
                }, f.prototype.then = function (O, y) {
                  if (typeof O != "function" && this.state === c || typeof y != "function" && this.state === o) return this;
                  var w = new this.constructor(l);
                  if (this.state !== u) {
                    var A = this.state === c ? O : y;
                    p(w, A, this.outcome);
                  } else this.queue.push(new d(w, O, y));
                  return w;
                };
                function d(O, y, w) {
                  this.promise = O, typeof y == "function" && (this.onFulfilled = y, this.callFulfilled = this.otherCallFulfilled), typeof w == "function" && (this.onRejected = w, this.callRejected = this.otherCallRejected);
                }
                d.prototype.callFulfilled = function (O) {
                  s.resolve(this.promise, O);
                }, d.prototype.otherCallFulfilled = function (O) {
                  p(this.promise, this.onFulfilled, O);
                }, d.prototype.callRejected = function (O) {
                  s.reject(this.promise, O);
                }, d.prototype.otherCallRejected = function (O) {
                  p(this.promise, this.onRejected, O);
                };
                function p(O, y, w) {
                  a(function () {
                    var A;
                    try {
                      A = y(w);
                    } catch (R) {
                      return s.reject(O, R);
                    }
                    A === O ? s.reject(O, new TypeError("Cannot resolve promise with itself")) : s.resolve(O, A);
                  });
                }
                s.resolve = function (O, y) {
                  var w = g(v, y);
                  if (w.status === "error") return s.reject(O, w.value);
                  var A = w.value;
                  if (A) h(O, A);else {
                    O.state = c, O.outcome = y;
                    for (var R = -1, T = O.queue.length; ++R < T;) O.queue[R].callFulfilled(y);
                  }
                  return O;
                }, s.reject = function (O, y) {
                  O.state = o, O.outcome = y;
                  for (var w = -1, A = O.queue.length; ++w < A;) O.queue[w].callRejected(y);
                  return O;
                };
                function v(O) {
                  var y = O && O.then;
                  if (O && (typeof O == "object" || typeof O == "function") && typeof y == "function") return function () {
                    y.apply(O, arguments);
                  };
                }
                function h(O, y) {
                  var w = !1;
                  function A(M) {
                    w || (w = !0, s.reject(O, M));
                  }
                  function R(M) {
                    w || (w = !0, s.resolve(O, M));
                  }
                  function T() {
                    y(R, A);
                  }
                  var D = g(T);
                  D.status === "error" && A(D.value);
                }
                function g(O, y) {
                  var w = {};
                  try {
                    w.value = O(y), w.status = "success";
                  } catch (A) {
                    w.status = "error", w.value = A;
                  }
                  return w;
                }
                f.resolve = b;
                function b(O) {
                  return O instanceof this ? O : s.resolve(new this(l), O);
                }
                f.reject = m;
                function m(O) {
                  var y = new this(l);
                  return s.reject(y, O);
                }
                f.all = _;
                function _(O) {
                  var y = this;
                  if (Object.prototype.toString.call(O) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                  var w = O.length,
                    A = !1;
                  if (!w) return this.resolve([]);
                  for (var R = new Array(w), T = 0, D = -1, M = new this(l); ++D < w;) q(O[D], D);
                  return M;
                  function q(W, x) {
                    y.resolve(W).then(C, function (B) {
                      A || (A = !0, s.reject(M, B));
                    });
                    function C(B) {
                      R[x] = B, ++T === w && !A && (A = !0, s.resolve(M, R));
                    }
                  }
                }
                f.race = N;
                function N(O) {
                  var y = this;
                  if (Object.prototype.toString.call(O) !== "[object Array]") return this.reject(new TypeError("must be an array"));
                  var w = O.length,
                    A = !1;
                  if (!w) return this.resolve([]);
                  for (var R = -1, T = new this(l); ++R < w;) D(O[R]);
                  return T;
                  function D(M) {
                    y.resolve(M).then(function (q) {
                      A || (A = !0, s.resolve(T, q));
                    }, function (q) {
                      A || (A = !0, s.reject(T, q));
                    });
                  }
                }
              }, {
                1: 1
              }],
              3: [function (t, r, i) {
                (function (a) {
                  typeof a.Promise != "function" && (a.Promise = t(2));
                }).call(this, typeof qt != "undefined" ? qt : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
              }, {
                2: 2
              }],
              4: [function (t, r, i) {
                var a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (I) {
                  return typeof I;
                } : function (I) {
                  return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
                };
                function l(I, j) {
                  if (!(I instanceof j)) throw new TypeError("Cannot call a class as a function");
                }
                function s() {
                  try {
                    if (typeof indexedDB != "undefined") return indexedDB;
                    if (typeof webkitIndexedDB != "undefined") return webkitIndexedDB;
                    if (typeof mozIndexedDB != "undefined") return mozIndexedDB;
                    if (typeof OIndexedDB != "undefined") return OIndexedDB;
                    if (typeof msIndexedDB != "undefined") return msIndexedDB;
                  } catch {
                    return;
                  }
                }
                var o = s();
                function c() {
                  try {
                    if (!o || !o.open) return !1;
                    var I = typeof openDatabase != "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform),
                      j = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
                    return (!I || j) && typeof indexedDB != "undefined" && typeof IDBKeyRange != "undefined";
                  } catch {
                    return !1;
                  }
                }
                function u(I, j) {
                  I = I || [], j = j || {};
                  try {
                    return new Blob(I, j);
                  } catch (Y) {
                    if (Y.name !== "TypeError") throw Y;
                    for (var K = typeof BlobBuilder != "undefined" ? BlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : WebKitBlobBuilder, Q = new K(), te = 0; te < I.length; te += 1) Q.append(I[te]);
                    return Q.getBlob(j.type);
                  }
                }
                typeof Promise == "undefined" && t(3);
                var f = Promise;
                function d(I, j) {
                  j && I.then(function (K) {
                    j(null, K);
                  }, function (K) {
                    j(K);
                  });
                }
                function p(I, j, K) {
                  typeof j == "function" && I.then(j), typeof K == "function" && I.catch(K);
                }
                function v(I) {
                  return typeof I != "string" && (console.warn(I + " used as a key, but it is not a string."), I = String(I)), I;
                }
                function h() {
                  if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
                }
                var g = "local-forage-detect-blob-support",
                  b = void 0,
                  m = {},
                  _ = Object.prototype.toString,
                  N = "readonly",
                  O = "readwrite";
                function y(I) {
                  for (var j = I.length, K = new ArrayBuffer(j), Q = new Uint8Array(K), te = 0; te < j; te++) Q[te] = I.charCodeAt(te);
                  return K;
                }
                function w(I) {
                  return new f(function (j) {
                    var K = I.transaction(g, O),
                      Q = u([""]);
                    K.objectStore(g).put(Q, "key"), K.onabort = function (te) {
                      te.preventDefault(), te.stopPropagation(), j(!1);
                    }, K.oncomplete = function () {
                      var te = navigator.userAgent.match(/Chrome\/(\d+)/),
                        Y = navigator.userAgent.match(/Edge\//);
                      j(Y || !te || parseInt(te[1], 10) >= 43);
                    };
                  }).catch(function () {
                    return !1;
                  });
                }
                function A(I) {
                  return typeof b == "boolean" ? f.resolve(b) : w(I).then(function (j) {
                    return b = j, b;
                  });
                }
                function R(I) {
                  var j = m[I.name],
                    K = {};
                  K.promise = new f(function (Q, te) {
                    K.resolve = Q, K.reject = te;
                  }), j.deferredOperations.push(K), j.dbReady ? j.dbReady = j.dbReady.then(function () {
                    return K.promise;
                  }) : j.dbReady = K.promise;
                }
                function T(I) {
                  var j = m[I.name],
                    K = j.deferredOperations.pop();
                  if (K) return K.resolve(), K.promise;
                }
                function D(I, j) {
                  var K = m[I.name],
                    Q = K.deferredOperations.pop();
                  if (Q) return Q.reject(j), Q.promise;
                }
                function M(I, j) {
                  return new f(function (K, Q) {
                    if (m[I.name] = m[I.name] || se(), I.db) if (j) R(I), I.db.close();else return K(I.db);
                    var te = [I.name];
                    j && te.push(I.version);
                    var Y = o.open.apply(o, te);
                    j && (Y.onupgradeneeded = function (ue) {
                      var F = Y.result;
                      try {
                        F.createObjectStore(I.storeName), ue.oldVersion <= 1 && F.createObjectStore(g);
                      } catch (pe) {
                        if (pe.name === "ConstraintError") console.warn('The database "' + I.name + '" has been upgraded from version ' + ue.oldVersion + " to version " + ue.newVersion + ', but the storage "' + I.storeName + '" already exists.');else throw pe;
                      }
                    }), Y.onerror = function (ue) {
                      ue.preventDefault(), Q(Y.error);
                    }, Y.onsuccess = function () {
                      var ue = Y.result;
                      ue.onversionchange = function (F) {
                        F.target.close();
                      }, K(ue), T(I);
                    };
                  });
                }
                function q(I) {
                  return M(I, !1);
                }
                function W(I) {
                  return M(I, !0);
                }
                function x(I, j) {
                  if (!I.db) return !0;
                  var K = !I.db.objectStoreNames.contains(I.storeName),
                    Q = I.version < I.db.version,
                    te = I.version > I.db.version;
                  if (Q && (I.version !== j && console.warn('The database "' + I.name + `" can't be downgraded from version ` + I.db.version + " to version " + I.version + "."), I.version = I.db.version), te || K) {
                    if (K) {
                      var Y = I.db.version + 1;
                      Y > I.version && (I.version = Y);
                    }
                    return !0;
                  }
                  return !1;
                }
                function C(I) {
                  return new f(function (j, K) {
                    var Q = new FileReader();
                    Q.onerror = K, Q.onloadend = function (te) {
                      var Y = btoa(te.target.result || "");
                      j({
                        __local_forage_encoded_blob: !0,
                        data: Y,
                        type: I.type
                      });
                    }, Q.readAsBinaryString(I);
                  });
                }
                function B(I) {
                  var j = y(atob(I.data));
                  return u([j], {
                    type: I.type
                  });
                }
                function X(I) {
                  return I && I.__local_forage_encoded_blob;
                }
                function J(I) {
                  var j = this,
                    K = j._initReady().then(function () {
                      var Q = m[j._dbInfo.name];
                      if (Q && Q.dbReady) return Q.dbReady;
                    });
                  return p(K, I, I), K;
                }
                function V(I) {
                  R(I);
                  for (var j = m[I.name], K = j.forages, Q = 0; Q < K.length; Q++) {
                    var te = K[Q];
                    te._dbInfo.db && (te._dbInfo.db.close(), te._dbInfo.db = null);
                  }
                  return I.db = null, q(I).then(function (Y) {
                    return I.db = Y, x(I) ? W(I) : Y;
                  }).then(function (Y) {
                    I.db = j.db = Y;
                    for (var ue = 0; ue < K.length; ue++) K[ue]._dbInfo.db = Y;
                  }).catch(function (Y) {
                    throw D(I, Y), Y;
                  });
                }
                function $(I, j, K, Q) {
                  Q === void 0 && (Q = 1);
                  try {
                    var te = I.db.transaction(I.storeName, j);
                    K(null, te);
                  } catch (Y) {
                    if (Q > 0 && (!I.db || Y.name === "InvalidStateError" || Y.name === "NotFoundError")) return f.resolve().then(function () {
                      if (!I.db || Y.name === "NotFoundError" && !I.db.objectStoreNames.contains(I.storeName) && I.version <= I.db.version) return I.db && (I.version = I.db.version + 1), W(I);
                    }).then(function () {
                      return V(I).then(function () {
                        $(I, j, K, Q - 1);
                      });
                    }).catch(K);
                    K(Y);
                  }
                }
                function se() {
                  return {
                    forages: [],
                    db: null,
                    dbReady: null,
                    deferredOperations: []
                  };
                }
                function ne(I) {
                  var j = this,
                    K = {
                      db: null
                    };
                  if (I) for (var Q in I) K[Q] = I[Q];
                  var te = m[K.name];
                  te || (te = se(), m[K.name] = te), te.forages.push(j), j._initReady || (j._initReady = j.ready, j.ready = J);
                  var Y = [];
                  function ue() {
                    return f.resolve();
                  }
                  for (var F = 0; F < te.forages.length; F++) {
                    var pe = te.forages[F];
                    pe !== j && Y.push(pe._initReady().catch(ue));
                  }
                  var ge = te.forages.slice(0);
                  return f.all(Y).then(function () {
                    return K.db = te.db, q(K);
                  }).then(function (ve) {
                    return K.db = ve, x(K, j._defaultConfig.version) ? W(K) : ve;
                  }).then(function (ve) {
                    K.db = te.db = ve, j._dbInfo = K;
                    for (var xe = 0; xe < ge.length; xe++) {
                      var De = ge[xe];
                      De !== j && (De._dbInfo.db = K.db, De._dbInfo.version = K.version);
                    }
                  });
                }
                function oe(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = new f(function (te, Y) {
                    K.ready().then(function () {
                      $(K._dbInfo, N, function (ue, F) {
                        if (ue) return Y(ue);
                        try {
                          var pe = F.objectStore(K._dbInfo.storeName),
                            ge = pe.get(I);
                          ge.onsuccess = function () {
                            var ve = ge.result;
                            ve === void 0 && (ve = null), X(ve) && (ve = B(ve)), te(ve);
                          }, ge.onerror = function () {
                            Y(ge.error);
                          };
                        } catch (ve) {
                          Y(ve);
                        }
                      });
                    }).catch(Y);
                  });
                  return d(Q, j), Q;
                }
                function ye(I, j) {
                  var K = this,
                    Q = new f(function (te, Y) {
                      K.ready().then(function () {
                        $(K._dbInfo, N, function (ue, F) {
                          if (ue) return Y(ue);
                          try {
                            var pe = F.objectStore(K._dbInfo.storeName),
                              ge = pe.openCursor(),
                              ve = 1;
                            ge.onsuccess = function () {
                              var xe = ge.result;
                              if (xe) {
                                var De = xe.value;
                                X(De) && (De = B(De));
                                var He = I(De, xe.key, ve++);
                                He !== void 0 ? te(He) : xe.continue();
                              } else te();
                            }, ge.onerror = function () {
                              Y(ge.error);
                            };
                          } catch (xe) {
                            Y(xe);
                          }
                        });
                      }).catch(Y);
                    });
                  return d(Q, j), Q;
                }
                function Te(I, j, K) {
                  var Q = this;
                  I = v(I);
                  var te = new f(function (Y, ue) {
                    var F;
                    Q.ready().then(function () {
                      return F = Q._dbInfo, _.call(j) === "[object Blob]" ? A(F.db).then(function (pe) {
                        return pe ? j : C(j);
                      }) : j;
                    }).then(function (pe) {
                      $(Q._dbInfo, O, function (ge, ve) {
                        if (ge) return ue(ge);
                        try {
                          var xe = ve.objectStore(Q._dbInfo.storeName);
                          pe === null && (pe = void 0);
                          var De = xe.put(pe, I);
                          ve.oncomplete = function () {
                            pe === void 0 && (pe = null), Y(pe);
                          }, ve.onabort = ve.onerror = function () {
                            var He = De.error ? De.error : De.transaction.error;
                            ue(He);
                          };
                        } catch (He) {
                          ue(He);
                        }
                      });
                    }).catch(ue);
                  });
                  return d(te, K), te;
                }
                function ae(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = new f(function (te, Y) {
                    K.ready().then(function () {
                      $(K._dbInfo, O, function (ue, F) {
                        if (ue) return Y(ue);
                        try {
                          var pe = F.objectStore(K._dbInfo.storeName),
                            ge = pe.delete(I);
                          F.oncomplete = function () {
                            te();
                          }, F.onerror = function () {
                            Y(ge.error);
                          }, F.onabort = function () {
                            var ve = ge.error ? ge.error : ge.transaction.error;
                            Y(ve);
                          };
                        } catch (ve) {
                          Y(ve);
                        }
                      });
                    }).catch(Y);
                  });
                  return d(Q, j), Q;
                }
                function G(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        $(j._dbInfo, O, function (Y, ue) {
                          if (Y) return te(Y);
                          try {
                            var F = ue.objectStore(j._dbInfo.storeName),
                              pe = F.clear();
                            ue.oncomplete = function () {
                              Q();
                            }, ue.onabort = ue.onerror = function () {
                              var ge = pe.error ? pe.error : pe.transaction.error;
                              te(ge);
                            };
                          } catch (ge) {
                            te(ge);
                          }
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function Z(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        $(j._dbInfo, N, function (Y, ue) {
                          if (Y) return te(Y);
                          try {
                            var F = ue.objectStore(j._dbInfo.storeName),
                              pe = F.count();
                            pe.onsuccess = function () {
                              Q(pe.result);
                            }, pe.onerror = function () {
                              te(pe.error);
                            };
                          } catch (ge) {
                            te(ge);
                          }
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function S(I, j) {
                  var K = this,
                    Q = new f(function (te, Y) {
                      if (I < 0) {
                        te(null);
                        return;
                      }
                      K.ready().then(function () {
                        $(K._dbInfo, N, function (ue, F) {
                          if (ue) return Y(ue);
                          try {
                            var pe = F.objectStore(K._dbInfo.storeName),
                              ge = !1,
                              ve = pe.openKeyCursor();
                            ve.onsuccess = function () {
                              var xe = ve.result;
                              if (!xe) {
                                te(null);
                                return;
                              }
                              I === 0 || ge ? te(xe.key) : (ge = !0, xe.advance(I));
                            }, ve.onerror = function () {
                              Y(ve.error);
                            };
                          } catch (xe) {
                            Y(xe);
                          }
                        });
                      }).catch(Y);
                    });
                  return d(Q, j), Q;
                }
                function ee(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        $(j._dbInfo, N, function (Y, ue) {
                          if (Y) return te(Y);
                          try {
                            var F = ue.objectStore(j._dbInfo.storeName),
                              pe = F.openKeyCursor(),
                              ge = [];
                            pe.onsuccess = function () {
                              var ve = pe.result;
                              if (!ve) {
                                Q(ge);
                                return;
                              }
                              ge.push(ve.key), ve.continue();
                            }, pe.onerror = function () {
                              te(pe.error);
                            };
                          } catch (ve) {
                            te(ve);
                          }
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function Ce(I, j) {
                  j = h.apply(this, arguments);
                  var K = this.config();
                  I = typeof I != "function" && I || {}, I.name || (I.name = I.name || K.name, I.storeName = I.storeName || K.storeName);
                  var Q = this,
                    te;
                  if (!I.name) te = f.reject("Invalid arguments");else {
                    var Y = I.name === K.name && Q._dbInfo.db,
                      ue = Y ? f.resolve(Q._dbInfo.db) : q(I).then(function (F) {
                        var pe = m[I.name],
                          ge = pe.forages;
                        pe.db = F;
                        for (var ve = 0; ve < ge.length; ve++) ge[ve]._dbInfo.db = F;
                        return F;
                      });
                    I.storeName ? te = ue.then(function (F) {
                      if (F.objectStoreNames.contains(I.storeName)) {
                        var pe = F.version + 1;
                        R(I);
                        var ge = m[I.name],
                          ve = ge.forages;
                        F.close();
                        for (var xe = 0; xe < ve.length; xe++) {
                          var De = ve[xe];
                          De._dbInfo.db = null, De._dbInfo.version = pe;
                        }
                        var He = new f(function (Qe, Ye) {
                          var st = o.open(I.name, pe);
                          st.onerror = function (Nt) {
                            var Wt = st.result;
                            Wt.close(), Ye(Nt);
                          }, st.onupgradeneeded = function () {
                            var Nt = st.result;
                            Nt.deleteObjectStore(I.storeName);
                          }, st.onsuccess = function () {
                            var Nt = st.result;
                            Nt.close(), Qe(Nt);
                          };
                        });
                        return He.then(function (Qe) {
                          ge.db = Qe;
                          for (var Ye = 0; Ye < ve.length; Ye++) {
                            var st = ve[Ye];
                            st._dbInfo.db = Qe, T(st._dbInfo);
                          }
                        }).catch(function (Qe) {
                          throw (D(I, Qe) || f.resolve()).catch(function () {}), Qe;
                        });
                      }
                    }) : te = ue.then(function (F) {
                      R(I);
                      var pe = m[I.name],
                        ge = pe.forages;
                      F.close();
                      for (var ve = 0; ve < ge.length; ve++) {
                        var xe = ge[ve];
                        xe._dbInfo.db = null;
                      }
                      var De = new f(function (He, Qe) {
                        var Ye = o.deleteDatabase(I.name);
                        Ye.onerror = function () {
                          var st = Ye.result;
                          st && st.close(), Qe(Ye.error);
                        }, Ye.onblocked = function () {
                          console.warn('dropInstance blocked for database "' + I.name + '" until all open connections are closed');
                        }, Ye.onsuccess = function () {
                          var st = Ye.result;
                          st && st.close(), He(st);
                        };
                      });
                      return De.then(function (He) {
                        pe.db = He;
                        for (var Qe = 0; Qe < ge.length; Qe++) {
                          var Ye = ge[Qe];
                          T(Ye._dbInfo);
                        }
                      }).catch(function (He) {
                        throw (D(I, He) || f.resolve()).catch(function () {}), He;
                      });
                    });
                  }
                  return d(te, j), te;
                }
                var Oe = {
                  _driver: "asyncStorage",
                  _initStorage: ne,
                  _support: c(),
                  iterate: ye,
                  getItem: oe,
                  setItem: Te,
                  removeItem: ae,
                  clear: G,
                  length: Z,
                  key: S,
                  keys: ee,
                  dropInstance: Ce
                };
                function Xe() {
                  return typeof openDatabase == "function";
                }
                var Ve = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                  at = "~~local_forage_type~",
                  ht = /^~~local_forage_type~([^~]+)~/,
                  Et = "__lfsc__:",
                  vt = Et.length,
                  It = "arbf",
                  yt = "blob",
                  ut = "si08",
                  rt = "ui08",
                  pt = "uic8",
                  Ct = "si16",
                  Pe = "si32",
                  Fe = "ur16",
                  ke = "ui32",
                  ze = "fl32",
                  Bt = "fl64",
                  mt = vt + It.length,
                  Je = Object.prototype.toString;
                function Ke(I) {
                  var j = I.length * .75,
                    K = I.length,
                    Q,
                    te = 0,
                    Y,
                    ue,
                    F,
                    pe;
                  I[I.length - 1] === "=" && (j--, I[I.length - 2] === "=" && j--);
                  var ge = new ArrayBuffer(j),
                    ve = new Uint8Array(ge);
                  for (Q = 0; Q < K; Q += 4) Y = Ve.indexOf(I[Q]), ue = Ve.indexOf(I[Q + 1]), F = Ve.indexOf(I[Q + 2]), pe = Ve.indexOf(I[Q + 3]), ve[te++] = Y << 2 | ue >> 4, ve[te++] = (ue & 15) << 4 | F >> 2, ve[te++] = (F & 3) << 6 | pe & 63;
                  return ge;
                }
                function St(I) {
                  var j = new Uint8Array(I),
                    K = "",
                    Q;
                  for (Q = 0; Q < j.length; Q += 3) K += Ve[j[Q] >> 2], K += Ve[(j[Q] & 3) << 4 | j[Q + 1] >> 4], K += Ve[(j[Q + 1] & 15) << 2 | j[Q + 2] >> 6], K += Ve[j[Q + 2] & 63];
                  return j.length % 3 === 2 ? K = K.substring(0, K.length - 1) + "=" : j.length % 3 === 1 && (K = K.substring(0, K.length - 2) + "=="), K;
                }
                function Gt(I, j) {
                  var K = "";
                  if (I && (K = Je.call(I)), I && (K === "[object ArrayBuffer]" || I.buffer && Je.call(I.buffer) === "[object ArrayBuffer]")) {
                    var Q,
                      te = Et;
                    I instanceof ArrayBuffer ? (Q = I, te += It) : (Q = I.buffer, K === "[object Int8Array]" ? te += ut : K === "[object Uint8Array]" ? te += rt : K === "[object Uint8ClampedArray]" ? te += pt : K === "[object Int16Array]" ? te += Ct : K === "[object Uint16Array]" ? te += Fe : K === "[object Int32Array]" ? te += Pe : K === "[object Uint32Array]" ? te += ke : K === "[object Float32Array]" ? te += ze : K === "[object Float64Array]" ? te += Bt : j(new Error("Failed to get type for BinaryArray"))), j(te + St(Q));
                  } else if (K === "[object Blob]") {
                    var Y = new FileReader();
                    Y.onload = function () {
                      var ue = at + I.type + "~" + St(this.result);
                      j(Et + yt + ue);
                    }, Y.readAsArrayBuffer(I);
                  } else try {
                    j(JSON.stringify(I));
                  } catch (ue) {
                    console.error("Couldn't convert value into a JSON string: ", I), j(null, ue);
                  }
                }
                function hn(I) {
                  if (I.substring(0, vt) !== Et) return JSON.parse(I);
                  var j = I.substring(mt),
                    K = I.substring(vt, mt),
                    Q;
                  if (K === yt && ht.test(j)) {
                    var te = j.match(ht);
                    Q = te[1], j = j.substring(te[0].length);
                  }
                  var Y = Ke(j);
                  switch (K) {
                    case It:
                      return Y;
                    case yt:
                      return u([Y], {
                        type: Q
                      });
                    case ut:
                      return new Int8Array(Y);
                    case rt:
                      return new Uint8Array(Y);
                    case pt:
                      return new Uint8ClampedArray(Y);
                    case Ct:
                      return new Int16Array(Y);
                    case Fe:
                      return new Uint16Array(Y);
                    case Pe:
                      return new Int32Array(Y);
                    case ke:
                      return new Uint32Array(Y);
                    case ze:
                      return new Float32Array(Y);
                    case Bt:
                      return new Float64Array(Y);
                    default:
                      throw new Error("Unkown type: " + K);
                  }
                }
                var On = {
                  serialize: Gt,
                  deserialize: hn,
                  stringToBuffer: Ke,
                  bufferToString: St
                };
                function An(I, j, K, Q) {
                  I.executeSql("CREATE TABLE IF NOT EXISTS " + j.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], K, Q);
                }
                function Gn(I) {
                  var j = this,
                    K = {
                      db: null
                    };
                  if (I) for (var Q in I) K[Q] = typeof I[Q] != "string" ? I[Q].toString() : I[Q];
                  var te = new f(function (Y, ue) {
                    try {
                      K.db = openDatabase(K.name, String(K.version), K.description, K.size);
                    } catch (F) {
                      return ue(F);
                    }
                    K.db.transaction(function (F) {
                      An(F, K, function () {
                        j._dbInfo = K, Y();
                      }, function (pe, ge) {
                        ue(ge);
                      });
                    }, ue);
                  });
                  return K.serializer = On, te;
                }
                function mn(I, j, K, Q, te, Y) {
                  I.executeSql(K, Q, te, function (ue, F) {
                    F.code === F.SYNTAX_ERR ? ue.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [j.storeName], function (pe, ge) {
                      ge.rows.length ? Y(pe, F) : An(pe, j, function () {
                        pe.executeSql(K, Q, te, Y);
                      }, Y);
                    }, Y) : Y(ue, F);
                  }, Y);
                }
                function ni(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = new f(function (te, Y) {
                    K.ready().then(function () {
                      var ue = K._dbInfo;
                      ue.db.transaction(function (F) {
                        mn(F, ue, "SELECT * FROM " + ue.storeName + " WHERE key = ? LIMIT 1", [I], function (pe, ge) {
                          var ve = ge.rows.length ? ge.rows.item(0).value : null;
                          ve && (ve = ue.serializer.deserialize(ve)), te(ve);
                        }, function (pe, ge) {
                          Y(ge);
                        });
                      });
                    }).catch(Y);
                  });
                  return d(Q, j), Q;
                }
                function Di(I, j) {
                  var K = this,
                    Q = new f(function (te, Y) {
                      K.ready().then(function () {
                        var ue = K._dbInfo;
                        ue.db.transaction(function (F) {
                          mn(F, ue, "SELECT * FROM " + ue.storeName, [], function (pe, ge) {
                            for (var ve = ge.rows, xe = ve.length, De = 0; De < xe; De++) {
                              var He = ve.item(De),
                                Qe = He.value;
                              if (Qe && (Qe = ue.serializer.deserialize(Qe)), Qe = I(Qe, He.key, De + 1), Qe !== void 0) {
                                te(Qe);
                                return;
                              }
                            }
                            te();
                          }, function (pe, ge) {
                            Y(ge);
                          });
                        });
                      }).catch(Y);
                    });
                  return d(Q, j), Q;
                }
                function rn(I, j, K, Q) {
                  var te = this;
                  I = v(I);
                  var Y = new f(function (ue, F) {
                    te.ready().then(function () {
                      j === void 0 && (j = null);
                      var pe = j,
                        ge = te._dbInfo;
                      ge.serializer.serialize(j, function (ve, xe) {
                        xe ? F(xe) : ge.db.transaction(function (De) {
                          mn(De, ge, "INSERT OR REPLACE INTO " + ge.storeName + " (key, value) VALUES (?, ?)", [I, ve], function () {
                            ue(pe);
                          }, function (He, Qe) {
                            F(Qe);
                          });
                        }, function (De) {
                          if (De.code === De.QUOTA_ERR) {
                            if (Q > 0) {
                              ue(rn.apply(te, [I, pe, K, Q - 1]));
                              return;
                            }
                            F(De);
                          }
                        });
                      });
                    }).catch(F);
                  });
                  return d(Y, K), Y;
                }
                function Lt(I, j, K) {
                  return rn.apply(this, [I, j, K, 1]);
                }
                function Ht(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = new f(function (te, Y) {
                    K.ready().then(function () {
                      var ue = K._dbInfo;
                      ue.db.transaction(function (F) {
                        mn(F, ue, "DELETE FROM " + ue.storeName + " WHERE key = ?", [I], function () {
                          te();
                        }, function (pe, ge) {
                          Y(ge);
                        });
                      });
                    }).catch(Y);
                  });
                  return d(Q, j), Q;
                }
                function jt(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        var Y = j._dbInfo;
                        Y.db.transaction(function (ue) {
                          mn(ue, Y, "DELETE FROM " + Y.storeName, [], function () {
                            Q();
                          }, function (F, pe) {
                            te(pe);
                          });
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function $t(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        var Y = j._dbInfo;
                        Y.db.transaction(function (ue) {
                          mn(ue, Y, "SELECT COUNT(key) as c FROM " + Y.storeName, [], function (F, pe) {
                            var ge = pe.rows.item(0).c;
                            Q(ge);
                          }, function (F, pe) {
                            te(pe);
                          });
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function Qt(I, j) {
                  var K = this,
                    Q = new f(function (te, Y) {
                      K.ready().then(function () {
                        var ue = K._dbInfo;
                        ue.db.transaction(function (F) {
                          mn(F, ue, "SELECT key FROM " + ue.storeName + " WHERE id = ? LIMIT 1", [I + 1], function (pe, ge) {
                            var ve = ge.rows.length ? ge.rows.item(0).key : null;
                            te(ve);
                          }, function (pe, ge) {
                            Y(ge);
                          });
                        });
                      }).catch(Y);
                    });
                  return d(Q, j), Q;
                }
                function Yt(I) {
                  var j = this,
                    K = new f(function (Q, te) {
                      j.ready().then(function () {
                        var Y = j._dbInfo;
                        Y.db.transaction(function (ue) {
                          mn(ue, Y, "SELECT key FROM " + Y.storeName, [], function (F, pe) {
                            for (var ge = [], ve = 0; ve < pe.rows.length; ve++) ge.push(pe.rows.item(ve).key);
                            Q(ge);
                          }, function (F, pe) {
                            te(pe);
                          });
                        });
                      }).catch(te);
                    });
                  return d(K, I), K;
                }
                function ln(I) {
                  return new f(function (j, K) {
                    I.transaction(function (Q) {
                      Q.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (te, Y) {
                        for (var ue = [], F = 0; F < Y.rows.length; F++) ue.push(Y.rows.item(F).name);
                        j({
                          db: I,
                          storeNames: ue
                        });
                      }, function (te, Y) {
                        K(Y);
                      });
                    }, function (Q) {
                      K(Q);
                    });
                  });
                }
                function Ot(I, j) {
                  j = h.apply(this, arguments);
                  var K = this.config();
                  I = typeof I != "function" && I || {}, I.name || (I.name = I.name || K.name, I.storeName = I.storeName || K.storeName);
                  var Q = this,
                    te;
                  return I.name ? te = new f(function (Y) {
                    var ue;
                    I.name === K.name ? ue = Q._dbInfo.db : ue = openDatabase(I.name, "", "", 0), I.storeName ? Y({
                      db: ue,
                      storeNames: [I.storeName]
                    }) : Y(ln(ue));
                  }).then(function (Y) {
                    return new f(function (ue, F) {
                      Y.db.transaction(function (pe) {
                        function ge(He) {
                          return new f(function (Qe, Ye) {
                            pe.executeSql("DROP TABLE IF EXISTS " + He, [], function () {
                              Qe();
                            }, function (st, Nt) {
                              Ye(Nt);
                            });
                          });
                        }
                        for (var ve = [], xe = 0, De = Y.storeNames.length; xe < De; xe++) ve.push(ge(Y.storeNames[xe]));
                        f.all(ve).then(function () {
                          ue();
                        }).catch(function (He) {
                          F(He);
                        });
                      }, function (pe) {
                        F(pe);
                      });
                    });
                  }) : te = f.reject("Invalid arguments"), d(te, j), te;
                }
                var At = {
                  _driver: "webSQLStorage",
                  _initStorage: Gn,
                  _support: Xe(),
                  iterate: Di,
                  getItem: ni,
                  setItem: Lt,
                  removeItem: Ht,
                  clear: jt,
                  length: $t,
                  key: Qt,
                  keys: Yt,
                  dropInstance: Ot
                };
                function P() {
                  try {
                    return typeof localStorage != "undefined" && "setItem" in localStorage && !!localStorage.setItem;
                  } catch {
                    return !1;
                  }
                }
                function U(I, j) {
                  var K = I.name + "/";
                  return I.storeName !== j.storeName && (K += I.storeName + "/"), K;
                }
                function L() {
                  var I = "_localforage_support_test";
                  try {
                    return localStorage.setItem(I, !0), localStorage.removeItem(I), !1;
                  } catch {
                    return !0;
                  }
                }
                function E() {
                  return !L() || localStorage.length > 0;
                }
                function H(I) {
                  var j = this,
                    K = {};
                  if (I) for (var Q in I) K[Q] = I[Q];
                  return K.keyPrefix = U(I, j._defaultConfig), E() ? (j._dbInfo = K, K.serializer = On, f.resolve()) : f.reject();
                }
                function ie(I) {
                  var j = this,
                    K = j.ready().then(function () {
                      for (var Q = j._dbInfo.keyPrefix, te = localStorage.length - 1; te >= 0; te--) {
                        var Y = localStorage.key(te);
                        Y.indexOf(Q) === 0 && localStorage.removeItem(Y);
                      }
                    });
                  return d(K, I), K;
                }
                function le(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = K.ready().then(function () {
                    var te = K._dbInfo,
                      Y = localStorage.getItem(te.keyPrefix + I);
                    return Y && (Y = te.serializer.deserialize(Y)), Y;
                  });
                  return d(Q, j), Q;
                }
                function me(I, j) {
                  var K = this,
                    Q = K.ready().then(function () {
                      for (var te = K._dbInfo, Y = te.keyPrefix, ue = Y.length, F = localStorage.length, pe = 1, ge = 0; ge < F; ge++) {
                        var ve = localStorage.key(ge);
                        if (ve.indexOf(Y) === 0) {
                          var xe = localStorage.getItem(ve);
                          if (xe && (xe = te.serializer.deserialize(xe)), xe = I(xe, ve.substring(ue), pe++), xe !== void 0) return xe;
                        }
                      }
                    });
                  return d(Q, j), Q;
                }
                function Ee(I, j) {
                  var K = this,
                    Q = K.ready().then(function () {
                      var te = K._dbInfo,
                        Y;
                      try {
                        Y = localStorage.key(I);
                      } catch {
                        Y = null;
                      }
                      return Y && (Y = Y.substring(te.keyPrefix.length)), Y;
                    });
                  return d(Q, j), Q;
                }
                function We(I) {
                  var j = this,
                    K = j.ready().then(function () {
                      for (var Q = j._dbInfo, te = localStorage.length, Y = [], ue = 0; ue < te; ue++) {
                        var F = localStorage.key(ue);
                        F.indexOf(Q.keyPrefix) === 0 && Y.push(F.substring(Q.keyPrefix.length));
                      }
                      return Y;
                    });
                  return d(K, I), K;
                }
                function Ne(I) {
                  var j = this,
                    K = j.keys().then(function (Q) {
                      return Q.length;
                    });
                  return d(K, I), K;
                }
                function Rt(I, j) {
                  var K = this;
                  I = v(I);
                  var Q = K.ready().then(function () {
                    var te = K._dbInfo;
                    localStorage.removeItem(te.keyPrefix + I);
                  });
                  return d(Q, j), Q;
                }
                function Be(I, j, K) {
                  var Q = this;
                  I = v(I);
                  var te = Q.ready().then(function () {
                    j === void 0 && (j = null);
                    var Y = j;
                    return new f(function (ue, F) {
                      var pe = Q._dbInfo;
                      pe.serializer.serialize(j, function (ge, ve) {
                        if (ve) F(ve);else try {
                          localStorage.setItem(pe.keyPrefix + I, ge), ue(Y);
                        } catch (xe) {
                          (xe.name === "QuotaExceededError" || xe.name === "NS_ERROR_DOM_QUOTA_REACHED") && F(xe), F(xe);
                        }
                      });
                    });
                  });
                  return d(te, K), te;
                }
                function Ze(I, j) {
                  if (j = h.apply(this, arguments), I = typeof I != "function" && I || {}, !I.name) {
                    var K = this.config();
                    I.name = I.name || K.name, I.storeName = I.storeName || K.storeName;
                  }
                  var Q = this,
                    te;
                  return I.name ? te = new f(function (Y) {
                    I.storeName ? Y(U(I, Q._defaultConfig)) : Y(I.name + "/");
                  }).then(function (Y) {
                    for (var ue = localStorage.length - 1; ue >= 0; ue--) {
                      var F = localStorage.key(ue);
                      F.indexOf(Y) === 0 && localStorage.removeItem(F);
                    }
                  }) : te = f.reject("Invalid arguments"), d(te, j), te;
                }
                var nt = {
                    _driver: "localStorageWrapper",
                    _initStorage: H,
                    _support: P(),
                    iterate: me,
                    getItem: le,
                    setItem: Be,
                    removeItem: Rt,
                    clear: ie,
                    length: Ne,
                    key: Ee,
                    keys: We,
                    dropInstance: Ze
                  },
                  ot = function (j, K) {
                    return j === K || typeof j == "number" && typeof K == "number" && isNaN(j) && isNaN(K);
                  },
                  it = function (j, K) {
                    for (var Q = j.length, te = 0; te < Q;) {
                      if (ot(j[te], K)) return !0;
                      te++;
                    }
                    return !1;
                  },
                  et = Array.isArray || function (I) {
                    return Object.prototype.toString.call(I) === "[object Array]";
                  },
                  $e = {},
                  tt = {},
                  Ie = {
                    INDEXEDDB: Oe,
                    WEBSQL: At,
                    LOCALSTORAGE: nt
                  },
                  qe = [Ie.INDEXEDDB._driver, Ie.WEBSQL._driver, Ie.LOCALSTORAGE._driver],
                  Ae = ["dropInstance"],
                  Me = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Ae),
                  je = {
                    description: "",
                    driver: qe.slice(),
                    name: "localforage",
                    size: 4980736,
                    storeName: "keyvaluepairs",
                    version: 1
                  };
                function Re(I, j) {
                  I[j] = function () {
                    var K = arguments;
                    return I.ready().then(function () {
                      return I[j].apply(I, K);
                    });
                  };
                }
                function fe() {
                  for (var I = 1; I < arguments.length; I++) {
                    var j = arguments[I];
                    if (j) for (var K in j) j.hasOwnProperty(K) && (et(j[K]) ? arguments[0][K] = j[K].slice() : arguments[0][K] = j[K]);
                  }
                  return arguments[0];
                }
                var he = function () {
                    function I(j) {
                      l(this, I);
                      for (var K in Ie) if (Ie.hasOwnProperty(K)) {
                        var Q = Ie[K],
                          te = Q._driver;
                        this[K] = te, $e[te] || this.defineDriver(Q);
                      }
                      this._defaultConfig = fe({}, je), this._config = fe({}, this._defaultConfig, j), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () {});
                    }
                    return I.prototype.config = function (K) {
                      if ((typeof K == "undefined" ? "undefined" : a(K)) === "object") {
                        if (this._ready) return new Error("Can't call config() after localforage has been used.");
                        for (var Q in K) {
                          if (Q === "storeName" && (K[Q] = K[Q].replace(/\W/g, "_")), Q === "version" && typeof K[Q] != "number") return new Error("Database version must be a number.");
                          this._config[Q] = K[Q];
                        }
                        return "driver" in K && K.driver ? this.setDriver(this._config.driver) : !0;
                      } else return typeof K == "string" ? this._config[K] : this._config;
                    }, I.prototype.defineDriver = function (K, Q, te) {
                      var Y = new f(function (ue, F) {
                        try {
                          var pe = K._driver,
                            ge = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                          if (!K._driver) {
                            F(ge);
                            return;
                          }
                          for (var ve = Me.concat("_initStorage"), xe = 0, De = ve.length; xe < De; xe++) {
                            var He = ve[xe],
                              Qe = !it(Ae, He);
                            if ((Qe || K[He]) && typeof K[He] != "function") {
                              F(ge);
                              return;
                            }
                          }
                          var Ye = function () {
                            for (var Wt = function (K2) {
                                return function () {
                                  var L2 = new Error("Method " + K2 + " is not implemented by the current driver"),
                                    Jb = f.reject(L2);
                                  return d(Jb, arguments[arguments.length - 1]), Jb;
                                };
                              }, on = 0, Rn = Ae.length; on < Rn; on++) {
                              var bn = Ae[on];
                              K[bn] || (K[bn] = Wt(bn));
                            }
                          };
                          Ye();
                          var st = function (Wt) {
                            $e[pe] && console.info("Redefining LocalForage driver: " + pe), $e[pe] = K, tt[pe] = Wt, ue();
                          };
                          "_support" in K ? K._support && typeof K._support == "function" ? K._support().then(st, F) : st(!!K._support) : st(!0);
                        } catch (Nt) {
                          F(Nt);
                        }
                      });
                      return p(Y, Q, te), Y;
                    }, I.prototype.driver = function () {
                      return this._driver || null;
                    }, I.prototype.getDriver = function (K, Q, te) {
                      var Y = $e[K] ? f.resolve($e[K]) : f.reject(new Error("Driver not found."));
                      return p(Y, Q, te), Y;
                    }, I.prototype.getSerializer = function (K) {
                      var Q = f.resolve(On);
                      return p(Q, K), Q;
                    }, I.prototype.ready = function (K) {
                      var Q = this,
                        te = Q._driverSet.then(function () {
                          return Q._ready === null && (Q._ready = Q._initDriver()), Q._ready;
                        });
                      return p(te, K, K), te;
                    }, I.prototype.setDriver = function (K, Q, te) {
                      var Y = this;
                      et(K) || (K = [K]);
                      var ue = this._getSupportedDrivers(K);
                      function F() {
                        Y._config.driver = Y.driver();
                      }
                      function pe(xe) {
                        return Y._extend(xe), F(), Y._ready = Y._initStorage(Y._config), Y._ready;
                      }
                      function ge(xe) {
                        return function () {
                          var De = 0;
                          function He() {
                            for (; De < xe.length;) {
                              var Qe = xe[De];
                              return De++, Y._dbInfo = null, Y._ready = null, Y.getDriver(Qe).then(pe).catch(He);
                            }
                            F();
                            var Ye = new Error("No available storage method found.");
                            return Y._driverSet = f.reject(Ye), Y._driverSet;
                          }
                          return He();
                        };
                      }
                      var ve = this._driverSet !== null ? this._driverSet.catch(function () {
                        return f.resolve();
                      }) : f.resolve();
                      return this._driverSet = ve.then(function () {
                        var xe = ue[0];
                        return Y._dbInfo = null, Y._ready = null, Y.getDriver(xe).then(function (De) {
                          Y._driver = De._driver, F(), Y._wrapLibraryMethodsWithReady(), Y._initDriver = ge(ue);
                        });
                      }).catch(function () {
                        F();
                        var xe = new Error("No available storage method found.");
                        return Y._driverSet = f.reject(xe), Y._driverSet;
                      }), p(this._driverSet, Q, te), this._driverSet;
                    }, I.prototype.supports = function (K) {
                      return !!tt[K];
                    }, I.prototype._extend = function (K) {
                      fe(this, K);
                    }, I.prototype._getSupportedDrivers = function (K) {
                      for (var Q = [], te = 0, Y = K.length; te < Y; te++) {
                        var ue = K[te];
                        this.supports(ue) && Q.push(ue);
                      }
                      return Q;
                    }, I.prototype._wrapLibraryMethodsWithReady = function () {
                      for (var K = 0, Q = Me.length; K < Q; K++) Re(this, Me[K]);
                    }, I.prototype.createInstance = function (K) {
                      return new I(K);
                    }, I;
                  }(),
                  we = new he();
                r.exports = we;
              }, {
                3: 3
              }]
            }, {}, [4])(4);
          });
        }(_d)), _d.exports;
      }
      var sy;
      function ku() {
        return sy || (sy = 1, function (n) {
          var e = qo && qo.__awaiter || function (b, m, _, N) {
              function O(y) {
                return y instanceof _ ? y : new _(function (w) {
                  w(y);
                });
              }
              return new (_ || (_ = Promise))(function (y, w) {
                function A(D) {
                  try {
                    T(N.next(D));
                  } catch (M) {
                    w(M);
                  }
                }
                function R(D) {
                  try {
                    T(N.throw(D));
                  } catch (M) {
                    w(M);
                  }
                }
                function T(D) {
                  D.done ? y(D.value) : O(D.value).then(A, R);
                }
                T((N = N.apply(b, m || [])).next());
              });
            },
            t = qo && qo.__importDefault || function (b) {
              return b && b.__esModule ? b : {
                default: b
              };
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.OKXReporter = n.OKXReportSide = n.OKXReportType = n.versionStr = void 0;
          const r = t(dO()),
            i = yn(),
            a = ll(),
            l = tn(),
            s = t(Ed());
          n.versionStr = "1.8.6";
          const o = ["https://www.okx.com/dappstat/wallet-connect", "https://www.okx.ac/dappstat/wallet-connect"],
            c = "OKX_RP_CK",
            u = "OKX_RP_UUID_CK",
            f = 100,
            v = {
              headers: {
                Accept: "*/*",
                "Content-Type": "text/plain"
              },
              method: "POST"
            };
          n.OKXReportType = {
            PAGE_IN: "page_in",
            PAGE_OUT: "page_out",
            CLICK: "click",
            LOG: "log"
          }, n.OKXReportSide = {
            DAPP: "dapp",
            WALLET: "wallet"
          };
          const h = (b, ...m) => e(void 0, [b, ...m], void 0, function* (_, N = {}, O = 5e3) {
            for (const y of _) try {
              const w = new AbortController(),
                A = w.signal,
                R = (0, r.default)(y, Object.assign(Object.assign({}, N), {
                  signal: A
                })),
                T = new Promise((M, q) => setTimeout(() => {
                  w.abort(), q(new Error("Request timed out"));
                }, O)),
                D = yield Promise.race([R, T]);
              if (D.ok) return D;
              if (D.status == 502) return console.error("Fetch error status 502", y), D;
            } catch (w) {
              console.error(`Fetch error for ${y}:`, w);
            }
            throw console.error("'All fetch attempts failed.'"), new Error("All fetch attempts failed.");
          });
          class g {
            constructor() {
              this.currentSide = n.OKXReportSide.DAPP, this.currentVersion = n.versionStr, this.storage = s.default.createInstance({
                name: "OKXReporter"
              }), this.recordList = new Array(), this.currentUUID = "fjdkakfjsadkfklasdkfsdjkljfklsdjklfioruer3239084dkskfsa";
            }
            configVersionAndSide(m, _, N) {
              this.currentVersion = m + i.logVersion, this.currentSide = _, this.appName = N;
            }
            get recordCacheKey() {
              return c + "@" + this.appName;
            }
            get reportPlatform() {
              return (0, l.isMobileUserAgent)() ? (0, l.isIos)() ? "iOS" : "android" : "pc";
            }
            beginReport() {
              return e(this, void 0, void 0, function* () {
                this.startErrorCatching();
                let m = yield this.storage.getItem(this.recordCacheKey),
                  _ = yield this.storage.getItem(u);
                _ ? this.currentUUID = _ : this.storage.setItem(u, this.currentUUID), m && (this.recordList = m, (0, i.logDebug)("resume records from cache length: ", this.recordList.length), yield this.sendCachedRecords());
              });
            }
            startErrorCatching() {
              (0, a.getWindow)() && (0, i.logDebug)("begin capture console error");
            }
            cachedErrors() {
              return this.recordList;
            }
            sendRecord(m) {
              return e(this, void 0, void 0, function* () {
                return new Promise((_, N) => e(this, void 0, void 0, function* () {
                  try {
                    const O = JSON.stringify(m);
                    (0, i.logDebug)("[REPORT] record: ", O);
                    const y = yield h(o, Object.assign(Object.assign({}, v), {
                      body: O
                    }));
                    (0, i.logDebug)("[REPORT] get rsp:", y), y && y.status && y.status == 200 ? (this.recordList = this.recordList.filter(w => w.timestamp != m.timestamp || w.content != m.content), yield this.storage.setItem(this.recordCacheKey, this.recordList), _(!0)) : N(!1);
                  } catch (O) {
                    (0, i.logDebug)("send record error:", O), _(!0);
                  }
                }));
              });
            }
            sendRecordContent(m, _, N) {
              return e(this, arguments, void 0, function* (O, y, w, A = void 0, R = void 0, T = void 0, D = void 0, M = void 0, q = void 0) {
                var W, x, C, B;
                let X = (W = (0, a.getWindow)()) === null || W === void 0 ? void 0 : W.location.pathname,
                  J = (x = (0, a.getWindow)()) === null || x === void 0 ? void 0 : x.location.origin;
                X && J && (J = J + X);
                let V = (C = (0, a.getWindow)()) === null || C === void 0 ? void 0 : C.navigator.language,
                  $ = (B = (0, a.getWindow)()) === null || B === void 0 ? void 0 : B.navigator.userAgent,
                  se = this.reportPlatform,
                  ne = {
                    uuid: this.currentUUID,
                    version: this.currentVersion,
                    content: O,
                    action: w,
                    side: this.currentSide,
                    timestamp: new Date().getTime(),
                    url: J,
                    lang: V,
                    type: y,
                    platform: se,
                    "user-agent": $,
                    reverved1: A,
                    reverved2: R,
                    reverved3: T,
                    reverved4: D,
                    reverved5: M,
                    reverved6: q
                  };
                yield this.markRecordItem(ne), yield this.sendRecord(ne);
              });
            }
            sendCachedRecords() {
              return e(this, void 0, void 0, function* () {
                return new Promise((m, _) => e(this, void 0, void 0, function* () {
                  let N = this.recordList.map(O => this.sendRecord(O));
                  (0, i.logDebug)("[REPORT] submit & clean recorded caches begin @", new Date().toUTCString()), Promise.allSettled(N).then(O => {
                    (0, i.logDebug)("[REPORT] submit & clean recorded caches ends @", new Date().toUTCString());
                    let y = [];
                    O.forEach((w, A) => {
                      w.status == "rejected" && y.push(A);
                    }), this.recordList = this.recordList.filter((w, A) => !y.includes(A)), this.storage.setItem(this.recordCacheKey, this.recordList).then(function (w) {
                      m();
                    }).catch(function (w) {
                      _(w);
                    });
                  });
                }));
              });
            }
            markRecordItem(m) {
              return e(this, void 0, void 0, function* () {
                if (this.recordList.push(m), this.recordList.length > f) {
                  let _ = this.recordList.length - f;
                  this.recordList.splice(0, _);
                }
                return new Promise((_, N) => {
                  this.storage.setItem(this.recordCacheKey, this.recordList).then(function (O) {
                    _(m);
                  }).catch(function (O) {
                    N(O);
                  });
                });
              });
            }
          }
          n.OKXReporter = g;
        }(qo)), qo;
      }
      const AO = {
        version: "1.8.6"
      };
      var ay;
      function yn() {
        if (ay) return rr;
        ay = 1;
        var n = rr && rr.__awaiter || function (p, v, h, g) {
          function b(m) {
            return m instanceof h ? m : new h(function (_) {
              _(m);
            });
          }
          return new (h || (h = Promise))(function (m, _) {
            function N(w) {
              try {
                y(g.next(w));
              } catch (A) {
                _(A);
              }
            }
            function O(w) {
              try {
                y(g.throw(w));
              } catch (A) {
                _(A);
              }
            }
            function y(w) {
              w.done ? m(w.value) : b(w.value).then(N, O);
            }
            y((g = g.apply(p, v || [])).next());
          });
        };
        Object.defineProperty(rr, "__esModule", {
          value: !0
        }), rr.logVersion = void 0, rr.getDefaultReporter = a, rr.logDebug = o, rr.logError = c, rr.logWarning = u, rr.reportEvent = f, rr.reportLog = d;
        const e = !1,
          t = !1,
          r = ku(),
          i = new r.OKXReporter();
        function a() {
          return i;
        }
        const s = AO.version;
        function o(...p) {
          if (typeof console != "undefined") try {
            (e || window != null && window.okxLogDebug) && console.log(`[OKX_CONNECT_SDK1] ${s} `, ...p);
          } catch {}
        }
        function c(...p) {
          if (typeof console != "undefined") try {
            if ((e || window != null && window.okxLogDebug) && console.error(`[OKX_CONNECT_SDK1] ${s} `, ...p), t || !e) {
              let v = "";
              v += [...p].reduce((h, g) => {
                typeof g == "string" ? h += "," + g : typeof g == "object" && (h += JSON.stringify(g));
              }), i.sendRecordContent(v, r.OKXReportType.LOG, "");
            }
          } catch {}
        }
        function u(...p) {
          if (typeof console != "undefined") try {
            (e || window != null && window.okxLogDebug) && console.warn(`[OKX_CONNECT_SDK1] ${s} `, ...p);
          } catch {}
        }
        function f(p, v, h) {
          return n(this, arguments, void 0, function* (g, b, m, _ = void 0, N = void 0, O = void 0, y = void 0, w = void 0, A = void 0) {
            try {
              yield i.sendRecordContent(m, g, b, _, N, O, y, w, A);
            } catch {}
          });
        }
        function d(p) {
          return n(this, arguments, void 0, function* (v, h = "default") {});
        }
        return rr.logVersion = s, rr;
      }
      var cy;
      function $o() {
        if (cy) return ol;
        cy = 1, Object.defineProperty(ol, "__esModule", {
          value: !0
        }), ol.safeJsonParse = r, ol.safeJsonStringify = i;
        const n = yn(),
          e = a => JSON.stringify(a, (l, s) => typeof s == "bigint" ? s.toString() + "n" : s),
          t = a => {
            const l = /:(\b\d{17,}|\b(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))(?=[,\}\]]|$)/g,
              s = a.replace(l, (o, c) => `:"${c}n"`);
            try {
              return JSON.parse(s, (o, c) => typeof c == "string" && c.match(/^\d+n$/) ? BigInt(c.substring(0, c.length - 1)) : c);
            } catch {
              return JSON.parse(a);
            }
          };
        function r(a) {
          if (typeof a != "string") throw (0, n.logDebug)(a), new Error(`Cannot safe json parse value of type ${typeof a}`);
          try {
            return t(a);
          } catch (l) {
            return console.error("safeJsonParse error:", l), a;
          }
        }
        function i(a) {
          return typeof a == "string" ? a : e(a) || "";
        }
        return ol;
      }
      var Qo = {};
      const RO = $0(oO);
      var ly;
      function uy() {
        if (ly) return Qo;
        ly = 1, Object.defineProperty(Qo, "__esModule", {
          value: !0
        }), Qo.okxfromString = t, Qo.okxtoString = r, Qo.alloc = i, Qo.allocUnsafe = a;
        const n = RO,
          e = yn();
        function t(u, f = "utf8") {
          const d = c[f];
          if ((0, e.logDebug)("okxfromstring ====> "), !d) throw new Error(`Unsupported encoding "${f}"`);
          return d.decoder.decode(`${d.prefix}${u}`);
        }
        function r(u, f = "utf8") {
          const d = c[f];
          if ((0, e.logDebug)("okxtoString ====> "), !d) throw new Error(`Unsupported encoding "${f}"`);
          return d.encoder.encode(u).substring(1);
        }
        function i(u = 0) {
          return new Uint8Array(u);
        }
        function a(u = 0) {
          return new Uint8Array(u);
        }
        function l(u, f, d, p) {
          return {
            name: u,
            prefix: f,
            encoder: {
              name: u,
              prefix: f,
              encode: d
            },
            decoder: {
              decode: p
            }
          };
        }
        const s = l("utf8", "u", u => "u" + new TextDecoder("utf8").decode(u), u => new TextEncoder().encode(u.substring(1))),
          o = l("ascii", "a", u => {
            let f = "a";
            for (let d = 0; d < u.length; d++) {
              let p = u[d];
              p && String.fromCharCode(p) && (f += String.fromCharCode(p));
            }
            return f;
          }, u => {
            u = u.substring(1);
            const f = a(u.length);
            for (let d = 0; d < u.length; d++) f[d] = u.charCodeAt(d);
            return f;
          }),
          c = Object.assign({
            utf8: s,
            "utf-8": s,
            hex: n.bases.base16,
            latin1: o,
            ascii: o,
            binary: o
          }, n.bases);
        return Qo;
      }
      var Mu = {
          exports: {}
        },
        Ku = {
          exports: {}
        },
        NO = Ku.exports,
        fy;
      function _t() {
        return fy || (fy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r();
          })(NO, function () {
            var t = t || function (r, i) {
              var a;
              if (typeof window != "undefined" && window.crypto && (a = window.crypto), typeof self != "undefined" && self.crypto && (a = self.crypto), typeof globalThis != "undefined" && globalThis.crypto && (a = globalThis.crypto), !a && typeof window != "undefined" && window.msCrypto && (a = window.msCrypto), !a && typeof qt != "undefined" && qt.crypto && (a = qt.crypto), !a && typeof Xo == "function") try {
                a = rd;
              } catch {}
              var l = function () {
                  if (a) {
                    if (typeof a.getRandomValues == "function") try {
                      return a.getRandomValues(new Uint32Array(1))[0];
                    } catch {}
                    if (typeof a.randomBytes == "function") try {
                      return a.randomBytes(4).readInt32LE();
                    } catch {}
                  }
                  throw new Error("Native crypto module could not be used to get secure random number.");
                },
                s = Object.create || function () {
                  function m() {}
                  return function (_) {
                    var N;
                    return m.prototype = _, N = new m(), m.prototype = null, N;
                  };
                }(),
                o = {},
                c = o.lib = {},
                u = c.Base = function () {
                  return {
                    extend: function (m) {
                      var _ = s(this);
                      return m && _.mixIn(m), (!_.hasOwnProperty("init") || this.init === _.init) && (_.init = function () {
                        _.$super.init.apply(this, arguments);
                      }), _.init.prototype = _, _.$super = this, _;
                    },
                    create: function () {
                      var m = this.extend();
                      return m.init.apply(m, arguments), m;
                    },
                    init: function () {},
                    mixIn: function (m) {
                      for (var _ in m) m.hasOwnProperty(_) && (this[_] = m[_]);
                      m.hasOwnProperty("toString") && (this.toString = m.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    }
                  };
                }(),
                f = c.WordArray = u.extend({
                  init: function (m, _) {
                    m = this.words = m || [], _ != i ? this.sigBytes = _ : this.sigBytes = m.length * 4;
                  },
                  toString: function (m) {
                    return (m || p).stringify(this);
                  },
                  concat: function (m) {
                    var _ = this.words,
                      N = m.words,
                      O = this.sigBytes,
                      y = m.sigBytes;
                    if (this.clamp(), O % 4) for (var w = 0; w < y; w++) {
                      var A = N[w >>> 2] >>> 24 - w % 4 * 8 & 255;
                      _[O + w >>> 2] |= A << 24 - (O + w) % 4 * 8;
                    } else for (var R = 0; R < y; R += 4) _[O + R >>> 2] = N[R >>> 2];
                    return this.sigBytes += y, this;
                  },
                  clamp: function () {
                    var m = this.words,
                      _ = this.sigBytes;
                    m[_ >>> 2] &= 4294967295 << 32 - _ % 4 * 8, m.length = r.ceil(_ / 4);
                  },
                  clone: function () {
                    var m = u.clone.call(this);
                    return m.words = this.words.slice(0), m;
                  },
                  random: function (m) {
                    for (var _ = [], N = 0; N < m; N += 4) _.push(l());
                    return new f.init(_, m);
                  }
                }),
                d = o.enc = {},
                p = d.Hex = {
                  stringify: function (m) {
                    for (var _ = m.words, N = m.sigBytes, O = [], y = 0; y < N; y++) {
                      var w = _[y >>> 2] >>> 24 - y % 4 * 8 & 255;
                      O.push((w >>> 4).toString(16)), O.push((w & 15).toString(16));
                    }
                    return O.join("");
                  },
                  parse: function (m) {
                    for (var _ = m.length, N = [], O = 0; O < _; O += 2) N[O >>> 3] |= parseInt(m.substr(O, 2), 16) << 24 - O % 8 * 4;
                    return new f.init(N, _ / 2);
                  }
                },
                v = d.Latin1 = {
                  stringify: function (m) {
                    for (var _ = m.words, N = m.sigBytes, O = [], y = 0; y < N; y++) {
                      var w = _[y >>> 2] >>> 24 - y % 4 * 8 & 255;
                      O.push(String.fromCharCode(w));
                    }
                    return O.join("");
                  },
                  parse: function (m) {
                    for (var _ = m.length, N = [], O = 0; O < _; O++) N[O >>> 2] |= (m.charCodeAt(O) & 255) << 24 - O % 4 * 8;
                    return new f.init(N, _);
                  }
                },
                h = d.Utf8 = {
                  stringify: function (m) {
                    try {
                      return decodeURIComponent(escape(v.stringify(m)));
                    } catch {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (m) {
                    return v.parse(unescape(encodeURIComponent(m)));
                  }
                },
                g = c.BufferedBlockAlgorithm = u.extend({
                  reset: function () {
                    this._data = new f.init(), this._nDataBytes = 0;
                  },
                  _append: function (m) {
                    typeof m == "string" && (m = h.parse(m)), this._data.concat(m), this._nDataBytes += m.sigBytes;
                  },
                  _process: function (m) {
                    var _,
                      N = this._data,
                      O = N.words,
                      y = N.sigBytes,
                      w = this.blockSize,
                      A = w * 4,
                      R = y / A;
                    m ? R = r.ceil(R) : R = r.max((R | 0) - this._minBufferSize, 0);
                    var T = R * w,
                      D = r.min(T * 4, y);
                    if (T) {
                      for (var M = 0; M < T; M += w) this._doProcessBlock(O, M);
                      _ = O.splice(0, T), N.sigBytes -= D;
                    }
                    return new f.init(_, D);
                  },
                  clone: function () {
                    var m = u.clone.call(this);
                    return m._data = this._data.clone(), m;
                  },
                  _minBufferSize: 0
                });
              c.Hasher = g.extend({
                cfg: u.extend(),
                init: function (m) {
                  this.cfg = this.cfg.extend(m), this.reset();
                },
                reset: function () {
                  g.reset.call(this), this._doReset();
                },
                update: function (m) {
                  return this._append(m), this._process(), this;
                },
                finalize: function (m) {
                  m && this._append(m);
                  var _ = this._doFinalize();
                  return _;
                },
                blockSize: 16,
                _createHelper: function (m) {
                  return function (_, N) {
                    return new m.init(N).finalize(_);
                  };
                },
                _createHmacHelper: function (m) {
                  return function (_, N) {
                    return new b.HMAC.init(m, N).finalize(_);
                  };
                }
              });
              var b = o.algo = {};
              return o;
            }(Math);
            return t;
          });
        }(Ku)), Ku.exports;
      }
      var Lu = {
          exports: {}
        },
        SO = Lu.exports,
        dy;
      function Uu() {
        return dy || (dy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(SO, function (t) {
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.Base,
                s = a.WordArray,
                o = i.x64 = {};
              o.Word = l.extend({
                init: function (c, u) {
                  this.high = c, this.low = u;
                }
              }), o.WordArray = l.extend({
                init: function (c, u) {
                  c = this.words = c || [], u != r ? this.sigBytes = u : this.sigBytes = c.length * 8;
                },
                toX32: function () {
                  for (var c = this.words, u = c.length, f = [], d = 0; d < u; d++) {
                    var p = c[d];
                    f.push(p.high), f.push(p.low);
                  }
                  return s.create(f, this.sigBytes);
                },
                clone: function () {
                  for (var c = l.clone.call(this), u = c.words = this.words.slice(0), f = u.length, d = 0; d < f; d++) u[d] = u[d].clone();
                  return c;
                }
              });
            }(), t;
          });
        }(Lu)), Lu.exports;
      }
      var Fu = {
          exports: {}
        },
        TO = Fu.exports,
        hy;
      function DO() {
        return hy || (hy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(TO, function (t) {
            return function () {
              if (typeof ArrayBuffer == "function") {
                var r = t,
                  i = r.lib,
                  a = i.WordArray,
                  l = a.init,
                  s = a.init = function (o) {
                    if (o instanceof ArrayBuffer && (o = new Uint8Array(o)), (o instanceof Int8Array || typeof Uint8ClampedArray != "undefined" && o instanceof Uint8ClampedArray || o instanceof Int16Array || o instanceof Uint16Array || o instanceof Int32Array || o instanceof Uint32Array || o instanceof Float32Array || o instanceof Float64Array) && (o = new Uint8Array(o.buffer, o.byteOffset, o.byteLength)), o instanceof Uint8Array) {
                      for (var c = o.byteLength, u = [], f = 0; f < c; f++) u[f >>> 2] |= o[f] << 24 - f % 4 * 8;
                      l.call(this, u, c);
                    } else l.apply(this, arguments);
                  };
                s.prototype = a;
              }
            }(), t.lib.WordArray;
          });
        }(Fu)), Fu.exports;
      }
      var Hu = {
          exports: {}
        },
        PO = Hu.exports,
        py;
      function IO() {
        return py || (py = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(PO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = r.enc;
              l.Utf16 = l.Utf16BE = {
                stringify: function (o) {
                  for (var c = o.words, u = o.sigBytes, f = [], d = 0; d < u; d += 2) {
                    var p = c[d >>> 2] >>> 16 - d % 4 * 8 & 65535;
                    f.push(String.fromCharCode(p));
                  }
                  return f.join("");
                },
                parse: function (o) {
                  for (var c = o.length, u = [], f = 0; f < c; f++) u[f >>> 1] |= o.charCodeAt(f) << 16 - f % 2 * 16;
                  return a.create(u, c * 2);
                }
              }, l.Utf16LE = {
                stringify: function (o) {
                  for (var c = o.words, u = o.sigBytes, f = [], d = 0; d < u; d += 2) {
                    var p = s(c[d >>> 2] >>> 16 - d % 4 * 8 & 65535);
                    f.push(String.fromCharCode(p));
                  }
                  return f.join("");
                },
                parse: function (o) {
                  for (var c = o.length, u = [], f = 0; f < c; f++) u[f >>> 1] |= s(o.charCodeAt(f) << 16 - f % 2 * 16);
                  return a.create(u, c * 2);
                }
              };
              function s(o) {
                return o << 8 & 4278255360 | o >>> 8 & 16711935;
              }
            }(), t.enc.Utf16;
          });
        }(Hu)), Hu.exports;
      }
      var ju = {
          exports: {}
        },
        BO = ju.exports,
        gy;
      function Yo() {
        return gy || (gy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(BO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = r.enc;
              l.Base64 = {
                stringify: function (o) {
                  var c = o.words,
                    u = o.sigBytes,
                    f = this._map;
                  o.clamp();
                  for (var d = [], p = 0; p < u; p += 3) for (var v = c[p >>> 2] >>> 24 - p % 4 * 8 & 255, h = c[p + 1 >>> 2] >>> 24 - (p + 1) % 4 * 8 & 255, g = c[p + 2 >>> 2] >>> 24 - (p + 2) % 4 * 8 & 255, b = v << 16 | h << 8 | g, m = 0; m < 4 && p + m * .75 < u; m++) d.push(f.charAt(b >>> 6 * (3 - m) & 63));
                  var _ = f.charAt(64);
                  if (_) for (; d.length % 4;) d.push(_);
                  return d.join("");
                },
                parse: function (o) {
                  var c = o.length,
                    u = this._map,
                    f = this._reverseMap;
                  if (!f) {
                    f = this._reverseMap = [];
                    for (var d = 0; d < u.length; d++) f[u.charCodeAt(d)] = d;
                  }
                  var p = u.charAt(64);
                  if (p) {
                    var v = o.indexOf(p);
                    v !== -1 && (c = v);
                  }
                  return s(o, c, f);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
              };
              function s(o, c, u) {
                for (var f = [], d = 0, p = 0; p < c; p++) if (p % 4) {
                  var v = u[o.charCodeAt(p - 1)] << p % 4 * 2,
                    h = u[o.charCodeAt(p)] >>> 6 - p % 4 * 2,
                    g = v | h;
                  f[d >>> 2] |= g << 24 - d % 4 * 8, d++;
                }
                return a.create(f, d);
              }
            }(), t.enc.Base64;
          });
        }(ju)), ju.exports;
      }
      var Wu = {
          exports: {}
        },
        kO = Wu.exports,
        vy;
      function MO() {
        return vy || (vy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(kO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = r.enc;
              l.Base64url = {
                stringify: function (o, c) {
                  c === void 0 && (c = !0);
                  var u = o.words,
                    f = o.sigBytes,
                    d = c ? this._safe_map : this._map;
                  o.clamp();
                  for (var p = [], v = 0; v < f; v += 3) for (var h = u[v >>> 2] >>> 24 - v % 4 * 8 & 255, g = u[v + 1 >>> 2] >>> 24 - (v + 1) % 4 * 8 & 255, b = u[v + 2 >>> 2] >>> 24 - (v + 2) % 4 * 8 & 255, m = h << 16 | g << 8 | b, _ = 0; _ < 4 && v + _ * .75 < f; _++) p.push(d.charAt(m >>> 6 * (3 - _) & 63));
                  var N = d.charAt(64);
                  if (N) for (; p.length % 4;) p.push(N);
                  return p.join("");
                },
                parse: function (o, c) {
                  c === void 0 && (c = !0);
                  var u = o.length,
                    f = c ? this._safe_map : this._map,
                    d = this._reverseMap;
                  if (!d) {
                    d = this._reverseMap = [];
                    for (var p = 0; p < f.length; p++) d[f.charCodeAt(p)] = p;
                  }
                  var v = f.charAt(64);
                  if (v) {
                    var h = o.indexOf(v);
                    h !== -1 && (u = h);
                  }
                  return s(o, u, d);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
              };
              function s(o, c, u) {
                for (var f = [], d = 0, p = 0; p < c; p++) if (p % 4) {
                  var v = u[o.charCodeAt(p - 1)] << p % 4 * 2,
                    h = u[o.charCodeAt(p)] >>> 6 - p % 4 * 2,
                    g = v | h;
                  f[d >>> 2] |= g << 24 - d % 4 * 8, d++;
                }
                return a.create(f, d);
              }
            }(), t.enc.Base64url;
          });
        }(Wu)), Wu.exports;
      }
      var Xu = {
          exports: {}
        },
        KO = Xu.exports,
        yy;
      function Zo() {
        return yy || (yy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(KO, function (t) {
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.WordArray,
                s = a.Hasher,
                o = i.algo,
                c = [];
              (function () {
                for (var h = 0; h < 64; h++) c[h] = r.abs(r.sin(h + 1)) * 4294967296 | 0;
              })();
              var u = o.MD5 = s.extend({
                _doReset: function () {
                  this._hash = new l.init([1732584193, 4023233417, 2562383102, 271733878]);
                },
                _doProcessBlock: function (h, g) {
                  for (var b = 0; b < 16; b++) {
                    var m = g + b,
                      _ = h[m];
                    h[m] = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360;
                  }
                  var N = this._hash.words,
                    O = h[g + 0],
                    y = h[g + 1],
                    w = h[g + 2],
                    A = h[g + 3],
                    R = h[g + 4],
                    T = h[g + 5],
                    D = h[g + 6],
                    M = h[g + 7],
                    q = h[g + 8],
                    W = h[g + 9],
                    x = h[g + 10],
                    C = h[g + 11],
                    B = h[g + 12],
                    X = h[g + 13],
                    J = h[g + 14],
                    V = h[g + 15],
                    $ = N[0],
                    se = N[1],
                    ne = N[2],
                    oe = N[3];
                  $ = f($, se, ne, oe, O, 7, c[0]), oe = f(oe, $, se, ne, y, 12, c[1]), ne = f(ne, oe, $, se, w, 17, c[2]), se = f(se, ne, oe, $, A, 22, c[3]), $ = f($, se, ne, oe, R, 7, c[4]), oe = f(oe, $, se, ne, T, 12, c[5]), ne = f(ne, oe, $, se, D, 17, c[6]), se = f(se, ne, oe, $, M, 22, c[7]), $ = f($, se, ne, oe, q, 7, c[8]), oe = f(oe, $, se, ne, W, 12, c[9]), ne = f(ne, oe, $, se, x, 17, c[10]), se = f(se, ne, oe, $, C, 22, c[11]), $ = f($, se, ne, oe, B, 7, c[12]), oe = f(oe, $, se, ne, X, 12, c[13]), ne = f(ne, oe, $, se, J, 17, c[14]), se = f(se, ne, oe, $, V, 22, c[15]), $ = d($, se, ne, oe, y, 5, c[16]), oe = d(oe, $, se, ne, D, 9, c[17]), ne = d(ne, oe, $, se, C, 14, c[18]), se = d(se, ne, oe, $, O, 20, c[19]), $ = d($, se, ne, oe, T, 5, c[20]), oe = d(oe, $, se, ne, x, 9, c[21]), ne = d(ne, oe, $, se, V, 14, c[22]), se = d(se, ne, oe, $, R, 20, c[23]), $ = d($, se, ne, oe, W, 5, c[24]), oe = d(oe, $, se, ne, J, 9, c[25]), ne = d(ne, oe, $, se, A, 14, c[26]), se = d(se, ne, oe, $, q, 20, c[27]), $ = d($, se, ne, oe, X, 5, c[28]), oe = d(oe, $, se, ne, w, 9, c[29]), ne = d(ne, oe, $, se, M, 14, c[30]), se = d(se, ne, oe, $, B, 20, c[31]), $ = p($, se, ne, oe, T, 4, c[32]), oe = p(oe, $, se, ne, q, 11, c[33]), ne = p(ne, oe, $, se, C, 16, c[34]), se = p(se, ne, oe, $, J, 23, c[35]), $ = p($, se, ne, oe, y, 4, c[36]), oe = p(oe, $, se, ne, R, 11, c[37]), ne = p(ne, oe, $, se, M, 16, c[38]), se = p(se, ne, oe, $, x, 23, c[39]), $ = p($, se, ne, oe, X, 4, c[40]), oe = p(oe, $, se, ne, O, 11, c[41]), ne = p(ne, oe, $, se, A, 16, c[42]), se = p(se, ne, oe, $, D, 23, c[43]), $ = p($, se, ne, oe, W, 4, c[44]), oe = p(oe, $, se, ne, B, 11, c[45]), ne = p(ne, oe, $, se, V, 16, c[46]), se = p(se, ne, oe, $, w, 23, c[47]), $ = v($, se, ne, oe, O, 6, c[48]), oe = v(oe, $, se, ne, M, 10, c[49]), ne = v(ne, oe, $, se, J, 15, c[50]), se = v(se, ne, oe, $, T, 21, c[51]), $ = v($, se, ne, oe, B, 6, c[52]), oe = v(oe, $, se, ne, A, 10, c[53]), ne = v(ne, oe, $, se, x, 15, c[54]), se = v(se, ne, oe, $, y, 21, c[55]), $ = v($, se, ne, oe, q, 6, c[56]), oe = v(oe, $, se, ne, V, 10, c[57]), ne = v(ne, oe, $, se, D, 15, c[58]), se = v(se, ne, oe, $, X, 21, c[59]), $ = v($, se, ne, oe, R, 6, c[60]), oe = v(oe, $, se, ne, C, 10, c[61]), ne = v(ne, oe, $, se, w, 15, c[62]), se = v(se, ne, oe, $, W, 21, c[63]), N[0] = N[0] + $ | 0, N[1] = N[1] + se | 0, N[2] = N[2] + ne | 0, N[3] = N[3] + oe | 0;
                },
                _doFinalize: function () {
                  var h = this._data,
                    g = h.words,
                    b = this._nDataBytes * 8,
                    m = h.sigBytes * 8;
                  g[m >>> 5] |= 128 << 24 - m % 32;
                  var _ = r.floor(b / 4294967296),
                    N = b;
                  g[(m + 64 >>> 9 << 4) + 15] = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360, g[(m + 64 >>> 9 << 4) + 14] = (N << 8 | N >>> 24) & 16711935 | (N << 24 | N >>> 8) & 4278255360, h.sigBytes = (g.length + 1) * 4, this._process();
                  for (var O = this._hash, y = O.words, w = 0; w < 4; w++) {
                    var A = y[w];
                    y[w] = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360;
                  }
                  return O;
                },
                clone: function () {
                  var h = s.clone.call(this);
                  return h._hash = this._hash.clone(), h;
                }
              });
              function f(h, g, b, m, _, N, O) {
                var y = h + (g & b | ~g & m) + _ + O;
                return (y << N | y >>> 32 - N) + g;
              }
              function d(h, g, b, m, _, N, O) {
                var y = h + (g & m | b & ~m) + _ + O;
                return (y << N | y >>> 32 - N) + g;
              }
              function p(h, g, b, m, _, N, O) {
                var y = h + (g ^ b ^ m) + _ + O;
                return (y << N | y >>> 32 - N) + g;
              }
              function v(h, g, b, m, _, N, O) {
                var y = h + (b ^ (g | ~m)) + _ + O;
                return (y << N | y >>> 32 - N) + g;
              }
              i.MD5 = s._createHelper(u), i.HmacMD5 = s._createHmacHelper(u);
            }(Math), t.MD5;
          });
        }(Xu)), Xu.exports;
      }
      var qu = {
          exports: {}
        },
        LO = qu.exports,
        my;
      function by() {
        return my || (my = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(LO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = i.Hasher,
                s = r.algo,
                o = [],
                c = s.SHA1 = l.extend({
                  _doReset: function () {
                    this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                  },
                  _doProcessBlock: function (u, f) {
                    for (var d = this._hash.words, p = d[0], v = d[1], h = d[2], g = d[3], b = d[4], m = 0; m < 80; m++) {
                      if (m < 16) o[m] = u[f + m] | 0;else {
                        var _ = o[m - 3] ^ o[m - 8] ^ o[m - 14] ^ o[m - 16];
                        o[m] = _ << 1 | _ >>> 31;
                      }
                      var N = (p << 5 | p >>> 27) + b + o[m];
                      m < 20 ? N += (v & h | ~v & g) + 1518500249 : m < 40 ? N += (v ^ h ^ g) + 1859775393 : m < 60 ? N += (v & h | v & g | h & g) - 1894007588 : N += (v ^ h ^ g) - 899497514, b = g, g = h, h = v << 30 | v >>> 2, v = p, p = N;
                    }
                    d[0] = d[0] + p | 0, d[1] = d[1] + v | 0, d[2] = d[2] + h | 0, d[3] = d[3] + g | 0, d[4] = d[4] + b | 0;
                  },
                  _doFinalize: function () {
                    var u = this._data,
                      f = u.words,
                      d = this._nDataBytes * 8,
                      p = u.sigBytes * 8;
                    return f[p >>> 5] |= 128 << 24 - p % 32, f[(p + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296), f[(p + 64 >>> 9 << 4) + 15] = d, u.sigBytes = f.length * 4, this._process(), this._hash;
                  },
                  clone: function () {
                    var u = l.clone.call(this);
                    return u._hash = this._hash.clone(), u;
                  }
                });
              r.SHA1 = l._createHelper(c), r.HmacSHA1 = l._createHmacHelper(c);
            }(), t.SHA1;
          });
        }(qu)), qu.exports;
      }
      var Ju = {
          exports: {}
        },
        UO = Ju.exports,
        wy;
      function Cd() {
        return wy || (wy = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(UO, function (t) {
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.WordArray,
                s = a.Hasher,
                o = i.algo,
                c = [],
                u = [];
              (function () {
                function p(b) {
                  for (var m = r.sqrt(b), _ = 2; _ <= m; _++) if (!(b % _)) return !1;
                  return !0;
                }
                function v(b) {
                  return (b - (b | 0)) * 4294967296 | 0;
                }
                for (var h = 2, g = 0; g < 64;) p(h) && (g < 8 && (c[g] = v(r.pow(h, 1 / 2))), u[g] = v(r.pow(h, 1 / 3)), g++), h++;
              })();
              var f = [],
                d = o.SHA256 = s.extend({
                  _doReset: function () {
                    this._hash = new l.init(c.slice(0));
                  },
                  _doProcessBlock: function (p, v) {
                    for (var h = this._hash.words, g = h[0], b = h[1], m = h[2], _ = h[3], N = h[4], O = h[5], y = h[6], w = h[7], A = 0; A < 64; A++) {
                      if (A < 16) f[A] = p[v + A] | 0;else {
                        var R = f[A - 15],
                          T = (R << 25 | R >>> 7) ^ (R << 14 | R >>> 18) ^ R >>> 3,
                          D = f[A - 2],
                          M = (D << 15 | D >>> 17) ^ (D << 13 | D >>> 19) ^ D >>> 10;
                        f[A] = T + f[A - 7] + M + f[A - 16];
                      }
                      var q = N & O ^ ~N & y,
                        W = g & b ^ g & m ^ b & m,
                        x = (g << 30 | g >>> 2) ^ (g << 19 | g >>> 13) ^ (g << 10 | g >>> 22),
                        C = (N << 26 | N >>> 6) ^ (N << 21 | N >>> 11) ^ (N << 7 | N >>> 25),
                        B = w + C + q + u[A] + f[A],
                        X = x + W;
                      w = y, y = O, O = N, N = _ + B | 0, _ = m, m = b, b = g, g = B + X | 0;
                    }
                    h[0] = h[0] + g | 0, h[1] = h[1] + b | 0, h[2] = h[2] + m | 0, h[3] = h[3] + _ | 0, h[4] = h[4] + N | 0, h[5] = h[5] + O | 0, h[6] = h[6] + y | 0, h[7] = h[7] + w | 0;
                  },
                  _doFinalize: function () {
                    var p = this._data,
                      v = p.words,
                      h = this._nDataBytes * 8,
                      g = p.sigBytes * 8;
                    return v[g >>> 5] |= 128 << 24 - g % 32, v[(g + 64 >>> 9 << 4) + 14] = r.floor(h / 4294967296), v[(g + 64 >>> 9 << 4) + 15] = h, p.sigBytes = v.length * 4, this._process(), this._hash;
                  },
                  clone: function () {
                    var p = s.clone.call(this);
                    return p._hash = this._hash.clone(), p;
                  }
                });
              i.SHA256 = s._createHelper(d), i.HmacSHA256 = s._createHmacHelper(d);
            }(Math), t.SHA256;
          });
        }(Ju)), Ju.exports;
      }
      var Gu = {
          exports: {}
        },
        FO = Gu.exports,
        xy;
      function HO() {
        return xy || (xy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Cd());
          })(FO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = r.algo,
                s = l.SHA256,
                o = l.SHA224 = s.extend({
                  _doReset: function () {
                    this._hash = new a.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
                  },
                  _doFinalize: function () {
                    var c = s._doFinalize.call(this);
                    return c.sigBytes -= 4, c;
                  }
                });
              r.SHA224 = s._createHelper(o), r.HmacSHA224 = s._createHmacHelper(o);
            }(), t.SHA224;
          });
        }(Gu)), Gu.exports;
      }
      var Vu = {
          exports: {}
        },
        jO = Vu.exports,
        _y;
      function Ey() {
        return _y || (_y = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Uu());
          })(jO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.Hasher,
                l = r.x64,
                s = l.Word,
                o = l.WordArray,
                c = r.algo;
              function u() {
                return s.create.apply(s, arguments);
              }
              var f = [u(1116352408, 3609767458), u(1899447441, 602891725), u(3049323471, 3964484399), u(3921009573, 2173295548), u(961987163, 4081628472), u(1508970993, 3053834265), u(2453635748, 2937671579), u(2870763221, 3664609560), u(3624381080, 2734883394), u(310598401, 1164996542), u(607225278, 1323610764), u(1426881987, 3590304994), u(1925078388, 4068182383), u(2162078206, 991336113), u(2614888103, 633803317), u(3248222580, 3479774868), u(3835390401, 2666613458), u(4022224774, 944711139), u(264347078, 2341262773), u(604807628, 2007800933), u(770255983, 1495990901), u(1249150122, 1856431235), u(1555081692, 3175218132), u(1996064986, 2198950837), u(2554220882, 3999719339), u(2821834349, 766784016), u(2952996808, 2566594879), u(3210313671, 3203337956), u(3336571891, 1034457026), u(3584528711, 2466948901), u(113926993, 3758326383), u(338241895, 168717936), u(666307205, 1188179964), u(773529912, 1546045734), u(1294757372, 1522805485), u(1396182291, 2643833823), u(1695183700, 2343527390), u(1986661051, 1014477480), u(2177026350, 1206759142), u(2456956037, 344077627), u(2730485921, 1290863460), u(2820302411, 3158454273), u(3259730800, 3505952657), u(3345764771, 106217008), u(3516065817, 3606008344), u(3600352804, 1432725776), u(4094571909, 1467031594), u(275423344, 851169720), u(430227734, 3100823752), u(506948616, 1363258195), u(659060556, 3750685593), u(883997877, 3785050280), u(958139571, 3318307427), u(1322822218, 3812723403), u(1537002063, 2003034995), u(1747873779, 3602036899), u(1955562222, 1575990012), u(2024104815, 1125592928), u(2227730452, 2716904306), u(2361852424, 442776044), u(2428436474, 593698344), u(2756734187, 3733110249), u(3204031479, 2999351573), u(3329325298, 3815920427), u(3391569614, 3928383900), u(3515267271, 566280711), u(3940187606, 3454069534), u(4118630271, 4000239992), u(116418474, 1914138554), u(174292421, 2731055270), u(289380356, 3203993006), u(460393269, 320620315), u(685471733, 587496836), u(852142971, 1086792851), u(1017036298, 365543100), u(1126000580, 2618297676), u(1288033470, 3409855158), u(1501505948, 4234509866), u(1607167915, 987167468), u(1816402316, 1246189591)],
                d = [];
              (function () {
                for (var v = 0; v < 80; v++) d[v] = u();
              })();
              var p = c.SHA512 = a.extend({
                _doReset: function () {
                  this._hash = new o.init([new s.init(1779033703, 4089235720), new s.init(3144134277, 2227873595), new s.init(1013904242, 4271175723), new s.init(2773480762, 1595750129), new s.init(1359893119, 2917565137), new s.init(2600822924, 725511199), new s.init(528734635, 4215389547), new s.init(1541459225, 327033209)]);
                },
                _doProcessBlock: function (v, h) {
                  for (var g = this._hash.words, b = g[0], m = g[1], _ = g[2], N = g[3], O = g[4], y = g[5], w = g[6], A = g[7], R = b.high, T = b.low, D = m.high, M = m.low, q = _.high, W = _.low, x = N.high, C = N.low, B = O.high, X = O.low, J = y.high, V = y.low, $ = w.high, se = w.low, ne = A.high, oe = A.low, ye = R, Te = T, ae = D, G = M, Z = q, S = W, ee = x, Ce = C, Oe = B, Xe = X, Ve = J, at = V, ht = $, Et = se, vt = ne, It = oe, yt = 0; yt < 80; yt++) {
                    var ut,
                      rt,
                      pt = d[yt];
                    if (yt < 16) rt = pt.high = v[h + yt * 2] | 0, ut = pt.low = v[h + yt * 2 + 1] | 0;else {
                      var Ct = d[yt - 15],
                        Pe = Ct.high,
                        Fe = Ct.low,
                        ke = (Pe >>> 1 | Fe << 31) ^ (Pe >>> 8 | Fe << 24) ^ Pe >>> 7,
                        ze = (Fe >>> 1 | Pe << 31) ^ (Fe >>> 8 | Pe << 24) ^ (Fe >>> 7 | Pe << 25),
                        Bt = d[yt - 2],
                        mt = Bt.high,
                        Je = Bt.low,
                        Ke = (mt >>> 19 | Je << 13) ^ (mt << 3 | Je >>> 29) ^ mt >>> 6,
                        St = (Je >>> 19 | mt << 13) ^ (Je << 3 | mt >>> 29) ^ (Je >>> 6 | mt << 26),
                        Gt = d[yt - 7],
                        hn = Gt.high,
                        On = Gt.low,
                        An = d[yt - 16],
                        Gn = An.high,
                        mn = An.low;
                      ut = ze + On, rt = ke + hn + (ut >>> 0 < ze >>> 0 ? 1 : 0), ut = ut + St, rt = rt + Ke + (ut >>> 0 < St >>> 0 ? 1 : 0), ut = ut + mn, rt = rt + Gn + (ut >>> 0 < mn >>> 0 ? 1 : 0), pt.high = rt, pt.low = ut;
                    }
                    var ni = Oe & Ve ^ ~Oe & ht,
                      Di = Xe & at ^ ~Xe & Et,
                      rn = ye & ae ^ ye & Z ^ ae & Z,
                      Lt = Te & G ^ Te & S ^ G & S,
                      Ht = (ye >>> 28 | Te << 4) ^ (ye << 30 | Te >>> 2) ^ (ye << 25 | Te >>> 7),
                      jt = (Te >>> 28 | ye << 4) ^ (Te << 30 | ye >>> 2) ^ (Te << 25 | ye >>> 7),
                      $t = (Oe >>> 14 | Xe << 18) ^ (Oe >>> 18 | Xe << 14) ^ (Oe << 23 | Xe >>> 9),
                      Qt = (Xe >>> 14 | Oe << 18) ^ (Xe >>> 18 | Oe << 14) ^ (Xe << 23 | Oe >>> 9),
                      Yt = f[yt],
                      ln = Yt.high,
                      Ot = Yt.low,
                      At = It + Qt,
                      P = vt + $t + (At >>> 0 < It >>> 0 ? 1 : 0),
                      At = At + Di,
                      P = P + ni + (At >>> 0 < Di >>> 0 ? 1 : 0),
                      At = At + Ot,
                      P = P + ln + (At >>> 0 < Ot >>> 0 ? 1 : 0),
                      At = At + ut,
                      P = P + rt + (At >>> 0 < ut >>> 0 ? 1 : 0),
                      U = jt + Lt,
                      L = Ht + rn + (U >>> 0 < jt >>> 0 ? 1 : 0);
                    vt = ht, It = Et, ht = Ve, Et = at, Ve = Oe, at = Xe, Xe = Ce + At | 0, Oe = ee + P + (Xe >>> 0 < Ce >>> 0 ? 1 : 0) | 0, ee = Z, Ce = S, Z = ae, S = G, ae = ye, G = Te, Te = At + U | 0, ye = P + L + (Te >>> 0 < At >>> 0 ? 1 : 0) | 0;
                  }
                  T = b.low = T + Te, b.high = R + ye + (T >>> 0 < Te >>> 0 ? 1 : 0), M = m.low = M + G, m.high = D + ae + (M >>> 0 < G >>> 0 ? 1 : 0), W = _.low = W + S, _.high = q + Z + (W >>> 0 < S >>> 0 ? 1 : 0), C = N.low = C + Ce, N.high = x + ee + (C >>> 0 < Ce >>> 0 ? 1 : 0), X = O.low = X + Xe, O.high = B + Oe + (X >>> 0 < Xe >>> 0 ? 1 : 0), V = y.low = V + at, y.high = J + Ve + (V >>> 0 < at >>> 0 ? 1 : 0), se = w.low = se + Et, w.high = $ + ht + (se >>> 0 < Et >>> 0 ? 1 : 0), oe = A.low = oe + It, A.high = ne + vt + (oe >>> 0 < It >>> 0 ? 1 : 0);
                },
                _doFinalize: function () {
                  var v = this._data,
                    h = v.words,
                    g = this._nDataBytes * 8,
                    b = v.sigBytes * 8;
                  h[b >>> 5] |= 128 << 24 - b % 32, h[(b + 128 >>> 10 << 5) + 30] = Math.floor(g / 4294967296), h[(b + 128 >>> 10 << 5) + 31] = g, v.sigBytes = h.length * 4, this._process();
                  var m = this._hash.toX32();
                  return m;
                },
                clone: function () {
                  var v = a.clone.call(this);
                  return v._hash = this._hash.clone(), v;
                },
                blockSize: 1024 / 32
              });
              r.SHA512 = a._createHelper(p), r.HmacSHA512 = a._createHmacHelper(p);
            }(), t.SHA512;
          });
        }(Vu)), Vu.exports;
      }
      var zu = {
          exports: {}
        },
        WO = zu.exports,
        Cy;
      function XO() {
        return Cy || (Cy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Uu(), Ey());
          })(WO, function (t) {
            return function () {
              var r = t,
                i = r.x64,
                a = i.Word,
                l = i.WordArray,
                s = r.algo,
                o = s.SHA512,
                c = s.SHA384 = o.extend({
                  _doReset: function () {
                    this._hash = new l.init([new a.init(3418070365, 3238371032), new a.init(1654270250, 914150663), new a.init(2438529370, 812702999), new a.init(355462360, 4144912697), new a.init(1731405415, 4290775857), new a.init(2394180231, 1750603025), new a.init(3675008525, 1694076839), new a.init(1203062813, 3204075428)]);
                  },
                  _doFinalize: function () {
                    var u = o._doFinalize.call(this);
                    return u.sigBytes -= 16, u;
                  }
                });
              r.SHA384 = o._createHelper(c), r.HmacSHA384 = o._createHmacHelper(c);
            }(), t.SHA384;
          });
        }(zu)), zu.exports;
      }
      var $u = {
          exports: {}
        },
        qO = $u.exports,
        Oy;
      function JO() {
        return Oy || (Oy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Uu());
          })(qO, function (t) {
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.WordArray,
                s = a.Hasher,
                o = i.x64,
                c = o.Word,
                u = i.algo,
                f = [],
                d = [],
                p = [];
              (function () {
                for (var g = 1, b = 0, m = 0; m < 24; m++) {
                  f[g + 5 * b] = (m + 1) * (m + 2) / 2 % 64;
                  var _ = b % 5,
                    N = (2 * g + 3 * b) % 5;
                  g = _, b = N;
                }
                for (var g = 0; g < 5; g++) for (var b = 0; b < 5; b++) d[g + 5 * b] = b + (2 * g + 3 * b) % 5 * 5;
                for (var O = 1, y = 0; y < 24; y++) {
                  for (var w = 0, A = 0, R = 0; R < 7; R++) {
                    if (O & 1) {
                      var T = (1 << R) - 1;
                      T < 32 ? A ^= 1 << T : w ^= 1 << T - 32;
                    }
                    O & 128 ? O = O << 1 ^ 113 : O <<= 1;
                  }
                  p[y] = c.create(w, A);
                }
              })();
              var v = [];
              (function () {
                for (var g = 0; g < 25; g++) v[g] = c.create();
              })();
              var h = u.SHA3 = s.extend({
                cfg: s.cfg.extend({
                  outputLength: 512
                }),
                _doReset: function () {
                  for (var g = this._state = [], b = 0; b < 25; b++) g[b] = new c.init();
                  this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function (g, b) {
                  for (var m = this._state, _ = this.blockSize / 2, N = 0; N < _; N++) {
                    var O = g[b + 2 * N],
                      y = g[b + 2 * N + 1];
                    O = (O << 8 | O >>> 24) & 16711935 | (O << 24 | O >>> 8) & 4278255360, y = (y << 8 | y >>> 24) & 16711935 | (y << 24 | y >>> 8) & 4278255360;
                    var w = m[N];
                    w.high ^= y, w.low ^= O;
                  }
                  for (var A = 0; A < 24; A++) {
                    for (var R = 0; R < 5; R++) {
                      for (var T = 0, D = 0, M = 0; M < 5; M++) {
                        var w = m[R + 5 * M];
                        T ^= w.high, D ^= w.low;
                      }
                      var q = v[R];
                      q.high = T, q.low = D;
                    }
                    for (var R = 0; R < 5; R++) for (var W = v[(R + 4) % 5], x = v[(R + 1) % 5], C = x.high, B = x.low, T = W.high ^ (C << 1 | B >>> 31), D = W.low ^ (B << 1 | C >>> 31), M = 0; M < 5; M++) {
                      var w = m[R + 5 * M];
                      w.high ^= T, w.low ^= D;
                    }
                    for (var X = 1; X < 25; X++) {
                      var T,
                        D,
                        w = m[X],
                        J = w.high,
                        V = w.low,
                        $ = f[X];
                      $ < 32 ? (T = J << $ | V >>> 32 - $, D = V << $ | J >>> 32 - $) : (T = V << $ - 32 | J >>> 64 - $, D = J << $ - 32 | V >>> 64 - $);
                      var se = v[d[X]];
                      se.high = T, se.low = D;
                    }
                    var ne = v[0],
                      oe = m[0];
                    ne.high = oe.high, ne.low = oe.low;
                    for (var R = 0; R < 5; R++) for (var M = 0; M < 5; M++) {
                      var X = R + 5 * M,
                        w = m[X],
                        ye = v[X],
                        Te = v[(R + 1) % 5 + 5 * M],
                        ae = v[(R + 2) % 5 + 5 * M];
                      w.high = ye.high ^ ~Te.high & ae.high, w.low = ye.low ^ ~Te.low & ae.low;
                    }
                    var w = m[0],
                      G = p[A];
                    w.high ^= G.high, w.low ^= G.low;
                  }
                },
                _doFinalize: function () {
                  var g = this._data,
                    b = g.words;
                  this._nDataBytes * 8;
                  var m = g.sigBytes * 8,
                    _ = this.blockSize * 32;
                  b[m >>> 5] |= 1 << 24 - m % 32, b[(r.ceil((m + 1) / _) * _ >>> 5) - 1] |= 128, g.sigBytes = b.length * 4, this._process();
                  for (var N = this._state, O = this.cfg.outputLength / 8, y = O / 8, w = [], A = 0; A < y; A++) {
                    var R = N[A],
                      T = R.high,
                      D = R.low;
                    T = (T << 8 | T >>> 24) & 16711935 | (T << 24 | T >>> 8) & 4278255360, D = (D << 8 | D >>> 24) & 16711935 | (D << 24 | D >>> 8) & 4278255360, w.push(D), w.push(T);
                  }
                  return new l.init(w, O);
                },
                clone: function () {
                  for (var g = s.clone.call(this), b = g._state = this._state.slice(0), m = 0; m < 25; m++) b[m] = b[m].clone();
                  return g;
                }
              });
              i.SHA3 = s._createHelper(h), i.HmacSHA3 = s._createHmacHelper(h);
            }(Math), t.SHA3;
          });
        }($u)), $u.exports;
      }
      var Qu = {
          exports: {}
        },
        GO = Qu.exports,
        Ay;
      function VO() {
        return Ay || (Ay = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(GO, function (t) {
            /** @preserve
            (c) 2012 by Cédric Mesnil. All rights reserved.
            Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
            - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
            - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.WordArray,
                s = a.Hasher,
                o = i.algo,
                c = l.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                u = l.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                f = l.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                d = l.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                p = l.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                v = l.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                h = o.RIPEMD160 = s.extend({
                  _doReset: function () {
                    this._hash = l.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                  },
                  _doProcessBlock: function (y, w) {
                    for (var A = 0; A < 16; A++) {
                      var R = w + A,
                        T = y[R];
                      y[R] = (T << 8 | T >>> 24) & 16711935 | (T << 24 | T >>> 8) & 4278255360;
                    }
                    var D = this._hash.words,
                      M = p.words,
                      q = v.words,
                      W = c.words,
                      x = u.words,
                      C = f.words,
                      B = d.words,
                      X,
                      J,
                      V,
                      $,
                      se,
                      ne,
                      oe,
                      ye,
                      Te,
                      ae;
                    ne = X = D[0], oe = J = D[1], ye = V = D[2], Te = $ = D[3], ae = se = D[4];
                    for (var G, A = 0; A < 80; A += 1) G = X + y[w + W[A]] | 0, A < 16 ? G += g(J, V, $) + M[0] : A < 32 ? G += b(J, V, $) + M[1] : A < 48 ? G += m(J, V, $) + M[2] : A < 64 ? G += _(J, V, $) + M[3] : G += N(J, V, $) + M[4], G = G | 0, G = O(G, C[A]), G = G + se | 0, X = se, se = $, $ = O(V, 10), V = J, J = G, G = ne + y[w + x[A]] | 0, A < 16 ? G += N(oe, ye, Te) + q[0] : A < 32 ? G += _(oe, ye, Te) + q[1] : A < 48 ? G += m(oe, ye, Te) + q[2] : A < 64 ? G += b(oe, ye, Te) + q[3] : G += g(oe, ye, Te) + q[4], G = G | 0, G = O(G, B[A]), G = G + ae | 0, ne = ae, ae = Te, Te = O(ye, 10), ye = oe, oe = G;
                    G = D[1] + V + Te | 0, D[1] = D[2] + $ + ae | 0, D[2] = D[3] + se + ne | 0, D[3] = D[4] + X + oe | 0, D[4] = D[0] + J + ye | 0, D[0] = G;
                  },
                  _doFinalize: function () {
                    var y = this._data,
                      w = y.words,
                      A = this._nDataBytes * 8,
                      R = y.sigBytes * 8;
                    w[R >>> 5] |= 128 << 24 - R % 32, w[(R + 64 >>> 9 << 4) + 14] = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360, y.sigBytes = (w.length + 1) * 4, this._process();
                    for (var T = this._hash, D = T.words, M = 0; M < 5; M++) {
                      var q = D[M];
                      D[M] = (q << 8 | q >>> 24) & 16711935 | (q << 24 | q >>> 8) & 4278255360;
                    }
                    return T;
                  },
                  clone: function () {
                    var y = s.clone.call(this);
                    return y._hash = this._hash.clone(), y;
                  }
                });
              function g(y, w, A) {
                return y ^ w ^ A;
              }
              function b(y, w, A) {
                return y & w | ~y & A;
              }
              function m(y, w, A) {
                return (y | ~w) ^ A;
              }
              function _(y, w, A) {
                return y & A | w & ~A;
              }
              function N(y, w, A) {
                return y ^ (w | ~A);
              }
              function O(y, w) {
                return y << w | y >>> 32 - w;
              }
              i.RIPEMD160 = s._createHelper(h), i.HmacRIPEMD160 = s._createHmacHelper(h);
            }(), t.RIPEMD160;
          });
        }(Qu)), Qu.exports;
      }
      var Yu = {
          exports: {}
        },
        zO = Yu.exports,
        Ry;
      function Od() {
        return Ry || (Ry = 1, function (n, e) {
          (function (t, r) {
            n.exports = r(_t());
          })(zO, function (t) {
            (function () {
              var r = t,
                i = r.lib,
                a = i.Base,
                l = r.enc,
                s = l.Utf8,
                o = r.algo;
              o.HMAC = a.extend({
                init: function (c, u) {
                  c = this._hasher = new c.init(), typeof u == "string" && (u = s.parse(u));
                  var f = c.blockSize,
                    d = f * 4;
                  u.sigBytes > d && (u = c.finalize(u)), u.clamp();
                  for (var p = this._oKey = u.clone(), v = this._iKey = u.clone(), h = p.words, g = v.words, b = 0; b < f; b++) h[b] ^= 1549556828, g[b] ^= 909522486;
                  p.sigBytes = v.sigBytes = d, this.reset();
                },
                reset: function () {
                  var c = this._hasher;
                  c.reset(), c.update(this._iKey);
                },
                update: function (c) {
                  return this._hasher.update(c), this;
                },
                finalize: function (c) {
                  var u = this._hasher,
                    f = u.finalize(c);
                  u.reset();
                  var d = u.finalize(this._oKey.clone().concat(f));
                  return d;
                }
              });
            })();
          });
        }(Yu)), Yu.exports;
      }
      var Zu = {
          exports: {}
        },
        $O = Zu.exports,
        Ny;
      function QO() {
        return Ny || (Ny = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Cd(), Od());
          })($O, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.Base,
                l = i.WordArray,
                s = r.algo,
                o = s.SHA256,
                c = s.HMAC,
                u = s.PBKDF2 = a.extend({
                  cfg: a.extend({
                    keySize: 128 / 32,
                    hasher: o,
                    iterations: 25e4
                  }),
                  init: function (f) {
                    this.cfg = this.cfg.extend(f);
                  },
                  compute: function (f, d) {
                    for (var p = this.cfg, v = c.create(p.hasher, f), h = l.create(), g = l.create([1]), b = h.words, m = g.words, _ = p.keySize, N = p.iterations; b.length < _;) {
                      var O = v.update(d).finalize(g);
                      v.reset();
                      for (var y = O.words, w = y.length, A = O, R = 1; R < N; R++) {
                        A = v.finalize(A), v.reset();
                        for (var T = A.words, D = 0; D < w; D++) y[D] ^= T[D];
                      }
                      h.concat(O), m[0]++;
                    }
                    return h.sigBytes = _ * 4, h;
                  }
                });
              r.PBKDF2 = function (f, d, p) {
                return u.create(p).compute(f, d);
              };
            }(), t.PBKDF2;
          });
        }(Zu)), Zu.exports;
      }
      var ef = {
          exports: {}
        },
        YO = ef.exports,
        Sy;
      function Xi() {
        return Sy || (Sy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), by(), Od());
          })(YO, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.Base,
                l = i.WordArray,
                s = r.algo,
                o = s.MD5,
                c = s.EvpKDF = a.extend({
                  cfg: a.extend({
                    keySize: 128 / 32,
                    hasher: o,
                    iterations: 1
                  }),
                  init: function (u) {
                    this.cfg = this.cfg.extend(u);
                  },
                  compute: function (u, f) {
                    for (var d, p = this.cfg, v = p.hasher.create(), h = l.create(), g = h.words, b = p.keySize, m = p.iterations; g.length < b;) {
                      d && v.update(d), d = v.update(u).finalize(f), v.reset();
                      for (var _ = 1; _ < m; _++) d = v.finalize(d), v.reset();
                      h.concat(d);
                    }
                    return h.sigBytes = b * 4, h;
                  }
                });
              r.EvpKDF = function (u, f, d) {
                return c.create(d).compute(u, f);
              };
            }(), t.EvpKDF;
          });
        }(ef)), ef.exports;
      }
      var tf = {
          exports: {}
        },
        ZO = tf.exports,
        Ty;
      function En() {
        return Ty || (Ty = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Xi());
          })(ZO, function (t) {
            t.lib.Cipher || function (r) {
              var i = t,
                a = i.lib,
                l = a.Base,
                s = a.WordArray,
                o = a.BufferedBlockAlgorithm,
                c = i.enc;
              c.Utf8;
              var u = c.Base64,
                f = i.algo,
                d = f.EvpKDF,
                p = a.Cipher = o.extend({
                  cfg: l.extend(),
                  createEncryptor: function (T, D) {
                    return this.create(this._ENC_XFORM_MODE, T, D);
                  },
                  createDecryptor: function (T, D) {
                    return this.create(this._DEC_XFORM_MODE, T, D);
                  },
                  init: function (T, D, M) {
                    this.cfg = this.cfg.extend(M), this._xformMode = T, this._key = D, this.reset();
                  },
                  reset: function () {
                    o.reset.call(this), this._doReset();
                  },
                  process: function (T) {
                    return this._append(T), this._process();
                  },
                  finalize: function (T) {
                    T && this._append(T);
                    var D = this._doFinalize();
                    return D;
                  },
                  keySize: 128 / 32,
                  ivSize: 128 / 32,
                  _ENC_XFORM_MODE: 1,
                  _DEC_XFORM_MODE: 2,
                  _createHelper: function () {
                    function T(D) {
                      return typeof D == "string" ? R : y;
                    }
                    return function (D) {
                      return {
                        encrypt: function (M, q, W) {
                          return T(q).encrypt(D, M, q, W);
                        },
                        decrypt: function (M, q, W) {
                          return T(q).decrypt(D, M, q, W);
                        }
                      };
                    };
                  }()
                });
              a.StreamCipher = p.extend({
                _doFinalize: function () {
                  var T = this._process(!0);
                  return T;
                },
                blockSize: 1
              });
              var v = i.mode = {},
                h = a.BlockCipherMode = l.extend({
                  createEncryptor: function (T, D) {
                    return this.Encryptor.create(T, D);
                  },
                  createDecryptor: function (T, D) {
                    return this.Decryptor.create(T, D);
                  },
                  init: function (T, D) {
                    this._cipher = T, this._iv = D;
                  }
                }),
                g = v.CBC = function () {
                  var T = h.extend();
                  T.Encryptor = T.extend({
                    processBlock: function (M, q) {
                      var W = this._cipher,
                        x = W.blockSize;
                      D.call(this, M, q, x), W.encryptBlock(M, q), this._prevBlock = M.slice(q, q + x);
                    }
                  }), T.Decryptor = T.extend({
                    processBlock: function (M, q) {
                      var W = this._cipher,
                        x = W.blockSize,
                        C = M.slice(q, q + x);
                      W.decryptBlock(M, q), D.call(this, M, q, x), this._prevBlock = C;
                    }
                  });
                  function D(M, q, W) {
                    var x,
                      C = this._iv;
                    C ? (x = C, this._iv = r) : x = this._prevBlock;
                    for (var B = 0; B < W; B++) M[q + B] ^= x[B];
                  }
                  return T;
                }(),
                b = i.pad = {},
                m = b.Pkcs7 = {
                  pad: function (T, D) {
                    for (var M = D * 4, q = M - T.sigBytes % M, W = q << 24 | q << 16 | q << 8 | q, x = [], C = 0; C < q; C += 4) x.push(W);
                    var B = s.create(x, q);
                    T.concat(B);
                  },
                  unpad: function (T) {
                    var D = T.words[T.sigBytes - 1 >>> 2] & 255;
                    T.sigBytes -= D;
                  }
                };
              a.BlockCipher = p.extend({
                cfg: p.cfg.extend({
                  mode: g,
                  padding: m
                }),
                reset: function () {
                  var T;
                  p.reset.call(this);
                  var D = this.cfg,
                    M = D.iv,
                    q = D.mode;
                  this._xformMode == this._ENC_XFORM_MODE ? T = q.createEncryptor : (T = q.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == T ? this._mode.init(this, M && M.words) : (this._mode = T.call(q, this, M && M.words), this._mode.__creator = T);
                },
                _doProcessBlock: function (T, D) {
                  this._mode.processBlock(T, D);
                },
                _doFinalize: function () {
                  var T,
                    D = this.cfg.padding;
                  return this._xformMode == this._ENC_XFORM_MODE ? (D.pad(this._data, this.blockSize), T = this._process(!0)) : (T = this._process(!0), D.unpad(T)), T;
                },
                blockSize: 128 / 32
              });
              var _ = a.CipherParams = l.extend({
                  init: function (T) {
                    this.mixIn(T);
                  },
                  toString: function (T) {
                    return (T || this.formatter).stringify(this);
                  }
                }),
                N = i.format = {},
                O = N.OpenSSL = {
                  stringify: function (T) {
                    var D,
                      M = T.ciphertext,
                      q = T.salt;
                    return q ? D = s.create([1398893684, 1701076831]).concat(q).concat(M) : D = M, D.toString(u);
                  },
                  parse: function (T) {
                    var D,
                      M = u.parse(T),
                      q = M.words;
                    return q[0] == 1398893684 && q[1] == 1701076831 && (D = s.create(q.slice(2, 4)), q.splice(0, 4), M.sigBytes -= 16), _.create({
                      ciphertext: M,
                      salt: D
                    });
                  }
                },
                y = a.SerializableCipher = l.extend({
                  cfg: l.extend({
                    format: O
                  }),
                  encrypt: function (T, D, M, q) {
                    q = this.cfg.extend(q);
                    var W = T.createEncryptor(M, q),
                      x = W.finalize(D),
                      C = W.cfg;
                    return _.create({
                      ciphertext: x,
                      key: M,
                      iv: C.iv,
                      algorithm: T,
                      mode: C.mode,
                      padding: C.padding,
                      blockSize: T.blockSize,
                      formatter: q.format
                    });
                  },
                  decrypt: function (T, D, M, q) {
                    q = this.cfg.extend(q), D = this._parse(D, q.format);
                    var W = T.createDecryptor(M, q).finalize(D.ciphertext);
                    return W;
                  },
                  _parse: function (T, D) {
                    return typeof T == "string" ? D.parse(T, this) : T;
                  }
                }),
                w = i.kdf = {},
                A = w.OpenSSL = {
                  execute: function (T, D, M, q, W) {
                    if (q || (q = s.random(64 / 8)), W) var x = d.create({
                      keySize: D + M,
                      hasher: W
                    }).compute(T, q);else var x = d.create({
                      keySize: D + M
                    }).compute(T, q);
                    var C = s.create(x.words.slice(D), M * 4);
                    return x.sigBytes = D * 4, _.create({
                      key: x,
                      iv: C,
                      salt: q
                    });
                  }
                },
                R = a.PasswordBasedCipher = y.extend({
                  cfg: y.cfg.extend({
                    kdf: A
                  }),
                  encrypt: function (T, D, M, q) {
                    q = this.cfg.extend(q);
                    var W = q.kdf.execute(M, T.keySize, T.ivSize, q.salt, q.hasher);
                    q.iv = W.iv;
                    var x = y.encrypt.call(this, T, D, W.key, q);
                    return x.mixIn(W), x;
                  },
                  decrypt: function (T, D, M, q) {
                    q = this.cfg.extend(q), D = this._parse(D, q.format);
                    var W = q.kdf.execute(M, T.keySize, T.ivSize, D.salt, q.hasher);
                    q.iv = W.iv;
                    var x = y.decrypt.call(this, T, D, W.key, q);
                    return x;
                  }
                });
            }();
          });
        }(tf)), tf.exports;
      }
      var nf = {
          exports: {}
        },
        eA = nf.exports,
        Dy;
      function tA() {
        return Dy || (Dy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(eA, function (t) {
            return t.mode.CFB = function () {
              var r = t.lib.BlockCipherMode.extend();
              r.Encryptor = r.extend({
                processBlock: function (a, l) {
                  var s = this._cipher,
                    o = s.blockSize;
                  i.call(this, a, l, o, s), this._prevBlock = a.slice(l, l + o);
                }
              }), r.Decryptor = r.extend({
                processBlock: function (a, l) {
                  var s = this._cipher,
                    o = s.blockSize,
                    c = a.slice(l, l + o);
                  i.call(this, a, l, o, s), this._prevBlock = c;
                }
              });
              function i(a, l, s, o) {
                var c,
                  u = this._iv;
                u ? (c = u.slice(0), this._iv = void 0) : c = this._prevBlock, o.encryptBlock(c, 0);
                for (var f = 0; f < s; f++) a[l + f] ^= c[f];
              }
              return r;
            }(), t.mode.CFB;
          });
        }(nf)), nf.exports;
      }
      var rf = {
          exports: {}
        },
        nA = rf.exports,
        Py;
      function rA() {
        return Py || (Py = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(nA, function (t) {
            return t.mode.CTR = function () {
              var r = t.lib.BlockCipherMode.extend(),
                i = r.Encryptor = r.extend({
                  processBlock: function (a, l) {
                    var s = this._cipher,
                      o = s.blockSize,
                      c = this._iv,
                      u = this._counter;
                    c && (u = this._counter = c.slice(0), this._iv = void 0);
                    var f = u.slice(0);
                    s.encryptBlock(f, 0), u[o - 1] = u[o - 1] + 1 | 0;
                    for (var d = 0; d < o; d++) a[l + d] ^= f[d];
                  }
                });
              return r.Decryptor = i, r;
            }(), t.mode.CTR;
          });
        }(rf)), rf.exports;
      }
      var of = {
          exports: {}
        },
        iA = of.exports,
        Iy;
      function oA() {
        return Iy || (Iy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(iA, function (t) {
            /** @preserve
            * Counter block mode compatible with  Dr Brian Gladman fileenc.c
            * derived from CryptoJS.mode.CTR
            * Jan Hruby jhruby.web@gmail.com
            */
            return t.mode.CTRGladman = function () {
              var r = t.lib.BlockCipherMode.extend();
              function i(s) {
                if ((s >> 24 & 255) === 255) {
                  var o = s >> 16 & 255,
                    c = s >> 8 & 255,
                    u = s & 255;
                  o === 255 ? (o = 0, c === 255 ? (c = 0, u === 255 ? u = 0 : ++u) : ++c) : ++o, s = 0, s += o << 16, s += c << 8, s += u;
                } else s += 1 << 24;
                return s;
              }
              function a(s) {
                return (s[0] = i(s[0])) === 0 && (s[1] = i(s[1])), s;
              }
              var l = r.Encryptor = r.extend({
                processBlock: function (s, o) {
                  var c = this._cipher,
                    u = c.blockSize,
                    f = this._iv,
                    d = this._counter;
                  f && (d = this._counter = f.slice(0), this._iv = void 0), a(d);
                  var p = d.slice(0);
                  c.encryptBlock(p, 0);
                  for (var v = 0; v < u; v++) s[o + v] ^= p[v];
                }
              });
              return r.Decryptor = l, r;
            }(), t.mode.CTRGladman;
          });
        }(of)), of.exports;
      }
      var sf = {
          exports: {}
        },
        sA = sf.exports,
        By;
      function aA() {
        return By || (By = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(sA, function (t) {
            return t.mode.OFB = function () {
              var r = t.lib.BlockCipherMode.extend(),
                i = r.Encryptor = r.extend({
                  processBlock: function (a, l) {
                    var s = this._cipher,
                      o = s.blockSize,
                      c = this._iv,
                      u = this._keystream;
                    c && (u = this._keystream = c.slice(0), this._iv = void 0), s.encryptBlock(u, 0);
                    for (var f = 0; f < o; f++) a[l + f] ^= u[f];
                  }
                });
              return r.Decryptor = i, r;
            }(), t.mode.OFB;
          });
        }(sf)), sf.exports;
      }
      var af = {
          exports: {}
        },
        cA = af.exports,
        ky;
      function lA() {
        return ky || (ky = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(cA, function (t) {
            return t.mode.ECB = function () {
              var r = t.lib.BlockCipherMode.extend();
              return r.Encryptor = r.extend({
                processBlock: function (i, a) {
                  this._cipher.encryptBlock(i, a);
                }
              }), r.Decryptor = r.extend({
                processBlock: function (i, a) {
                  this._cipher.decryptBlock(i, a);
                }
              }), r;
            }(), t.mode.ECB;
          });
        }(af)), af.exports;
      }
      var cf = {
          exports: {}
        },
        uA = cf.exports,
        My;
      function fA() {
        return My || (My = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(uA, function (t) {
            return t.pad.AnsiX923 = {
              pad: function (r, i) {
                var a = r.sigBytes,
                  l = i * 4,
                  s = l - a % l,
                  o = a + s - 1;
                r.clamp(), r.words[o >>> 2] |= s << 24 - o % 4 * 8, r.sigBytes += s;
              },
              unpad: function (r) {
                var i = r.words[r.sigBytes - 1 >>> 2] & 255;
                r.sigBytes -= i;
              }
            }, t.pad.Ansix923;
          });
        }(cf)), cf.exports;
      }
      var lf = {
          exports: {}
        },
        dA = lf.exports,
        Ky;
      function hA() {
        return Ky || (Ky = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(dA, function (t) {
            return t.pad.Iso10126 = {
              pad: function (r, i) {
                var a = i * 4,
                  l = a - r.sigBytes % a;
                r.concat(t.lib.WordArray.random(l - 1)).concat(t.lib.WordArray.create([l << 24], 1));
              },
              unpad: function (r) {
                var i = r.words[r.sigBytes - 1 >>> 2] & 255;
                r.sigBytes -= i;
              }
            }, t.pad.Iso10126;
          });
        }(lf)), lf.exports;
      }
      var uf = {
          exports: {}
        },
        pA = uf.exports,
        Ly;
      function gA() {
        return Ly || (Ly = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(pA, function (t) {
            return t.pad.Iso97971 = {
              pad: function (r, i) {
                r.concat(t.lib.WordArray.create([2147483648], 1)), t.pad.ZeroPadding.pad(r, i);
              },
              unpad: function (r) {
                t.pad.ZeroPadding.unpad(r), r.sigBytes--;
              }
            }, t.pad.Iso97971;
          });
        }(uf)), uf.exports;
      }
      var ff = {
          exports: {}
        },
        vA = ff.exports,
        Uy;
      function yA() {
        return Uy || (Uy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(vA, function (t) {
            return t.pad.ZeroPadding = {
              pad: function (r, i) {
                var a = i * 4;
                r.clamp(), r.sigBytes += a - (r.sigBytes % a || a);
              },
              unpad: function (r) {
                for (var i = r.words, a = r.sigBytes - 1, a = r.sigBytes - 1; a >= 0; a--) if (i[a >>> 2] >>> 24 - a % 4 * 8 & 255) {
                  r.sigBytes = a + 1;
                  break;
                }
              }
            }, t.pad.ZeroPadding;
          });
        }(ff)), ff.exports;
      }
      var df = {
          exports: {}
        },
        mA = df.exports,
        Fy;
      function bA() {
        return Fy || (Fy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(mA, function (t) {
            return t.pad.NoPadding = {
              pad: function () {},
              unpad: function () {}
            }, t.pad.NoPadding;
          });
        }(df)), df.exports;
      }
      var hf = {
          exports: {}
        },
        wA = hf.exports,
        Hy;
      function xA() {
        return Hy || (Hy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), En());
          })(wA, function (t) {
            return function (r) {
              var i = t,
                a = i.lib,
                l = a.CipherParams,
                s = i.enc,
                o = s.Hex,
                c = i.format;
              c.Hex = {
                stringify: function (u) {
                  return u.ciphertext.toString(o);
                },
                parse: function (u) {
                  var f = o.parse(u);
                  return l.create({
                    ciphertext: f
                  });
                }
              };
            }(), t.format.Hex;
          });
        }(hf)), hf.exports;
      }
      var pf = {
          exports: {}
        },
        _A = pf.exports,
        jy;
      function EA() {
        return jy || (jy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(_A, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.BlockCipher,
                l = r.algo,
                s = [],
                o = [],
                c = [],
                u = [],
                f = [],
                d = [],
                p = [],
                v = [],
                h = [],
                g = [];
              (function () {
                for (var _ = [], N = 0; N < 256; N++) N < 128 ? _[N] = N << 1 : _[N] = N << 1 ^ 283;
                for (var O = 0, y = 0, N = 0; N < 256; N++) {
                  var w = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
                  w = w >>> 8 ^ w & 255 ^ 99, s[O] = w, o[w] = O;
                  var A = _[O],
                    R = _[A],
                    T = _[R],
                    D = _[w] * 257 ^ w * 16843008;
                  c[O] = D << 24 | D >>> 8, u[O] = D << 16 | D >>> 16, f[O] = D << 8 | D >>> 24, d[O] = D;
                  var D = T * 16843009 ^ R * 65537 ^ A * 257 ^ O * 16843008;
                  p[w] = D << 24 | D >>> 8, v[w] = D << 16 | D >>> 16, h[w] = D << 8 | D >>> 24, g[w] = D, O ? (O = A ^ _[_[_[T ^ A]]], y ^= _[_[y]]) : O = y = 1;
                }
              })();
              var b = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                m = l.AES = a.extend({
                  _doReset: function () {
                    var _;
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                      for (var N = this._keyPriorReset = this._key, O = N.words, y = N.sigBytes / 4, w = this._nRounds = y + 6, A = (w + 1) * 4, R = this._keySchedule = [], T = 0; T < A; T++) T < y ? R[T] = O[T] : (_ = R[T - 1], T % y ? y > 6 && T % y == 4 && (_ = s[_ >>> 24] << 24 | s[_ >>> 16 & 255] << 16 | s[_ >>> 8 & 255] << 8 | s[_ & 255]) : (_ = _ << 8 | _ >>> 24, _ = s[_ >>> 24] << 24 | s[_ >>> 16 & 255] << 16 | s[_ >>> 8 & 255] << 8 | s[_ & 255], _ ^= b[T / y | 0] << 24), R[T] = R[T - y] ^ _);
                      for (var D = this._invKeySchedule = [], M = 0; M < A; M++) {
                        var T = A - M;
                        if (M % 4) var _ = R[T];else var _ = R[T - 4];
                        M < 4 || T <= 4 ? D[M] = _ : D[M] = p[s[_ >>> 24]] ^ v[s[_ >>> 16 & 255]] ^ h[s[_ >>> 8 & 255]] ^ g[s[_ & 255]];
                      }
                    }
                  },
                  encryptBlock: function (_, N) {
                    this._doCryptBlock(_, N, this._keySchedule, c, u, f, d, s);
                  },
                  decryptBlock: function (_, N) {
                    var O = _[N + 1];
                    _[N + 1] = _[N + 3], _[N + 3] = O, this._doCryptBlock(_, N, this._invKeySchedule, p, v, h, g, o);
                    var O = _[N + 1];
                    _[N + 1] = _[N + 3], _[N + 3] = O;
                  },
                  _doCryptBlock: function (_, N, O, y, w, A, R, T) {
                    for (var D = this._nRounds, M = _[N] ^ O[0], q = _[N + 1] ^ O[1], W = _[N + 2] ^ O[2], x = _[N + 3] ^ O[3], C = 4, B = 1; B < D; B++) {
                      var X = y[M >>> 24] ^ w[q >>> 16 & 255] ^ A[W >>> 8 & 255] ^ R[x & 255] ^ O[C++],
                        J = y[q >>> 24] ^ w[W >>> 16 & 255] ^ A[x >>> 8 & 255] ^ R[M & 255] ^ O[C++],
                        V = y[W >>> 24] ^ w[x >>> 16 & 255] ^ A[M >>> 8 & 255] ^ R[q & 255] ^ O[C++],
                        $ = y[x >>> 24] ^ w[M >>> 16 & 255] ^ A[q >>> 8 & 255] ^ R[W & 255] ^ O[C++];
                      M = X, q = J, W = V, x = $;
                    }
                    var X = (T[M >>> 24] << 24 | T[q >>> 16 & 255] << 16 | T[W >>> 8 & 255] << 8 | T[x & 255]) ^ O[C++],
                      J = (T[q >>> 24] << 24 | T[W >>> 16 & 255] << 16 | T[x >>> 8 & 255] << 8 | T[M & 255]) ^ O[C++],
                      V = (T[W >>> 24] << 24 | T[x >>> 16 & 255] << 16 | T[M >>> 8 & 255] << 8 | T[q & 255]) ^ O[C++],
                      $ = (T[x >>> 24] << 24 | T[M >>> 16 & 255] << 16 | T[q >>> 8 & 255] << 8 | T[W & 255]) ^ O[C++];
                    _[N] = X, _[N + 1] = J, _[N + 2] = V, _[N + 3] = $;
                  },
                  keySize: 256 / 32
                });
              r.AES = a._createHelper(m);
            }(), t.AES;
          });
        }(pf)), pf.exports;
      }
      var gf = {
          exports: {}
        },
        CA = gf.exports,
        Wy;
      function OA() {
        return Wy || (Wy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(CA, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.WordArray,
                l = i.BlockCipher,
                s = r.algo,
                o = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                c = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                u = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                f = [{
                  0: 8421888,
                  268435456: 32768,
                  536870912: 8421378,
                  805306368: 2,
                  1073741824: 512,
                  1342177280: 8421890,
                  1610612736: 8389122,
                  1879048192: 8388608,
                  2147483648: 514,
                  2415919104: 8389120,
                  2684354560: 33280,
                  2952790016: 8421376,
                  3221225472: 32770,
                  3489660928: 8388610,
                  3758096384: 0,
                  4026531840: 33282,
                  134217728: 0,
                  402653184: 8421890,
                  671088640: 33282,
                  939524096: 32768,
                  1207959552: 8421888,
                  1476395008: 512,
                  1744830464: 8421378,
                  2013265920: 2,
                  2281701376: 8389120,
                  2550136832: 33280,
                  2818572288: 8421376,
                  3087007744: 8389122,
                  3355443200: 8388610,
                  3623878656: 32770,
                  3892314112: 514,
                  4160749568: 8388608,
                  1: 32768,
                  268435457: 2,
                  536870913: 8421888,
                  805306369: 8388608,
                  1073741825: 8421378,
                  1342177281: 33280,
                  1610612737: 512,
                  1879048193: 8389122,
                  2147483649: 8421890,
                  2415919105: 8421376,
                  2684354561: 8388610,
                  2952790017: 33282,
                  3221225473: 514,
                  3489660929: 8389120,
                  3758096385: 32770,
                  4026531841: 0,
                  134217729: 8421890,
                  402653185: 8421376,
                  671088641: 8388608,
                  939524097: 512,
                  1207959553: 32768,
                  1476395009: 8388610,
                  1744830465: 2,
                  2013265921: 33282,
                  2281701377: 32770,
                  2550136833: 8389122,
                  2818572289: 514,
                  3087007745: 8421888,
                  3355443201: 8389120,
                  3623878657: 0,
                  3892314113: 33280,
                  4160749569: 8421378
                }, {
                  0: 1074282512,
                  16777216: 16384,
                  33554432: 524288,
                  50331648: 1074266128,
                  67108864: 1073741840,
                  83886080: 1074282496,
                  100663296: 1073758208,
                  117440512: 16,
                  134217728: 540672,
                  150994944: 1073758224,
                  167772160: 1073741824,
                  184549376: 540688,
                  201326592: 524304,
                  218103808: 0,
                  234881024: 16400,
                  251658240: 1074266112,
                  8388608: 1073758208,
                  25165824: 540688,
                  41943040: 16,
                  58720256: 1073758224,
                  75497472: 1074282512,
                  92274688: 1073741824,
                  109051904: 524288,
                  125829120: 1074266128,
                  142606336: 524304,
                  159383552: 0,
                  176160768: 16384,
                  192937984: 1074266112,
                  209715200: 1073741840,
                  226492416: 540672,
                  243269632: 1074282496,
                  260046848: 16400,
                  268435456: 0,
                  285212672: 1074266128,
                  301989888: 1073758224,
                  318767104: 1074282496,
                  335544320: 1074266112,
                  352321536: 16,
                  369098752: 540688,
                  385875968: 16384,
                  402653184: 16400,
                  419430400: 524288,
                  436207616: 524304,
                  452984832: 1073741840,
                  469762048: 540672,
                  486539264: 1073758208,
                  503316480: 1073741824,
                  520093696: 1074282512,
                  276824064: 540688,
                  293601280: 524288,
                  310378496: 1074266112,
                  327155712: 16384,
                  343932928: 1073758208,
                  360710144: 1074282512,
                  377487360: 16,
                  394264576: 1073741824,
                  411041792: 1074282496,
                  427819008: 1073741840,
                  444596224: 1073758224,
                  461373440: 524304,
                  478150656: 0,
                  494927872: 16400,
                  511705088: 1074266128,
                  528482304: 540672
                }, {
                  0: 260,
                  1048576: 0,
                  2097152: 67109120,
                  3145728: 65796,
                  4194304: 65540,
                  5242880: 67108868,
                  6291456: 67174660,
                  7340032: 67174400,
                  8388608: 67108864,
                  9437184: 67174656,
                  10485760: 65792,
                  11534336: 67174404,
                  12582912: 67109124,
                  13631488: 65536,
                  14680064: 4,
                  15728640: 256,
                  524288: 67174656,
                  1572864: 67174404,
                  2621440: 0,
                  3670016: 67109120,
                  4718592: 67108868,
                  5767168: 65536,
                  6815744: 65540,
                  7864320: 260,
                  8912896: 4,
                  9961472: 256,
                  11010048: 67174400,
                  12058624: 65796,
                  13107200: 65792,
                  14155776: 67109124,
                  15204352: 67174660,
                  16252928: 67108864,
                  16777216: 67174656,
                  17825792: 65540,
                  18874368: 65536,
                  19922944: 67109120,
                  20971520: 256,
                  22020096: 67174660,
                  23068672: 67108868,
                  24117248: 0,
                  25165824: 67109124,
                  26214400: 67108864,
                  27262976: 4,
                  28311552: 65792,
                  29360128: 67174400,
                  30408704: 260,
                  31457280: 65796,
                  32505856: 67174404,
                  17301504: 67108864,
                  18350080: 260,
                  19398656: 67174656,
                  20447232: 0,
                  21495808: 65540,
                  22544384: 67109120,
                  23592960: 256,
                  24641536: 67174404,
                  25690112: 65536,
                  26738688: 67174660,
                  27787264: 65796,
                  28835840: 67108868,
                  29884416: 67109124,
                  30932992: 67174400,
                  31981568: 4,
                  33030144: 65792
                }, {
                  0: 2151682048,
                  65536: 2147487808,
                  131072: 4198464,
                  196608: 2151677952,
                  262144: 0,
                  327680: 4198400,
                  393216: 2147483712,
                  458752: 4194368,
                  524288: 2147483648,
                  589824: 4194304,
                  655360: 64,
                  720896: 2147487744,
                  786432: 2151678016,
                  851968: 4160,
                  917504: 4096,
                  983040: 2151682112,
                  32768: 2147487808,
                  98304: 64,
                  163840: 2151678016,
                  229376: 2147487744,
                  294912: 4198400,
                  360448: 2151682112,
                  425984: 0,
                  491520: 2151677952,
                  557056: 4096,
                  622592: 2151682048,
                  688128: 4194304,
                  753664: 4160,
                  819200: 2147483648,
                  884736: 4194368,
                  950272: 4198464,
                  1015808: 2147483712,
                  1048576: 4194368,
                  1114112: 4198400,
                  1179648: 2147483712,
                  1245184: 0,
                  1310720: 4160,
                  1376256: 2151678016,
                  1441792: 2151682048,
                  1507328: 2147487808,
                  1572864: 2151682112,
                  1638400: 2147483648,
                  1703936: 2151677952,
                  1769472: 4198464,
                  1835008: 2147487744,
                  1900544: 4194304,
                  1966080: 64,
                  2031616: 4096,
                  1081344: 2151677952,
                  1146880: 2151682112,
                  1212416: 0,
                  1277952: 4198400,
                  1343488: 4194368,
                  1409024: 2147483648,
                  1474560: 2147487808,
                  1540096: 64,
                  1605632: 2147483712,
                  1671168: 4096,
                  1736704: 2147487744,
                  1802240: 2151678016,
                  1867776: 4160,
                  1933312: 2151682048,
                  1998848: 4194304,
                  2064384: 4198464
                }, {
                  0: 128,
                  4096: 17039360,
                  8192: 262144,
                  12288: 536870912,
                  16384: 537133184,
                  20480: 16777344,
                  24576: 553648256,
                  28672: 262272,
                  32768: 16777216,
                  36864: 537133056,
                  40960: 536871040,
                  45056: 553910400,
                  49152: 553910272,
                  53248: 0,
                  57344: 17039488,
                  61440: 553648128,
                  2048: 17039488,
                  6144: 553648256,
                  10240: 128,
                  14336: 17039360,
                  18432: 262144,
                  22528: 537133184,
                  26624: 553910272,
                  30720: 536870912,
                  34816: 537133056,
                  38912: 0,
                  43008: 553910400,
                  47104: 16777344,
                  51200: 536871040,
                  55296: 553648128,
                  59392: 16777216,
                  63488: 262272,
                  65536: 262144,
                  69632: 128,
                  73728: 536870912,
                  77824: 553648256,
                  81920: 16777344,
                  86016: 553910272,
                  90112: 537133184,
                  94208: 16777216,
                  98304: 553910400,
                  102400: 553648128,
                  106496: 17039360,
                  110592: 537133056,
                  114688: 262272,
                  118784: 536871040,
                  122880: 0,
                  126976: 17039488,
                  67584: 553648256,
                  71680: 16777216,
                  75776: 17039360,
                  79872: 537133184,
                  83968: 536870912,
                  88064: 17039488,
                  92160: 128,
                  96256: 553910272,
                  100352: 262272,
                  104448: 553910400,
                  108544: 0,
                  112640: 553648128,
                  116736: 16777344,
                  120832: 262144,
                  124928: 537133056,
                  129024: 536871040
                }, {
                  0: 268435464,
                  256: 8192,
                  512: 270532608,
                  768: 270540808,
                  1024: 268443648,
                  1280: 2097152,
                  1536: 2097160,
                  1792: 268435456,
                  2048: 0,
                  2304: 268443656,
                  2560: 2105344,
                  2816: 8,
                  3072: 270532616,
                  3328: 2105352,
                  3584: 8200,
                  3840: 270540800,
                  128: 270532608,
                  384: 270540808,
                  640: 8,
                  896: 2097152,
                  1152: 2105352,
                  1408: 268435464,
                  1664: 268443648,
                  1920: 8200,
                  2176: 2097160,
                  2432: 8192,
                  2688: 268443656,
                  2944: 270532616,
                  3200: 0,
                  3456: 270540800,
                  3712: 2105344,
                  3968: 268435456,
                  4096: 268443648,
                  4352: 270532616,
                  4608: 270540808,
                  4864: 8200,
                  5120: 2097152,
                  5376: 268435456,
                  5632: 268435464,
                  5888: 2105344,
                  6144: 2105352,
                  6400: 0,
                  6656: 8,
                  6912: 270532608,
                  7168: 8192,
                  7424: 268443656,
                  7680: 270540800,
                  7936: 2097160,
                  4224: 8,
                  4480: 2105344,
                  4736: 2097152,
                  4992: 268435464,
                  5248: 268443648,
                  5504: 8200,
                  5760: 270540808,
                  6016: 270532608,
                  6272: 270540800,
                  6528: 270532616,
                  6784: 8192,
                  7040: 2105352,
                  7296: 2097160,
                  7552: 0,
                  7808: 268435456,
                  8064: 268443656
                }, {
                  0: 1048576,
                  16: 33555457,
                  32: 1024,
                  48: 1049601,
                  64: 34604033,
                  80: 0,
                  96: 1,
                  112: 34603009,
                  128: 33555456,
                  144: 1048577,
                  160: 33554433,
                  176: 34604032,
                  192: 34603008,
                  208: 1025,
                  224: 1049600,
                  240: 33554432,
                  8: 34603009,
                  24: 0,
                  40: 33555457,
                  56: 34604032,
                  72: 1048576,
                  88: 33554433,
                  104: 33554432,
                  120: 1025,
                  136: 1049601,
                  152: 33555456,
                  168: 34603008,
                  184: 1048577,
                  200: 1024,
                  216: 34604033,
                  232: 1,
                  248: 1049600,
                  256: 33554432,
                  272: 1048576,
                  288: 33555457,
                  304: 34603009,
                  320: 1048577,
                  336: 33555456,
                  352: 34604032,
                  368: 1049601,
                  384: 1025,
                  400: 34604033,
                  416: 1049600,
                  432: 1,
                  448: 0,
                  464: 34603008,
                  480: 33554433,
                  496: 1024,
                  264: 1049600,
                  280: 33555457,
                  296: 34603009,
                  312: 1,
                  328: 33554432,
                  344: 1048576,
                  360: 1025,
                  376: 34604032,
                  392: 33554433,
                  408: 34603008,
                  424: 0,
                  440: 34604033,
                  456: 1049601,
                  472: 1024,
                  488: 33555456,
                  504: 1048577
                }, {
                  0: 134219808,
                  1: 131072,
                  2: 134217728,
                  3: 32,
                  4: 131104,
                  5: 134350880,
                  6: 134350848,
                  7: 2048,
                  8: 134348800,
                  9: 134219776,
                  10: 133120,
                  11: 134348832,
                  12: 2080,
                  13: 0,
                  14: 134217760,
                  15: 133152,
                  2147483648: 2048,
                  2147483649: 134350880,
                  2147483650: 134219808,
                  2147483651: 134217728,
                  2147483652: 134348800,
                  2147483653: 133120,
                  2147483654: 133152,
                  2147483655: 32,
                  2147483656: 134217760,
                  2147483657: 2080,
                  2147483658: 131104,
                  2147483659: 134350848,
                  2147483660: 0,
                  2147483661: 134348832,
                  2147483662: 134219776,
                  2147483663: 131072,
                  16: 133152,
                  17: 134350848,
                  18: 32,
                  19: 2048,
                  20: 134219776,
                  21: 134217760,
                  22: 134348832,
                  23: 131072,
                  24: 0,
                  25: 131104,
                  26: 134348800,
                  27: 134219808,
                  28: 134350880,
                  29: 133120,
                  30: 2080,
                  31: 134217728,
                  2147483664: 131072,
                  2147483665: 2048,
                  2147483666: 134348832,
                  2147483667: 133152,
                  2147483668: 32,
                  2147483669: 134348800,
                  2147483670: 134217728,
                  2147483671: 134219808,
                  2147483672: 134350880,
                  2147483673: 134217760,
                  2147483674: 134219776,
                  2147483675: 0,
                  2147483676: 133120,
                  2147483677: 2080,
                  2147483678: 131104,
                  2147483679: 134350848
                }],
                d = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                p = s.DES = l.extend({
                  _doReset: function () {
                    for (var b = this._key, m = b.words, _ = [], N = 0; N < 56; N++) {
                      var O = o[N] - 1;
                      _[N] = m[O >>> 5] >>> 31 - O % 32 & 1;
                    }
                    for (var y = this._subKeys = [], w = 0; w < 16; w++) {
                      for (var A = y[w] = [], R = u[w], N = 0; N < 24; N++) A[N / 6 | 0] |= _[(c[N] - 1 + R) % 28] << 31 - N % 6, A[4 + (N / 6 | 0)] |= _[28 + (c[N + 24] - 1 + R) % 28] << 31 - N % 6;
                      A[0] = A[0] << 1 | A[0] >>> 31;
                      for (var N = 1; N < 7; N++) A[N] = A[N] >>> (N - 1) * 4 + 3;
                      A[7] = A[7] << 5 | A[7] >>> 27;
                    }
                    for (var T = this._invSubKeys = [], N = 0; N < 16; N++) T[N] = y[15 - N];
                  },
                  encryptBlock: function (b, m) {
                    this._doCryptBlock(b, m, this._subKeys);
                  },
                  decryptBlock: function (b, m) {
                    this._doCryptBlock(b, m, this._invSubKeys);
                  },
                  _doCryptBlock: function (b, m, _) {
                    this._lBlock = b[m], this._rBlock = b[m + 1], v.call(this, 4, 252645135), v.call(this, 16, 65535), h.call(this, 2, 858993459), h.call(this, 8, 16711935), v.call(this, 1, 1431655765);
                    for (var N = 0; N < 16; N++) {
                      for (var O = _[N], y = this._lBlock, w = this._rBlock, A = 0, R = 0; R < 8; R++) A |= f[R][((w ^ O[R]) & d[R]) >>> 0];
                      this._lBlock = w, this._rBlock = y ^ A;
                    }
                    var T = this._lBlock;
                    this._lBlock = this._rBlock, this._rBlock = T, v.call(this, 1, 1431655765), h.call(this, 8, 16711935), h.call(this, 2, 858993459), v.call(this, 16, 65535), v.call(this, 4, 252645135), b[m] = this._lBlock, b[m + 1] = this._rBlock;
                  },
                  keySize: 64 / 32,
                  ivSize: 64 / 32,
                  blockSize: 64 / 32
                });
              function v(b, m) {
                var _ = (this._lBlock >>> b ^ this._rBlock) & m;
                this._rBlock ^= _, this._lBlock ^= _ << b;
              }
              function h(b, m) {
                var _ = (this._rBlock >>> b ^ this._lBlock) & m;
                this._lBlock ^= _, this._rBlock ^= _ << b;
              }
              r.DES = l._createHelper(p);
              var g = s.TripleDES = l.extend({
                _doReset: function () {
                  var b = this._key,
                    m = b.words;
                  if (m.length !== 2 && m.length !== 4 && m.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                  var _ = m.slice(0, 2),
                    N = m.length < 4 ? m.slice(0, 2) : m.slice(2, 4),
                    O = m.length < 6 ? m.slice(0, 2) : m.slice(4, 6);
                  this._des1 = p.createEncryptor(a.create(_)), this._des2 = p.createEncryptor(a.create(N)), this._des3 = p.createEncryptor(a.create(O));
                },
                encryptBlock: function (b, m) {
                  this._des1.encryptBlock(b, m), this._des2.decryptBlock(b, m), this._des3.encryptBlock(b, m);
                },
                decryptBlock: function (b, m) {
                  this._des3.decryptBlock(b, m), this._des2.encryptBlock(b, m), this._des1.decryptBlock(b, m);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32
              });
              r.TripleDES = l._createHelper(g);
            }(), t.TripleDES;
          });
        }(gf)), gf.exports;
      }
      var vf = {
          exports: {}
        },
        AA = vf.exports,
        Xy;
      function RA() {
        return Xy || (Xy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(AA, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.StreamCipher,
                l = r.algo,
                s = l.RC4 = a.extend({
                  _doReset: function () {
                    for (var u = this._key, f = u.words, d = u.sigBytes, p = this._S = [], v = 0; v < 256; v++) p[v] = v;
                    for (var v = 0, h = 0; v < 256; v++) {
                      var g = v % d,
                        b = f[g >>> 2] >>> 24 - g % 4 * 8 & 255;
                      h = (h + p[v] + b) % 256;
                      var m = p[v];
                      p[v] = p[h], p[h] = m;
                    }
                    this._i = this._j = 0;
                  },
                  _doProcessBlock: function (u, f) {
                    u[f] ^= o.call(this);
                  },
                  keySize: 256 / 32,
                  ivSize: 0
                });
              function o() {
                for (var u = this._S, f = this._i, d = this._j, p = 0, v = 0; v < 4; v++) {
                  f = (f + 1) % 256, d = (d + u[f]) % 256;
                  var h = u[f];
                  u[f] = u[d], u[d] = h, p |= u[(u[f] + u[d]) % 256] << 24 - v * 8;
                }
                return this._i = f, this._j = d, p;
              }
              r.RC4 = a._createHelper(s);
              var c = l.RC4Drop = s.extend({
                cfg: s.cfg.extend({
                  drop: 192
                }),
                _doReset: function () {
                  s._doReset.call(this);
                  for (var u = this.cfg.drop; u > 0; u--) o.call(this);
                }
              });
              r.RC4Drop = a._createHelper(c);
            }(), t.RC4;
          });
        }(vf)), vf.exports;
      }
      var yf = {
          exports: {}
        },
        NA = yf.exports,
        qy;
      function SA() {
        return qy || (qy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(NA, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.StreamCipher,
                l = r.algo,
                s = [],
                o = [],
                c = [],
                u = l.Rabbit = a.extend({
                  _doReset: function () {
                    for (var d = this._key.words, p = this.cfg.iv, v = 0; v < 4; v++) d[v] = (d[v] << 8 | d[v] >>> 24) & 16711935 | (d[v] << 24 | d[v] >>> 8) & 4278255360;
                    var h = this._X = [d[0], d[3] << 16 | d[2] >>> 16, d[1], d[0] << 16 | d[3] >>> 16, d[2], d[1] << 16 | d[0] >>> 16, d[3], d[2] << 16 | d[1] >>> 16],
                      g = this._C = [d[2] << 16 | d[2] >>> 16, d[0] & 4294901760 | d[1] & 65535, d[3] << 16 | d[3] >>> 16, d[1] & 4294901760 | d[2] & 65535, d[0] << 16 | d[0] >>> 16, d[2] & 4294901760 | d[3] & 65535, d[1] << 16 | d[1] >>> 16, d[3] & 4294901760 | d[0] & 65535];
                    this._b = 0;
                    for (var v = 0; v < 4; v++) f.call(this);
                    for (var v = 0; v < 8; v++) g[v] ^= h[v + 4 & 7];
                    if (p) {
                      var b = p.words,
                        m = b[0],
                        _ = b[1],
                        N = (m << 8 | m >>> 24) & 16711935 | (m << 24 | m >>> 8) & 4278255360,
                        O = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360,
                        y = N >>> 16 | O & 4294901760,
                        w = O << 16 | N & 65535;
                      g[0] ^= N, g[1] ^= y, g[2] ^= O, g[3] ^= w, g[4] ^= N, g[5] ^= y, g[6] ^= O, g[7] ^= w;
                      for (var v = 0; v < 4; v++) f.call(this);
                    }
                  },
                  _doProcessBlock: function (d, p) {
                    var v = this._X;
                    f.call(this), s[0] = v[0] ^ v[5] >>> 16 ^ v[3] << 16, s[1] = v[2] ^ v[7] >>> 16 ^ v[5] << 16, s[2] = v[4] ^ v[1] >>> 16 ^ v[7] << 16, s[3] = v[6] ^ v[3] >>> 16 ^ v[1] << 16;
                    for (var h = 0; h < 4; h++) s[h] = (s[h] << 8 | s[h] >>> 24) & 16711935 | (s[h] << 24 | s[h] >>> 8) & 4278255360, d[p + h] ^= s[h];
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32
                });
              function f() {
                for (var d = this._X, p = this._C, v = 0; v < 8; v++) o[v] = p[v];
                p[0] = p[0] + 1295307597 + this._b | 0, p[1] = p[1] + 3545052371 + (p[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, p[2] = p[2] + 886263092 + (p[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, p[3] = p[3] + 1295307597 + (p[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, p[4] = p[4] + 3545052371 + (p[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, p[5] = p[5] + 886263092 + (p[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, p[6] = p[6] + 1295307597 + (p[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, p[7] = p[7] + 3545052371 + (p[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = p[7] >>> 0 < o[7] >>> 0 ? 1 : 0;
                for (var v = 0; v < 8; v++) {
                  var h = d[v] + p[v],
                    g = h & 65535,
                    b = h >>> 16,
                    m = ((g * g >>> 17) + g * b >>> 15) + b * b,
                    _ = ((h & 4294901760) * h | 0) + ((h & 65535) * h | 0);
                  c[v] = m ^ _;
                }
                d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
              }
              r.Rabbit = a._createHelper(u);
            }(), t.Rabbit;
          });
        }(yf)), yf.exports;
      }
      var mf = {
          exports: {}
        },
        TA = mf.exports,
        Jy;
      function DA() {
        return Jy || (Jy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(TA, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.StreamCipher,
                l = r.algo,
                s = [],
                o = [],
                c = [],
                u = l.RabbitLegacy = a.extend({
                  _doReset: function () {
                    var d = this._key.words,
                      p = this.cfg.iv,
                      v = this._X = [d[0], d[3] << 16 | d[2] >>> 16, d[1], d[0] << 16 | d[3] >>> 16, d[2], d[1] << 16 | d[0] >>> 16, d[3], d[2] << 16 | d[1] >>> 16],
                      h = this._C = [d[2] << 16 | d[2] >>> 16, d[0] & 4294901760 | d[1] & 65535, d[3] << 16 | d[3] >>> 16, d[1] & 4294901760 | d[2] & 65535, d[0] << 16 | d[0] >>> 16, d[2] & 4294901760 | d[3] & 65535, d[1] << 16 | d[1] >>> 16, d[3] & 4294901760 | d[0] & 65535];
                    this._b = 0;
                    for (var g = 0; g < 4; g++) f.call(this);
                    for (var g = 0; g < 8; g++) h[g] ^= v[g + 4 & 7];
                    if (p) {
                      var b = p.words,
                        m = b[0],
                        _ = b[1],
                        N = (m << 8 | m >>> 24) & 16711935 | (m << 24 | m >>> 8) & 4278255360,
                        O = (_ << 8 | _ >>> 24) & 16711935 | (_ << 24 | _ >>> 8) & 4278255360,
                        y = N >>> 16 | O & 4294901760,
                        w = O << 16 | N & 65535;
                      h[0] ^= N, h[1] ^= y, h[2] ^= O, h[3] ^= w, h[4] ^= N, h[5] ^= y, h[6] ^= O, h[7] ^= w;
                      for (var g = 0; g < 4; g++) f.call(this);
                    }
                  },
                  _doProcessBlock: function (d, p) {
                    var v = this._X;
                    f.call(this), s[0] = v[0] ^ v[5] >>> 16 ^ v[3] << 16, s[1] = v[2] ^ v[7] >>> 16 ^ v[5] << 16, s[2] = v[4] ^ v[1] >>> 16 ^ v[7] << 16, s[3] = v[6] ^ v[3] >>> 16 ^ v[1] << 16;
                    for (var h = 0; h < 4; h++) s[h] = (s[h] << 8 | s[h] >>> 24) & 16711935 | (s[h] << 24 | s[h] >>> 8) & 4278255360, d[p + h] ^= s[h];
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32
                });
              function f() {
                for (var d = this._X, p = this._C, v = 0; v < 8; v++) o[v] = p[v];
                p[0] = p[0] + 1295307597 + this._b | 0, p[1] = p[1] + 3545052371 + (p[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, p[2] = p[2] + 886263092 + (p[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, p[3] = p[3] + 1295307597 + (p[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, p[4] = p[4] + 3545052371 + (p[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, p[5] = p[5] + 886263092 + (p[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, p[6] = p[6] + 1295307597 + (p[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, p[7] = p[7] + 3545052371 + (p[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = p[7] >>> 0 < o[7] >>> 0 ? 1 : 0;
                for (var v = 0; v < 8; v++) {
                  var h = d[v] + p[v],
                    g = h & 65535,
                    b = h >>> 16,
                    m = ((g * g >>> 17) + g * b >>> 15) + b * b,
                    _ = ((h & 4294901760) * h | 0) + ((h & 65535) * h | 0);
                  c[v] = m ^ _;
                }
                d[0] = c[0] + (c[7] << 16 | c[7] >>> 16) + (c[6] << 16 | c[6] >>> 16) | 0, d[1] = c[1] + (c[0] << 8 | c[0] >>> 24) + c[7] | 0, d[2] = c[2] + (c[1] << 16 | c[1] >>> 16) + (c[0] << 16 | c[0] >>> 16) | 0, d[3] = c[3] + (c[2] << 8 | c[2] >>> 24) + c[1] | 0, d[4] = c[4] + (c[3] << 16 | c[3] >>> 16) + (c[2] << 16 | c[2] >>> 16) | 0, d[5] = c[5] + (c[4] << 8 | c[4] >>> 24) + c[3] | 0, d[6] = c[6] + (c[5] << 16 | c[5] >>> 16) + (c[4] << 16 | c[4] >>> 16) | 0, d[7] = c[7] + (c[6] << 8 | c[6] >>> 24) + c[5] | 0;
              }
              r.RabbitLegacy = a._createHelper(u);
            }(), t.RabbitLegacy;
          });
        }(mf)), mf.exports;
      }
      var bf = {
          exports: {}
        },
        PA = bf.exports,
        Gy;
      function IA() {
        return Gy || (Gy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Yo(), Zo(), Xi(), En());
          })(PA, function (t) {
            return function () {
              var r = t,
                i = r.lib,
                a = i.BlockCipher,
                l = r.algo;
              const s = 16,
                o = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731],
                c = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
              var u = {
                pbox: [],
                sbox: []
              };
              function f(g, b) {
                let m = b >> 24 & 255,
                  _ = b >> 16 & 255,
                  N = b >> 8 & 255,
                  O = b & 255,
                  y = g.sbox[0][m] + g.sbox[1][_];
                return y = y ^ g.sbox[2][N], y = y + g.sbox[3][O], y;
              }
              function d(g, b, m) {
                let _ = b,
                  N = m,
                  O;
                for (let y = 0; y < s; ++y) _ = _ ^ g.pbox[y], N = f(g, _) ^ N, O = _, _ = N, N = O;
                return O = _, _ = N, N = O, N = N ^ g.pbox[s], _ = _ ^ g.pbox[s + 1], {
                  left: _,
                  right: N
                };
              }
              function p(g, b, m) {
                let _ = b,
                  N = m,
                  O;
                for (let y = s + 1; y > 1; --y) _ = _ ^ g.pbox[y], N = f(g, _) ^ N, O = _, _ = N, N = O;
                return O = _, _ = N, N = O, N = N ^ g.pbox[1], _ = _ ^ g.pbox[0], {
                  left: _,
                  right: N
                };
              }
              function v(g, b, m) {
                for (let w = 0; w < 4; w++) {
                  g.sbox[w] = [];
                  for (let A = 0; A < 256; A++) g.sbox[w][A] = c[w][A];
                }
                let _ = 0;
                for (let w = 0; w < s + 2; w++) g.pbox[w] = o[w] ^ b[_], _++, _ >= m && (_ = 0);
                let N = 0,
                  O = 0,
                  y = 0;
                for (let w = 0; w < s + 2; w += 2) y = d(g, N, O), N = y.left, O = y.right, g.pbox[w] = N, g.pbox[w + 1] = O;
                for (let w = 0; w < 4; w++) for (let A = 0; A < 256; A += 2) y = d(g, N, O), N = y.left, O = y.right, g.sbox[w][A] = N, g.sbox[w][A + 1] = O;
                return !0;
              }
              var h = l.Blowfish = a.extend({
                _doReset: function () {
                  if (this._keyPriorReset !== this._key) {
                    var g = this._keyPriorReset = this._key,
                      b = g.words,
                      m = g.sigBytes / 4;
                    v(u, b, m);
                  }
                },
                encryptBlock: function (g, b) {
                  var m = d(u, g[b], g[b + 1]);
                  g[b] = m.left, g[b + 1] = m.right;
                },
                decryptBlock: function (g, b) {
                  var m = p(u, g[b], g[b + 1]);
                  g[b] = m.left, g[b + 1] = m.right;
                },
                blockSize: 64 / 32,
                keySize: 128 / 32,
                ivSize: 64 / 32
              });
              r.Blowfish = a._createHelper(h);
            }(), t.Blowfish;
          });
        }(bf)), bf.exports;
      }
      var BA = Mu.exports,
        Vy;
      function zy() {
        return Vy || (Vy = 1, function (n, e) {
          (function (t, r, i) {
            n.exports = r(_t(), Uu(), DO(), IO(), Yo(), MO(), Zo(), by(), Cd(), HO(), Ey(), XO(), JO(), VO(), Od(), QO(), Xi(), En(), tA(), rA(), oA(), aA(), lA(), fA(), hA(), gA(), yA(), bA(), xA(), EA(), OA(), RA(), SA(), DA(), IA());
          })(BA, function (t) {
            return t;
          });
        }(Mu)), Mu.exports;
      }
      var $y;
      function vr() {
        return $y || ($y = 1, function (n) {
          var e = Yc && Yc.__importDefault || function (G) {
            return G && G.__esModule ? G : {
              default: G
            };
          };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.chainName2IdMap = n.isValidObject = n.RANDOM_LENGTH = n.isBrowser = n.resolveLocalStorage = n.hasLocalStorage = n.hasBuiltInWebSocket = n.resolveWebSocketImplementation = void 0, n.hexToByteArray = d, n.getChainId = p, n.toHexString = v, n.concatUint8Arrays = h, n.splitToUint8Arrays = g, n.base64encode = _, n.base64decode = N, n.checkWSUrl = O, n.hashKey = D, n.generateRandomBytes32 = M, n.generateTopic = q, n.generateGroupId = W, n.isInIOSLine = C, n.isInIOSLark = B, n.isInIOSChrome = X, n.isInIOSWeChat = J, n.isIos = V, n.getLastSixMd5Hash = $, n.toSafeBase64FromBase64 = se, n.useShortLink = ne, n.replaceChainNameToChainId = oe, n.replaceChainIdToChainName = ye, n.getNamespaceKeyByChain = Te, n.scopePollingDetectionStrategy = ae;
          const t = e(Qc()),
            r = e(NE()),
            i = lO,
            a = fO(),
            l = $o(),
            s = yn(),
            o = uy(),
            c = e(zy()),
            u = Jt(),
            f = "base16";
          function d(G) {
            if (G.length % 2 !== 0) throw new Error(`Cannot convert ${G} to bytesArray`);
            const Z = new Uint8Array(G.length / 2);
            for (let S = 0; S < G.length; S += 2) Z[S / 2] = parseInt(G.slice(S, S + 2), 16);
            return Z;
          }
          function p(G) {
            return G.includes(":") ? G.split(":")[1] : G;
          }
          function v(G) {
            let Z = "";
            return G.forEach(S => {
              Z += ("0" + (S & 255).toString(16)).slice(-2);
            }), Z;
          }
          function h(G, Z) {
            const S = new Uint8Array(G.length + Z.length);
            return S.set(G), S.set(Z, G.length), S;
          }
          function g(G, Z) {
            if (Z >= G.length) throw new Error("Index is out of buffer");
            const S = G.slice(0, Z),
              ee = G.slice(Z);
            return [S, ee];
          }
          function b(G, Z) {
            const S = r.default.encodeBase64(G);
            return Z ? encodeURIComponent(S) : S;
          }
          function m(G, Z) {
            return Z && (G = decodeURIComponent(G)), r.default.decodeBase64(G);
          }
          function _(G, Z) {
            let S;
            return G instanceof Uint8Array ? S = G : (typeof G != "string" && (G = (0, l.safeJsonStringify)(G)), S = r.default.decodeUTF8(G)), b(S, Z);
          }
          function N(G, Z) {
            const S = m(G, Z);
            return {
              toString() {
                return r.default.encodeUTF8(S);
              },
              toObject() {
                try {
                  return (0, l.safeJsonParse)(r.default.encodeUTF8(S));
                } catch {
                  return null;
                }
              },
              toUint8Array() {
                return S;
              }
            };
          }
          function O(G) {
            const Z = G.match(new RegExp(/^\w+:/, "gi"));
            if (!Z || !Z.length) return !1;
            let S = Z[0];
            return S === void 0 ? !1 : new RegExp("^wss?:").test(S);
          }
          const y = () => typeof WebSocket != "undefined" ? WebSocket : typeof qt != "undefined" && typeof qt.WebSocket != "undefined" ? qt.WebSocket : typeof window != "undefined" && typeof window.WebSocket != "undefined" ? window.WebSocket : typeof self != "undefined" && typeof self.WebSocket != "undefined" ? self.WebSocket : WebSocket;
          n.resolveWebSocketImplementation = y;
          const w = () => typeof WebSocket != "undefined" || typeof qt != "undefined" && typeof qt.WebSocket != "undefined" || typeof window != "undefined" && typeof window.WebSocket != "undefined" || typeof self != "undefined" && typeof self.WebSocket != "undefined";
          n.hasBuiltInWebSocket = w;
          const A = () => typeof qt != "undefined" && typeof qt.localStorage != "undefined" || typeof window != "undefined" && typeof window.localStorage != "undefined";
          n.hasLocalStorage = A;
          const R = () => typeof qt != "undefined" && typeof qt.localStorage != "undefined" ? qt.localStorage : typeof window != "undefined" && typeof window.localStorage != "undefined" ? window.localStorage : localStorage;
          n.resolveLocalStorage = R;
          const T = () => typeof window != "undefined";
          n.isBrowser = T, n.RANDOM_LENGTH = 32;
          function D(G, Z = f) {
            (0, s.logDebug)(`hash key called ${G}`);
            const S = (0, a.hash)((0, o.okxfromString)(G, Z));
            return (0, i.toString)(S, Z);
          }
          function M() {
            return t.default.randomBytes(n.RANDOM_LENGTH);
          }
          function q() {
            let G = M();
            return (0, s.logDebug)(`generate topic called ${G}`), D((0, i.toString)(G, f));
          }
          function W() {
            let G = t.default.randomBytes(16);
            return (0, s.logDebug)(`generate groupid called ${G}`), D((0, i.toString)(G, f));
          }
          const x = G => Object.getPrototypeOf(G) === Object.prototype && Object.keys(G).length;
          n.isValidObject = x;
          function C() {
            return navigator.userAgent.includes("Safari Line/") && V();
          }
          function B() {
            return navigator.userAgent.includes("Lark/") && V();
          }
          function X() {
            return navigator.userAgent.includes("CriOS/") && V();
          }
          function J() {
            return navigator.userAgent.includes("MicroMessenger/") && V();
          }
          function V() {
            const G = navigator.userAgent,
              Z = navigator.maxTouchPoints || 0,
              S = /iPad|iPhone|iPod/.test(G) && !window.MSStream,
              ee = G.includes("Mac") && Z > 1;
            return (0, s.logDebug)(`utils isIos >>>isIOSDevice: ${S}    >> isIPadOS: ${ee}`), S || ee;
          }
          function $(G) {
            return c.default.MD5(G).toString().slice(-6);
          }
          function se(G) {
            return G.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
          }
          function ne() {
            return !0;
          }
          n.chainName2IdMap = new Map(), n.chainName2IdMap.set("aptos:mainnet", "aptos:637"), n.chainName2IdMap.set("movement:testnet", "aptos:70000060"), n.chainName2IdMap.set("movement:mainnet", "aptos:70000066"), n.chainName2IdMap.set("soon:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", "svm:70000069"), n.chainName2IdMap.set("soon:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z", "svm:70000067"), n.chainName2IdMap.set("eclipse:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", "svm:70000068"), n.chainName2IdMap.set("sonic:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp", "svm:70000073");
          function oe(G) {
            return n.chainName2IdMap.forEach((Z, S) => {
              G.includes(S) && (G = G.replace(S, Z));
            }), G;
          }
          function ye(G) {
            return n.chainName2IdMap.forEach((Z, S) => {
              G.includes(Z) && (G = G.replace(Z, S));
            }), G;
          }
          function Te(G) {
            for (const [Z, S] of Object.entries(u.NAMES_CHAINS)) if (Object.values(S).includes(G)) return Z;
            return G;
          }
          function ae(G) {
            if (typeof window == "undefined" || typeof document == "undefined") return;
            const Z = [];
            function S() {
              if (G()) for (const Oe of Z) Oe();
            }
            const ee = setInterval(S, 1e3);
            Z.push(() => clearInterval(ee)), document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", S, {
              once: !0
            }), Z.push(() => document.removeEventListener("DOMContentLoaded", S))), document.readyState !== "complete" && (window.addEventListener("load", S, {
              once: !0
            }), Z.push(() => window.removeEventListener("load", S))), S();
          }
        }(Yc)), Yc;
      }
      var Qy;
      function wf() {
        if (Qy) return nr;
        Qy = 1;
        var n = nr && nr.__createBinding || (Object.create ? function (d, p, v, h) {
            h === void 0 && (h = v);
            var g = Object.getOwnPropertyDescriptor(p, v);
            (!g || ("get" in g ? !p.__esModule : g.writable || g.configurable)) && (g = {
              enumerable: !0,
              get: function () {
                return p[v];
              }
            }), Object.defineProperty(d, h, g);
          } : function (d, p, v, h) {
            h === void 0 && (h = v), d[h] = p[v];
          }),
          e = nr && nr.__setModuleDefault || (Object.create ? function (d, p) {
            Object.defineProperty(d, "default", {
              enumerable: !0,
              value: p
            });
          } : function (d, p) {
            d.default = p;
          }),
          t = nr && nr.__importStar || function () {
            var d = function (p) {
              return d = Object.getOwnPropertyNames || function (v) {
                var h = [];
                for (var g in v) Object.prototype.hasOwnProperty.call(v, g) && (h[h.length] = g);
                return h;
              }, d(p);
            };
            return function (p) {
              if (p && p.__esModule) return p;
              var v = {};
              if (p != null) for (var h = d(p), g = 0; g < h.length; g++) h[g] !== "default" && n(v, p, h[g]);
              return e(v, p), v;
            };
          }(),
          r = nr && nr.__importDefault || function (d) {
            return d && d.__esModule ? d : {
              default: d
            };
          };
        Object.defineProperty(nr, "__esModule", {
          value: !0
        }), nr.Storage = void 0;
        const i = $c(),
          a = r(Qc()),
          l = vr(),
          s = tn(),
          o = t(yn()),
          c = tn(),
          u = zy();
        class f {
          constructor(p, v = void 0) {
            const h = (0, l.resolveLocalStorage)();
            this.storeKey = "", this.cipherIV = "", this.subKey = p, o.logDebug("--------get current local storage --------"), o.logDebug(h), this.synchronizedCache();
          }
          checkAndUpgradeCache(p, v) {
            if (p && p.length > 0 && v && v.length > 0) {
              o.logDebug("--------get current local storage --------"), o.logDebug(localStorage);
              const h = localStorage.getItem(f.cacheKey + p);
              if (typeof h == "undefined" || h === null) {
                o.logDebug("no pre cache content");
                return;
              }
              o.logDebug(h), (h == null ? void 0 : h.length) > 0 && (o.logDebug("write in cache content: ", p, "->", v), localStorage.setItem(f.cacheKey + v, h), o.logDebug("clean in cache content: ", p), localStorage.removeItem(f.cacheKey + p));
            } else o.logDebug("no pre cache key:", p);
          }
          saveContent(p, v, h = "-") {
            let g = {
              id: h,
              timestamp: Date.now().toString(),
              content: p
            };
            this.saveItem(g, v);
          }
          saveItem(p, v) {
            let h = f.cacheKey + this.subKey;
            const g = (0, l.resolveLocalStorage)();
            o.logDebug(this.cache), o.logDebug(`get cache obj: ${this.cache}, ${v}, ${p}`), this.cache[v] = p;
            let b = (0, s.safeJsonStringify)(this.cache);
            o.logDebug(`STORAGE: ${v} @ ${this.cache}`), g.setItem(h, b);
          }
          getItem(p) {
            return o.logDebug(`STORAGE >> getItem: ${p} @ ${this.cache}`), this.cache[p];
          }
          synchronizedCache() {
            const p = localStorage.getItem(f.cacheKey + this.subKey);
            if (typeof p == "undefined" || p === null) {
              o.logDebug("with no cache"), this.cache = {};
              return;
            }
            if (o.logDebug(p), (p == null ? void 0 : p.length) > 0) {
              var v = (0, s.safeJsonParse)(p);
              this.cache = v;
            }
            o.logDebug(`get cache obj: ${this.cache}`), (typeof this.cache == "undefined" || this.cache == null) && (this.cache = {});
          }
          getCachedPBKDF2InfoKey() {
            var p, v, h, g;
            if (this.storeKey.length > 0 && ((p = this.cipherIV) === null || p === void 0 ? void 0 : p.length) > 0) return {
              pw: this.storeKey,
              iv: this.cipherIV
            };
            let _ = (v = this.getItem(i.OKXCONNECTOR_STORAGER_CRYPTO_SALT)) === null || v === void 0 ? void 0 : v.content;
            _ || (_ = (0, l.toHexString)(a.default.randomBytes(24)), this.saveContent(_, i.OKXCONNECTOR_STORAGER_CRYPTO_SALT));
            let N = (h = this.getItem(i.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD)) === null || h === void 0 ? void 0 : h.content;
            N || (N = (0, l.toHexString)(a.default.randomBytes(32)), this.saveContent(N, i.OKXCONNECTOR_STORAGE_CRYPTO_PASSWORD));
            let O = (g = this.getItem(i.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV)) === null || g === void 0 ? void 0 : g.content;
            if (!O) {
              let y = a.default.randomBytes(16);
              O = (0, l.toHexString)(y), this.saveContent(O, i.OKXCONNECTOR_STORAGE_CRYPTO_CIPHERIV);
            }
            return this.cipherIV = O, this.storeKey = (0, u.PBKDF2)(N, _, {
              iterations: 10
            }).toString(), {
              pw: this.storeKey,
              iv: this.cipherIV
            };
          }
          encryptStoreMsg(p, v) {
            (0, c.logDebug)(`encryptStoreMsg  encryptStoreMsg start ${Date.now()}`);
            let h = this.getCachedPBKDF2InfoKey();
            (0, c.logDebug)(`encryptStoreMsg  encryptStoreMsg mid ${Date.now()}`);
            var g = u.AES.encrypt(p, h.pw).toString();
            this.saveContent(g, v), (0, c.logDebug)(`encryptStoreMsg  encryptStoreMsg end ${Date.now()}`);
          }
          getAndDecrypt(p) {
            (0, c.logDebug)(`encryptStoreMsg  getAndDecrypt start ${Date.now()}`);
            let v = this.getItem(p);
            if (v && v.content) {
              let h = this.getCachedPBKDF2InfoKey();
              (0, c.logDebug)(`encryptStoreMsg  getAndDecrypt mid ${Date.now()}`);
              let g = u.AES.decrypt(v.content, h.pw).toString(u.enc.Utf8);
              return (0, c.logDebug)(`encryptStoreMsg  getAndDecrypt end ${Date.now()}`), g;
            }
            return null;
          }
          clearCache(p = void 0) {
            if (p === void 0) {
              const v = (0, l.resolveLocalStorage)();
              this.cache = {};
              let h = f.cacheKey + this.subKey;
              v.setItem(h, "");
            } else {
              let v = f.cacheKey + this.subKey;
              const h = (0, l.resolveLocalStorage)();
              o.logDebug(this.cache), this.cache[p] = null;
              let g = (0, s.safeJsonStringify)(this.cache);
              o.logDebug(`STORAGE: clean key ${p} @ ${this.cache}`), h.setItem(v, g);
            }
          }
        }
        return nr.Storage = f, f.cacheKey = "OKXStorageKey", nr;
      }
      var Yy;
      function Ad() {
        if (Yy) return tr;
        Yy = 1;
        var n = tr && tr.__createBinding || (Object.create ? function (h, g, b, m) {
            m === void 0 && (m = b);
            var _ = Object.getOwnPropertyDescriptor(g, b);
            (!_ || ("get" in _ ? !g.__esModule : _.writable || _.configurable)) && (_ = {
              enumerable: !0,
              get: function () {
                return g[b];
              }
            }), Object.defineProperty(h, m, _);
          } : function (h, g, b, m) {
            m === void 0 && (m = b), h[m] = g[b];
          }),
          e = tr && tr.__setModuleDefault || (Object.create ? function (h, g) {
            Object.defineProperty(h, "default", {
              enumerable: !0,
              value: g
            });
          } : function (h, g) {
            h.default = g;
          }),
          t = tr && tr.__importStar || function () {
            var h = function (g) {
              return h = Object.getOwnPropertyNames || function (b) {
                var m = [];
                for (var _ in b) Object.prototype.hasOwnProperty.call(b, _) && (m[m.length] = _);
                return m;
              }, h(g);
            };
            return function (g) {
              if (g && g.__esModule) return g;
              var b = {};
              if (g != null) for (var m = h(g), _ = 0; _ < m.length; _++) m[_] !== "default" && n(b, g, m[_]);
              return e(b, g), b;
            };
          }(),
          r = tr && tr.__awaiter || function (h, g, b, m) {
            function _(N) {
              return N instanceof b ? N : new b(function (O) {
                O(N);
              });
            }
            return new (b || (b = Promise))(function (N, O) {
              function y(R) {
                try {
                  A(m.next(R));
                } catch (T) {
                  O(T);
                }
              }
              function w(R) {
                try {
                  A(m.throw(R));
                } catch (T) {
                  O(T);
                }
              }
              function A(R) {
                R.done ? N(R.value) : _(R.value).then(y, w);
              }
              A((m = m.apply(h, g || [])).next());
            });
          };
        Object.defineProperty(tr, "__esModule", {
          value: !0
        }), tr.OKXWalletConnector = void 0;
        const i = zc(),
          a = $c(),
          l = wf(),
          s = tn(),
          o = vr(),
          c = Wi(),
          u = t(yn()),
          f = Jt(),
          d = ku(),
          p = (0, o.resolveWebSocketImplementation)();
        class v {
          constructor(g) {
            if (this.events = new c.EventEmitter(), this.state = i.ConnectorState.InitState, this.selectedUrlIndex = 0, this.retryCount = 0, this.timeOutLimit = 8e3, !(0, o.checkWSUrl)(g)) throw new Error(`CONNECTOR: invalid url ${g}`);
            this.url = g, this.heartbeatTimer = null, this.connectionTimeoutTimer = null, this.connectURLStorage = new l.Storage(a.OKXCONNECTOR_CACHE_KEY + a.OKXCONNECTOR_CACHE_KEY);
          }
          get connecting() {
            return this.state == i.ConnectorState.Connecting;
          }
          onPayload(g) {
            if (typeof g.data != "undefined") {
              if (u.logDebug("get received data"), u.logDebug(g), typeof g.data == "string" && g.data === "pong") {
                u.logDebug(`CONNECT: receive pong ${Date.now().toString()}`);
                return;
              }
              this.events.emit("payload", g.data);
            }
          }
          onClose(g) {
            var b;
            u.logDebug("socket get closed: ", (b = this.socket) === null || b === void 0 ? void 0 : b.url, g.code), this.socket = void 0, this.events.emit("close", g);
          }
          onError(g, b) {
            const m = {
              id: g,
              msg: b.toString()
            };
            this.events.emit("payload", m);
          }
          onopen(g) {
            g.onmessage = b => this.onPayload(b), g.onclose = b => this.onClose(b), this.socket = g, this.state = i.ConnectorState.Connected, this.events.emit("open");
          }
          emitError(g) {
            this.events.emit("fail", g);
          }
          heartbeat() {
            return r(this, void 0, void 0, function* () {
              if (this.heartbeatTimer && clearTimeout(this.heartbeatTimer), this.state != i.ConnectorState.Connected && this.state != i.ConnectorState.OnError) {
                u.logDebug("heart beat close");
                return;
              }
              if (!this.socket) {
                if (u.logDebug("socket not exist"), this.state == i.ConnectorState.Connected || this.state == i.ConnectorState.OnError) {
                  u.logDebug("socket reconnect by heartbeat");
                  try {
                    yield this.tryRegistOpen();
                  } catch {
                    u.logError("regist open failed"), this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5e3);
                  }
                }
                return;
              }
              if (this.socket.readyState !== WebSocket.OPEN) {
                if (u.logDebug("socket not ready"), this.state == i.ConnectorState.Connected || this.state == i.ConnectorState.OnError) {
                  u.logDebug("socket reconnect by heartbeat with state", this.state, this.socket.readyState);
                  try {
                    yield this.tryRegistOpen();
                  } catch {
                    u.logError("regist open failed"), this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5e3);
                  }
                }
                return;
              }
              u.logDebug(`send ping heart beat: ${Date.now().toString()}, ${this.socket}`), this.socket.send("ping"), this.heartbeatTimer = setTimeout(this.heartbeat.bind(this), 5e3);
            });
          }
          registOpen(g = this.url, b = !1) {
            if (!(0, o.checkWSUrl)(g)) throw new Error(`CONNECTOR: invalid url ${g}`);
            return this.url = g, b || u.logDebug("Connection connect:", this.url, new Date().toUTCString()), this.state = i.ConnectorState.Connecting, new URLSearchParams(g).get("origin"), new Promise((m, _) => {
              const N = new p(g, []);
              u.logDebug("Connection connect Begin:", this.url, new Date().toUTCString()), this.startTimeOutTimer(N), (0, o.hasBuiltInWebSocket)() ? (u.logDebug("Add socket error handler"), N.onerror = () => {
                _(new Error("socket error")), N.close();
              }) : (u.logDebug("Add socket error handler"), N.on("error", () => {
                _(new Error("socket error")), N.close();
              })), N.onopen = () => {
                u.logDebug("socket opened"), this.resetTimeOutTimer(i.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.FINISHED), this.onopen(N), this.heartbeat(), m(N);
              };
            });
          }
          checkMaxRetry() {
            return u.logDebug("current retry count:", this.retryCount, "of", i.OKXCONNECTOR_WS_URL_LIST.length), this.retryCount > i.OKXCONNECTOR_WS_URL_LIST.length * 3;
          }
          connectionTryNext() {
            return r(this, void 0, void 0, function* () {
              if (this.checkMaxRetry()) u.logDebug("Max Connection retry ", this.retryCount, new Date().toUTCString());else {
                this.retryCount += 1;
                let g = this.getNextSelectUrl();
                return u.logDebug("Connection retry:", g, new Date().toUTCString()), this.registOpen(g, !0);
              }
            });
          }
          startTimeOutTimer(g) {
            this.connectionTimeoutTimer && this.resetTimeOutTimer(i.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.CANCELED), this.pendingSocket = g, this.connectionTimeoutTimer = setTimeout(() => {
              this.pendingSocket && this.resetTimeOutTimer(i.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.TIME_OUT);
            }, this.timeOutLimit);
          }
          resetTimeOutTimer(g) {
            var b;
            if (g == i.OKXCONNECTOR_WS_URL_PENDING_CLOSE_CODE.TIME_OUT) throw clearTimeout(this.connectionTimeoutTimer), (b = this.pendingSocket) === null || b === void 0 || b.close(), this.pendingSocket = void 0, u.reportEvent(d.OKXReportType.LOG, "timeout", this.retryCount.toString()), new Error("socket timeout");
            this.pendingSocket = void 0, clearTimeout(this.connectionTimeoutTimer);
          }
          cacheSuccessUrlSelect() {
            this.connectURLStorage.saveContent(this.selectedUrlIndex.toString(), a.OKXCONNECTOR_CACHE_KEY);
          }
          getNextSelectUrl() {
            return this.selectedUrlIndex += 1, this.selectedUrlIndex = this.selectedUrlIndex % i.OKXCONNECTOR_WS_URL_LIST.length, i.OKXCONNECTOR_WS_URL_LIST[this.selectedUrlIndex];
          }
          onVisibleChanged() {
            return r(this, void 0, void 0, function* () {
              if (document.visibilityState === "visible" && (u.logDebug(`get changed ${this.state}, ${this.socket}`), this.state == i.ConnectorState.Connected && typeof this.socket == "undefined")) {
                u.logDebug("CONNECTION need reopen");
                try {
                  yield this.tryRegistOpen();
                } catch {
                  u.logError("regist open failed");
                }
                return;
              }
            });
          }
          tryRegistOpen() {
            return r(this, arguments, void 0, function* (g = this.url) {
              if (this.connecting) return u.logDebug("tryRegistOpen => connecting state"), new Promise((m, _) => {
                this.events.once("fail", N => (u.logDebug("tryRegistOpen => connecting fail listener", N), _(N))), this.events.once("open", () => typeof this.socket == "undefined" ? _(new Error("Connect lost")) : m(this.socket));
              });
              u.logDebug("tryRegistOpen => try registOpen until retry limit is hit");
              let b = !1;
              for (; !this.checkMaxRetry() && !this.socket;) try {
                u.logDebug("tryRegistOpen => call registOpen, try count:", this.retryCount, b), yield this.registOpen(g, b);
              } catch (m) {
                u.logDebug("tryRegistOpen => registOpen failed", m), this.retryCount += 1, g = this.getNextSelectUrl(), b = !0;
              }
              if (u.logDebug("tryRegistOpen => exit while loop", this.retryCount, this.socket), !this.socket && this.checkMaxRetry()) throw u.logDebug("tryRegistOpen => failed to open a socket", this.retryCount, this.socket), this.retryCount = 0, this.state = i.ConnectorState.OnError, this.emitError(new Error("tryRegistOpen failed")), new f.OKXConnectError(f.OKX_CONNECT_ERROR_CODES.CONNECTION_ERROR, "Failed to connect");
            });
          }
          connect() {
            return r(this, void 0, void 0, function* () {
              try {
                yield this.tryRegistOpen(), document.removeEventListener("visibilitychange", this.onVisibleChanged.bind(this)), document.addEventListener("visibilitychange", this.onVisibleChanged.bind(this));
              } catch (g) {
                throw u.logDebug("connect => failed to connect", g), g;
              }
            });
          }
          disconnect() {
            return r(this, void 0, void 0, function* () {
              return this.state = i.ConnectorState.Disconnected, new Promise((g, b) => {
                if (typeof this.socket == "undefined") {
                  g();
                  return;
                }
                this.socket.onclose = m => {
                  this.onClose(m), g();
                }, this.socket.close(), this.heartbeatTimer && clearTimeout(this.heartbeatTimer);
              });
            });
          }
          currentStatus() {
            return {
              state: this.state,
              url: this.url
            };
          }
          addListener(g, b, m, _, N) {
            this.listenPayloadHandler && this.events.removeListener("payload", this.listenPayloadHandler), this.listenPayloadHandler = O => r(this, void 0, void 0, function* () {
              var y;
              u.logDebug(`<<< get payload ${O}`);
              let w = (0, s.safeJsonParse)(O);
              if (w.params && w.params.data) {
                let A = (y = w.params.data) === null || y === void 0 ? void 0 : y.message,
                  R = !1;
                if (A && N) {
                  let T = yield N(w.params.data);
                  R = T.isSplitPackage && !T.finalMessage, T.isSplitPackage && (T.finalMessage && T.finalMessage.length > 0 ? (u.logDebug("CONNECT: update raw msg content"), A = T.finalMessage) : (u.logDebug("CONNECT: skip raw msg content"), R = !0));
                }
                if (!R) try {
                  let T = b(A);
                  T === void 0 ? (u.logDebug("CONNECT: decrypt undefined"), _(g, "Decrypt undefined")) : m(g, T);
                } catch (T) {
                  u.logDebug(`CONNECT: decrypt failed: ${T}`), _(g, T.message);
                }
              }
            }), this.events.on("payload", this.listenPayloadHandler), this.failHandler && this.events.removeListener("fail", this.failHandler), this.failHandler = O => {
              O ? (u.logDebug(`CONNECT failed: ${O}`), _(g, O.message)) : _(g, "Unkonow error");
            }, this.events.on("fail", this.failHandler);
          }
          addPackageParse(g) {
            this.payloadHandler && this.events.removeListener("payload", this.payloadHandler), this.payloadHandler = b => r(this, void 0, void 0, function* () {
              u.logDebug(`CONNECTION @[${new Date().toUTCString()}] <<<< received e:${b}`);
              let m = (0, s.safeJsonParse)(b);
              yield g(m);
            }), this.events.on("payload", this.payloadHandler);
          }
          once(g, b) {
            this.events.once(g, b);
          }
          off(g, b) {
            this.events.off(g, b);
          }
          removeListener(g, b) {
            this.events.removeListener(g, b);
          }
          send(g, b) {
            return r(this, void 0, void 0, function* () {
              try {
                typeof this.socket == "undefined" && (u.logDebug(`>>> send payload undefined ${b}`), yield g()), u.logDebug(`CONNECTION @[${new Date().toUTCString()}]>>> send payload ${(0, s.safeJsonStringify)(b)}`), this.socket && this.socket.send((0, s.safeJsonStringify)(b));
              } catch (m) {
                this.onError(b.id, m);
              }
            });
          }
          getMsgPayloadFromHistory(g) {
            return r(this, void 0, void 0, function* () {
              if (typeof g == "undefined") return;
              let b = {
                  params: {
                    data: g
                  }
                },
                m = (0, s.safeJsonStringify)(g);
              u.logDebug("get received data from history"), u.logDebug(m), m = (0, s.safeJsonStringify)(b), this.events.emit("payload", m);
            });
          }
          onOpen(g) {
            this.openHandler && this.events.removeListener("open", this.openHandler), this.openHandler = () => r(this, void 0, void 0, function* () {
              u.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> ws opened: `), yield g();
            }), this.events.on("open", this.openHandler), this.cacheSuccessUrlSelect();
          }
        }
        return tr.OKXWalletConnector = v, tr;
      }
      var or = {},
        nn = {},
        Zy;
      function em() {
        return Zy || (Zy = 1, Object.defineProperty(nn, "__esModule", {
          value: !0
        }), nn.CONNECT_METHOD_RECV_DISCONNECT = nn.CONNECT_METHOD_DISCONNECT = nn.CONNECT_METHOD_BATCH_FETCHMSG = nn.CONNECT_METHOD_FETCHMSG = nn.CONNECT_METHOD_RECEIVE = nn.CONNECT_METHOD_UNSUB = nn.CONNECT_METHOD_SUB = nn.CONNECT_METHOD_PUBLISH = nn.CONNECT_METHOD_LOGIN = nn.CONNECT_METHOD_PUSH = void 0, nn.CONNECT_METHOD_PUSH = "push", nn.CONNECT_METHOD_LOGIN = "login", nn.CONNECT_METHOD_PUBLISH = "publish", nn.CONNECT_METHOD_SUB = "subscribe", nn.CONNECT_METHOD_UNSUB = "unsubscribe", nn.CONNECT_METHOD_RECEIVE = "receive", nn.CONNECT_METHOD_FETCHMSG = "fetchMessages", nn.CONNECT_METHOD_BATCH_FETCHMSG = "batchFetchMessages", nn.CONNECT_METHOD_DISCONNECT = "disconnect", nn.CONNECT_METHOD_RECV_DISCONNECT = "receiveDisconnect"), nn;
      }
      var hi = {},
        tm;
      function nm() {
        return tm || (tm = 1, Object.defineProperty(hi, "__esModule", {
          value: !0
        }), hi.OKXCONNECTOR_JWT_TTL = hi.OKXCONNECTOR_JWT_WALLET_SIDE = hi.OKXCONNECTOR_JWT_SIDE = void 0, hi.OKXCONNECTOR_JWT_SIDE = "wallet", hi.OKXCONNECTOR_JWT_WALLET_SIDE = "dapp", hi.OKXCONNECTOR_JWT_TTL = 864e5), hi;
      }
      var es = {},
        rm;
      function im() {
        if (rm) return es;
        rm = 1;
        var n = es && es.__importDefault || function (i) {
          return i && i.__esModule ? i : {
            default: i
          };
        };
        Object.defineProperty(es, "__esModule", {
          value: !0
        }), es.SessionCrypto = void 0;
        const e = n(Qc()),
          t = vr();
        class r {
          constructor(a = void 0) {
            this.nonceLength = 24, this.sessionKeyPair = a ? this.createKeypairFromString(a) : this.createKeypair();
          }
          createKeypair() {
            return e.default.box.keyPair();
          }
          createKeypairFromString(a) {
            return {
              publicKey: (0, t.hexToByteArray)(a.publicKey),
              secretKey: (0, t.hexToByteArray)(a.secretKey)
            };
          }
          createNonce() {
            return e.default.randomBytes(this.nonceLength);
          }
          get keyPair() {
            return this.sessionKeyPair;
          }
          encrypt(a, l) {
            const s = new TextEncoder().encode(a),
              o = this.createNonce(),
              c = e.default.box(s, o, (0, t.hexToByteArray)(l), this.keyPair.secretKey);
            let u = (0, t.concatUint8Arrays)(o, c);
            var f = (0, t.toHexString)(u),
              d = new TextEncoder().encode(f);
            return (0, t.base64encode)(d, !1);
          }
          encryptWallet(a, l) {
            const s = new TextEncoder().encode(a),
              o = this.createNonce(),
              c = e.default.box(s, o, (0, t.hexToByteArray)(l), this.keyPair.secretKey);
            let u = (0, t.concatUint8Arrays)(o, c);
            return (0, t.base64encode)(u, !1);
          }
          decrypt(a, l) {
            let o = (0, t.base64decode)(a, !0).toUint8Array();
            const [c, u] = (0, t.splitToUint8Arrays)(o, this.nonceLength),
              f = e.default.box.open(u, c, (0, t.hexToByteArray)(l), this.keyPair.secretKey);
            if (!f) throw new Error(`Decryption error: 
 message: ${a.toString()} 
 sender pubkey: ${l.toString()} 
 keypair pubkey: ${(0, t.toHexString)(this.keyPair.publicKey)} 
 keypair secretkey: ${(0, t.toHexString)(this.keyPair.secretKey)}`);
            return new TextDecoder().decode(f);
          }
          decryptWallet(a, l) {
            let s = (0, t.base64decode)(a, !0),
              o = (0, t.hexToByteArray)(s.toString());
            const [c, u] = (0, t.splitToUint8Arrays)(o, this.nonceLength),
              f = e.default.box.open(u, c, (0, t.hexToByteArray)(l), this.keyPair.secretKey);
            if (!f) throw new Error(`Decryption error: 
 message: ${a.toString()} 
 sender pubkey: ${l.toString()} 
 keypair pubkey: ${(0, t.toHexString)(this.keyPair.publicKey)} 
 keypair secretkey: ${(0, t.toHexString)(this.keyPair.secretKey)}`);
            return new TextDecoder().decode(f);
          }
          stringifyKeypair() {
            return {
              publicKey: (0, t.toHexString)(this.keyPair.publicKey),
              secretKey: (0, t.toHexString)(this.keyPair.secretKey)
            };
          }
        }
        return es.SessionCrypto = r, es;
      }
      var sr = {},
        Rd = {},
        Nd = {},
        ul = {},
        fl = {},
        om;
      function kA() {
        if (om) return fl;
        om = 1, Object.defineProperty(fl, "__esModule", {
          value: !0
        }), fl.BrowserRandomSource = void 0;
        const n = 65536;
        class e {
          constructor() {
            this.isAvailable = !1, this.isInstantiated = !1;
            const r = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
            r && r.getRandomValues !== void 0 && (this._crypto = r, this.isAvailable = !0, this.isInstantiated = !0);
          }
          randomBytes(r) {
            if (!this.isAvailable || !this._crypto) throw new Error("Browser random byte generator is not available.");
            const i = new Uint8Array(r);
            for (let a = 0; a < i.length; a += n) this._crypto.getRandomValues(i.subarray(a, a + Math.min(i.length - a, n)));
            return i;
          }
        }
        return fl.BrowserRandomSource = e, fl;
      }
      var dl = {},
        sm;
      function MA() {
        if (sm) return dl;
        sm = 1, Object.defineProperty(dl, "__esModule", {
          value: !0
        }), dl.NodeRandomSource = void 0;
        const n = il();
        class e {
          constructor() {
            if (this.isAvailable = !1, this.isInstantiated = !1, typeof Xo != "undefined") {
              const r = rd;
              r && r.randomBytes && (this._crypto = r, this.isAvailable = !0, this.isInstantiated = !0);
            }
          }
          randomBytes(r) {
            if (!this.isAvailable || !this._crypto) throw new Error("Node.js random byte generator is not available.");
            let i = this._crypto.randomBytes(r);
            if (i.length !== r) throw new Error("NodeRandomSource: got fewer bytes than requested");
            const a = new Uint8Array(r);
            for (let l = 0; l < a.length; l++) a[l] = i[l];
            return (0, n.wipe)(i), a;
          }
        }
        return dl.NodeRandomSource = e, dl;
      }
      var am;
      function KA() {
        if (am) return ul;
        am = 1, Object.defineProperty(ul, "__esModule", {
          value: !0
        }), ul.SystemRandomSource = void 0;
        const n = kA(),
          e = MA();
        class t {
          constructor() {
            if (this.isAvailable = !1, this.name = "", this._source = new n.BrowserRandomSource(), this._source.isAvailable) {
              this.isAvailable = !0, this.name = "Browser";
              return;
            }
            if (this._source = new e.NodeRandomSource(), this._source.isAvailable) {
              this.isAvailable = !0, this.name = "Node";
              return;
            }
          }
          randomBytes(i) {
            if (!this.isAvailable) throw new Error("System random byte generator is not available.");
            return this._source.randomBytes(i);
          }
        }
        return ul.SystemRandomSource = t, ul;
      }
      var cm;
      function LA() {
        return cm || (cm = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.randomStringForEntropy = n.randomString = n.randomUint32 = n.randomBytes = n.defaultRandomSource = void 0;
          const e = KA(),
            t = dd(),
            r = il();
          n.defaultRandomSource = new e.SystemRandomSource();
          function i(c, u = n.defaultRandomSource) {
            return u.randomBytes(c);
          }
          n.randomBytes = i;
          function a(c = n.defaultRandomSource) {
            const u = i(4, c),
              f = (0, t.readUint32LE)(u);
            return (0, r.wipe)(u), f;
          }
          n.randomUint32 = a;
          const l = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          function s(c, u = l, f = n.defaultRandomSource) {
            if (u.length < 2) throw new Error("randomString charset is too short");
            if (u.length > 256) throw new Error("randomString charset is too long");
            let d = "";
            const p = u.length,
              v = 256 - 256 % p;
            for (; c > 0;) {
              const h = i(Math.ceil(c * 256 / v), f);
              for (let g = 0; g < h.length && c > 0; g++) {
                const b = h[g];
                b < v && (d += u.charAt(b % p), c--);
              }
              (0, r.wipe)(h);
            }
            return d;
          }
          n.randomString = s;
          function o(c, u = l, f = n.defaultRandomSource) {
            const d = Math.ceil(c / (Math.log(u.length) / Math.LN2));
            return s(d, u, f);
          }
          n.randomStringForEntropy = o;
        }(Nd)), Nd;
      }
      var Sd = {},
        lm;
      function UA() {
        return lm || (lm = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          var e = dd(),
            t = il();
          n.DIGEST_LENGTH = 64, n.BLOCK_SIZE = 128;
          var r = function () {
            function s() {
              this.digestLength = n.DIGEST_LENGTH, this.blockSize = n.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
            }
            return s.prototype._initState = function () {
              this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
            }, s.prototype.reset = function () {
              return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
            }, s.prototype.clean = function () {
              t.wipe(this._buffer), t.wipe(this._tempHi), t.wipe(this._tempLo), this.reset();
            }, s.prototype.update = function (o, c) {
              if (c === void 0 && (c = o.length), this._finished) throw new Error("SHA512: can't update because hash was finished.");
              var u = 0;
              if (this._bytesHashed += c, this._bufferLength > 0) {
                for (; this._bufferLength < n.BLOCK_SIZE && c > 0;) this._buffer[this._bufferLength++] = o[u++], c--;
                this._bufferLength === this.blockSize && (a(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
              }
              for (c >= this.blockSize && (u = a(this._tempHi, this._tempLo, this._stateHi, this._stateLo, o, u, c), c %= this.blockSize); c > 0;) this._buffer[this._bufferLength++] = o[u++], c--;
              return this;
            }, s.prototype.finish = function (o) {
              if (!this._finished) {
                var c = this._bytesHashed,
                  u = this._bufferLength,
                  f = c / 536870912 | 0,
                  d = c << 3,
                  p = c % 128 < 112 ? 128 : 256;
                this._buffer[u] = 128;
                for (var v = u + 1; v < p - 8; v++) this._buffer[v] = 0;
                e.writeUint32BE(f, this._buffer, p - 8), e.writeUint32BE(d, this._buffer, p - 4), a(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, p), this._finished = !0;
              }
              for (var v = 0; v < this.digestLength / 8; v++) e.writeUint32BE(this._stateHi[v], o, v * 8), e.writeUint32BE(this._stateLo[v], o, v * 8 + 4);
              return this;
            }, s.prototype.digest = function () {
              var o = new Uint8Array(this.digestLength);
              return this.finish(o), o;
            }, s.prototype.saveState = function () {
              if (this._finished) throw new Error("SHA256: cannot save finished state");
              return {
                stateHi: new Int32Array(this._stateHi),
                stateLo: new Int32Array(this._stateLo),
                buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                bufferLength: this._bufferLength,
                bytesHashed: this._bytesHashed
              };
            }, s.prototype.restoreState = function (o) {
              return this._stateHi.set(o.stateHi), this._stateLo.set(o.stateLo), this._bufferLength = o.bufferLength, o.buffer && this._buffer.set(o.buffer), this._bytesHashed = o.bytesHashed, this._finished = !1, this;
            }, s.prototype.cleanSavedState = function (o) {
              t.wipe(o.stateHi), t.wipe(o.stateLo), o.buffer && t.wipe(o.buffer), o.bufferLength = 0, o.bytesHashed = 0;
            }, s;
          }();
          n.SHA512 = r;
          var i = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);
          function a(s, o, c, u, f, d, p) {
            for (var v = c[0], h = c[1], g = c[2], b = c[3], m = c[4], _ = c[5], N = c[6], O = c[7], y = u[0], w = u[1], A = u[2], R = u[3], T = u[4], D = u[5], M = u[6], q = u[7], W, x, C, B, X, J, V, $; p >= 128;) {
              for (var se = 0; se < 16; se++) {
                var ne = 8 * se + d;
                s[se] = e.readUint32BE(f, ne), o[se] = e.readUint32BE(f, ne + 4);
              }
              for (var se = 0; se < 80; se++) {
                var oe = v,
                  ye = h,
                  Te = g,
                  ae = b,
                  G = m,
                  Z = _,
                  S = N,
                  ee = O,
                  Ce = y,
                  Oe = w,
                  Xe = A,
                  Ve = R,
                  at = T,
                  ht = D,
                  Et = M,
                  vt = q;
                if (W = O, x = q, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = (m >>> 14 | T << 18) ^ (m >>> 18 | T << 14) ^ (T >>> 9 | m << 23), x = (T >>> 14 | m << 18) ^ (T >>> 18 | m << 14) ^ (m >>> 9 | T << 23), X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, W = m & _ ^ ~m & N, x = T & D ^ ~T & M, X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, W = i[se * 2], x = i[se * 2 + 1], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, W = s[se % 16], x = o[se % 16], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, C = V & 65535 | $ << 16, B = X & 65535 | J << 16, W = C, x = B, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = (v >>> 28 | y << 4) ^ (y >>> 2 | v << 30) ^ (y >>> 7 | v << 25), x = (y >>> 28 | v << 4) ^ (v >>> 2 | y << 30) ^ (v >>> 7 | y << 25), X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, W = v & h ^ v & g ^ h & g, x = y & w ^ y & A ^ w & A, X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, ee = V & 65535 | $ << 16, vt = X & 65535 | J << 16, W = ae, x = Ve, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = C, x = B, X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, ae = V & 65535 | $ << 16, Ve = X & 65535 | J << 16, h = oe, g = ye, b = Te, m = ae, _ = G, N = Z, O = S, v = ee, w = Ce, A = Oe, R = Xe, T = Ve, D = at, M = ht, q = Et, y = vt, se % 16 === 15) for (var ne = 0; ne < 16; ne++) W = s[ne], x = o[ne], X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = s[(ne + 9) % 16], x = o[(ne + 9) % 16], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, C = s[(ne + 1) % 16], B = o[(ne + 1) % 16], W = (C >>> 1 | B << 31) ^ (C >>> 8 | B << 24) ^ C >>> 7, x = (B >>> 1 | C << 31) ^ (B >>> 8 | C << 24) ^ (B >>> 7 | C << 25), X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, C = s[(ne + 14) % 16], B = o[(ne + 14) % 16], W = (C >>> 19 | B << 13) ^ (B >>> 29 | C << 3) ^ C >>> 6, x = (B >>> 19 | C << 13) ^ (C >>> 29 | B << 3) ^ (B >>> 6 | C << 26), X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, s[ne] = V & 65535 | $ << 16, o[ne] = X & 65535 | J << 16;
              }
              W = v, x = y, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[0], x = u[0], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[0] = v = V & 65535 | $ << 16, u[0] = y = X & 65535 | J << 16, W = h, x = w, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[1], x = u[1], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[1] = h = V & 65535 | $ << 16, u[1] = w = X & 65535 | J << 16, W = g, x = A, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[2], x = u[2], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[2] = g = V & 65535 | $ << 16, u[2] = A = X & 65535 | J << 16, W = b, x = R, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[3], x = u[3], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[3] = b = V & 65535 | $ << 16, u[3] = R = X & 65535 | J << 16, W = m, x = T, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[4], x = u[4], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[4] = m = V & 65535 | $ << 16, u[4] = T = X & 65535 | J << 16, W = _, x = D, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[5], x = u[5], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[5] = _ = V & 65535 | $ << 16, u[5] = D = X & 65535 | J << 16, W = N, x = M, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[6], x = u[6], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[6] = N = V & 65535 | $ << 16, u[6] = M = X & 65535 | J << 16, W = O, x = q, X = x & 65535, J = x >>> 16, V = W & 65535, $ = W >>> 16, W = c[7], x = u[7], X += x & 65535, J += x >>> 16, V += W & 65535, $ += W >>> 16, J += X >>> 16, V += J >>> 16, $ += V >>> 16, c[7] = O = V & 65535 | $ << 16, u[7] = q = X & 65535 | J << 16, d += 128, p -= 128;
            }
            return d;
          }
          function l(s) {
            var o = new r();
            o.update(s);
            var c = o.digest();
            return o.clean(), c;
          }
          n.hash = l;
        }(Sd)), Sd;
      }
      var um;
      function FA() {
        return um || (um = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.convertSecretKeyToX25519 = n.convertPublicKeyToX25519 = n.verify = n.sign = n.extractPublicKeyFromSecretKey = n.generateKeyPair = n.generateKeyPairFromSeed = n.SEED_LENGTH = n.SECRET_KEY_LENGTH = n.PUBLIC_KEY_LENGTH = n.SIGNATURE_LENGTH = void 0;
          const e = LA(),
            t = UA(),
            r = il();
          n.SIGNATURE_LENGTH = 64, n.PUBLIC_KEY_LENGTH = 32, n.SECRET_KEY_LENGTH = 64, n.SEED_LENGTH = 32;
          function i(ae) {
            const G = new Float64Array(16);
            if (ae) for (let Z = 0; Z < ae.length; Z++) G[Z] = ae[Z];
            return G;
          }
          const a = new Uint8Array(32);
          a[0] = 9;
          const l = i(),
            s = i([1]),
            o = i([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
            c = i([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
            u = i([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
            f = i([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
            d = i([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
          function p(ae, G) {
            for (let Z = 0; Z < 16; Z++) ae[Z] = G[Z] | 0;
          }
          function v(ae) {
            let G = 1;
            for (let Z = 0; Z < 16; Z++) {
              let S = ae[Z] + G + 65535;
              G = Math.floor(S / 65536), ae[Z] = S - G * 65536;
            }
            ae[0] += G - 1 + 37 * (G - 1);
          }
          function h(ae, G, Z) {
            const S = ~(Z - 1);
            for (let ee = 0; ee < 16; ee++) {
              const Ce = S & (ae[ee] ^ G[ee]);
              ae[ee] ^= Ce, G[ee] ^= Ce;
            }
          }
          function g(ae, G) {
            const Z = i(),
              S = i();
            for (let ee = 0; ee < 16; ee++) S[ee] = G[ee];
            v(S), v(S), v(S);
            for (let ee = 0; ee < 2; ee++) {
              Z[0] = S[0] - 65517;
              for (let Oe = 1; Oe < 15; Oe++) Z[Oe] = S[Oe] - 65535 - (Z[Oe - 1] >> 16 & 1), Z[Oe - 1] &= 65535;
              Z[15] = S[15] - 32767 - (Z[14] >> 16 & 1);
              const Ce = Z[15] >> 16 & 1;
              Z[14] &= 65535, h(S, Z, 1 - Ce);
            }
            for (let ee = 0; ee < 16; ee++) ae[2 * ee] = S[ee] & 255, ae[2 * ee + 1] = S[ee] >> 8;
          }
          function b(ae, G) {
            let Z = 0;
            for (let S = 0; S < 32; S++) Z |= ae[S] ^ G[S];
            return (1 & Z - 1 >>> 8) - 1;
          }
          function m(ae, G) {
            const Z = new Uint8Array(32),
              S = new Uint8Array(32);
            return g(Z, ae), g(S, G), b(Z, S);
          }
          function _(ae) {
            const G = new Uint8Array(32);
            return g(G, ae), G[0] & 1;
          }
          function N(ae, G) {
            for (let Z = 0; Z < 16; Z++) ae[Z] = G[2 * Z] + (G[2 * Z + 1] << 8);
            ae[15] &= 32767;
          }
          function O(ae, G, Z) {
            for (let S = 0; S < 16; S++) ae[S] = G[S] + Z[S];
          }
          function y(ae, G, Z) {
            for (let S = 0; S < 16; S++) ae[S] = G[S] - Z[S];
          }
          function w(ae, G, Z) {
            let S,
              ee,
              Ce = 0,
              Oe = 0,
              Xe = 0,
              Ve = 0,
              at = 0,
              ht = 0,
              Et = 0,
              vt = 0,
              It = 0,
              yt = 0,
              ut = 0,
              rt = 0,
              pt = 0,
              Ct = 0,
              Pe = 0,
              Fe = 0,
              ke = 0,
              ze = 0,
              Bt = 0,
              mt = 0,
              Je = 0,
              Ke = 0,
              St = 0,
              Gt = 0,
              hn = 0,
              On = 0,
              An = 0,
              Gn = 0,
              mn = 0,
              ni = 0,
              Di = 0,
              rn = Z[0],
              Lt = Z[1],
              Ht = Z[2],
              jt = Z[3],
              $t = Z[4],
              Qt = Z[5],
              Yt = Z[6],
              ln = Z[7],
              Ot = Z[8],
              At = Z[9],
              P = Z[10],
              U = Z[11],
              L = Z[12],
              E = Z[13],
              H = Z[14],
              ie = Z[15];
            S = G[0], Ce += S * rn, Oe += S * Lt, Xe += S * Ht, Ve += S * jt, at += S * $t, ht += S * Qt, Et += S * Yt, vt += S * ln, It += S * Ot, yt += S * At, ut += S * P, rt += S * U, pt += S * L, Ct += S * E, Pe += S * H, Fe += S * ie, S = G[1], Oe += S * rn, Xe += S * Lt, Ve += S * Ht, at += S * jt, ht += S * $t, Et += S * Qt, vt += S * Yt, It += S * ln, yt += S * Ot, ut += S * At, rt += S * P, pt += S * U, Ct += S * L, Pe += S * E, Fe += S * H, ke += S * ie, S = G[2], Xe += S * rn, Ve += S * Lt, at += S * Ht, ht += S * jt, Et += S * $t, vt += S * Qt, It += S * Yt, yt += S * ln, ut += S * Ot, rt += S * At, pt += S * P, Ct += S * U, Pe += S * L, Fe += S * E, ke += S * H, ze += S * ie, S = G[3], Ve += S * rn, at += S * Lt, ht += S * Ht, Et += S * jt, vt += S * $t, It += S * Qt, yt += S * Yt, ut += S * ln, rt += S * Ot, pt += S * At, Ct += S * P, Pe += S * U, Fe += S * L, ke += S * E, ze += S * H, Bt += S * ie, S = G[4], at += S * rn, ht += S * Lt, Et += S * Ht, vt += S * jt, It += S * $t, yt += S * Qt, ut += S * Yt, rt += S * ln, pt += S * Ot, Ct += S * At, Pe += S * P, Fe += S * U, ke += S * L, ze += S * E, Bt += S * H, mt += S * ie, S = G[5], ht += S * rn, Et += S * Lt, vt += S * Ht, It += S * jt, yt += S * $t, ut += S * Qt, rt += S * Yt, pt += S * ln, Ct += S * Ot, Pe += S * At, Fe += S * P, ke += S * U, ze += S * L, Bt += S * E, mt += S * H, Je += S * ie, S = G[6], Et += S * rn, vt += S * Lt, It += S * Ht, yt += S * jt, ut += S * $t, rt += S * Qt, pt += S * Yt, Ct += S * ln, Pe += S * Ot, Fe += S * At, ke += S * P, ze += S * U, Bt += S * L, mt += S * E, Je += S * H, Ke += S * ie, S = G[7], vt += S * rn, It += S * Lt, yt += S * Ht, ut += S * jt, rt += S * $t, pt += S * Qt, Ct += S * Yt, Pe += S * ln, Fe += S * Ot, ke += S * At, ze += S * P, Bt += S * U, mt += S * L, Je += S * E, Ke += S * H, St += S * ie, S = G[8], It += S * rn, yt += S * Lt, ut += S * Ht, rt += S * jt, pt += S * $t, Ct += S * Qt, Pe += S * Yt, Fe += S * ln, ke += S * Ot, ze += S * At, Bt += S * P, mt += S * U, Je += S * L, Ke += S * E, St += S * H, Gt += S * ie, S = G[9], yt += S * rn, ut += S * Lt, rt += S * Ht, pt += S * jt, Ct += S * $t, Pe += S * Qt, Fe += S * Yt, ke += S * ln, ze += S * Ot, Bt += S * At, mt += S * P, Je += S * U, Ke += S * L, St += S * E, Gt += S * H, hn += S * ie, S = G[10], ut += S * rn, rt += S * Lt, pt += S * Ht, Ct += S * jt, Pe += S * $t, Fe += S * Qt, ke += S * Yt, ze += S * ln, Bt += S * Ot, mt += S * At, Je += S * P, Ke += S * U, St += S * L, Gt += S * E, hn += S * H, On += S * ie, S = G[11], rt += S * rn, pt += S * Lt, Ct += S * Ht, Pe += S * jt, Fe += S * $t, ke += S * Qt, ze += S * Yt, Bt += S * ln, mt += S * Ot, Je += S * At, Ke += S * P, St += S * U, Gt += S * L, hn += S * E, On += S * H, An += S * ie, S = G[12], pt += S * rn, Ct += S * Lt, Pe += S * Ht, Fe += S * jt, ke += S * $t, ze += S * Qt, Bt += S * Yt, mt += S * ln, Je += S * Ot, Ke += S * At, St += S * P, Gt += S * U, hn += S * L, On += S * E, An += S * H, Gn += S * ie, S = G[13], Ct += S * rn, Pe += S * Lt, Fe += S * Ht, ke += S * jt, ze += S * $t, Bt += S * Qt, mt += S * Yt, Je += S * ln, Ke += S * Ot, St += S * At, Gt += S * P, hn += S * U, On += S * L, An += S * E, Gn += S * H, mn += S * ie, S = G[14], Pe += S * rn, Fe += S * Lt, ke += S * Ht, ze += S * jt, Bt += S * $t, mt += S * Qt, Je += S * Yt, Ke += S * ln, St += S * Ot, Gt += S * At, hn += S * P, On += S * U, An += S * L, Gn += S * E, mn += S * H, ni += S * ie, S = G[15], Fe += S * rn, ke += S * Lt, ze += S * Ht, Bt += S * jt, mt += S * $t, Je += S * Qt, Ke += S * Yt, St += S * ln, Gt += S * Ot, hn += S * At, On += S * P, An += S * U, Gn += S * L, mn += S * E, ni += S * H, Di += S * ie, Ce += 38 * ke, Oe += 38 * ze, Xe += 38 * Bt, Ve += 38 * mt, at += 38 * Je, ht += 38 * Ke, Et += 38 * St, vt += 38 * Gt, It += 38 * hn, yt += 38 * On, ut += 38 * An, rt += 38 * Gn, pt += 38 * mn, Ct += 38 * ni, Pe += 38 * Di, ee = 1, S = Ce + ee + 65535, ee = Math.floor(S / 65536), Ce = S - ee * 65536, S = Oe + ee + 65535, ee = Math.floor(S / 65536), Oe = S - ee * 65536, S = Xe + ee + 65535, ee = Math.floor(S / 65536), Xe = S - ee * 65536, S = Ve + ee + 65535, ee = Math.floor(S / 65536), Ve = S - ee * 65536, S = at + ee + 65535, ee = Math.floor(S / 65536), at = S - ee * 65536, S = ht + ee + 65535, ee = Math.floor(S / 65536), ht = S - ee * 65536, S = Et + ee + 65535, ee = Math.floor(S / 65536), Et = S - ee * 65536, S = vt + ee + 65535, ee = Math.floor(S / 65536), vt = S - ee * 65536, S = It + ee + 65535, ee = Math.floor(S / 65536), It = S - ee * 65536, S = yt + ee + 65535, ee = Math.floor(S / 65536), yt = S - ee * 65536, S = ut + ee + 65535, ee = Math.floor(S / 65536), ut = S - ee * 65536, S = rt + ee + 65535, ee = Math.floor(S / 65536), rt = S - ee * 65536, S = pt + ee + 65535, ee = Math.floor(S / 65536), pt = S - ee * 65536, S = Ct + ee + 65535, ee = Math.floor(S / 65536), Ct = S - ee * 65536, S = Pe + ee + 65535, ee = Math.floor(S / 65536), Pe = S - ee * 65536, S = Fe + ee + 65535, ee = Math.floor(S / 65536), Fe = S - ee * 65536, Ce += ee - 1 + 37 * (ee - 1), ee = 1, S = Ce + ee + 65535, ee = Math.floor(S / 65536), Ce = S - ee * 65536, S = Oe + ee + 65535, ee = Math.floor(S / 65536), Oe = S - ee * 65536, S = Xe + ee + 65535, ee = Math.floor(S / 65536), Xe = S - ee * 65536, S = Ve + ee + 65535, ee = Math.floor(S / 65536), Ve = S - ee * 65536, S = at + ee + 65535, ee = Math.floor(S / 65536), at = S - ee * 65536, S = ht + ee + 65535, ee = Math.floor(S / 65536), ht = S - ee * 65536, S = Et + ee + 65535, ee = Math.floor(S / 65536), Et = S - ee * 65536, S = vt + ee + 65535, ee = Math.floor(S / 65536), vt = S - ee * 65536, S = It + ee + 65535, ee = Math.floor(S / 65536), It = S - ee * 65536, S = yt + ee + 65535, ee = Math.floor(S / 65536), yt = S - ee * 65536, S = ut + ee + 65535, ee = Math.floor(S / 65536), ut = S - ee * 65536, S = rt + ee + 65535, ee = Math.floor(S / 65536), rt = S - ee * 65536, S = pt + ee + 65535, ee = Math.floor(S / 65536), pt = S - ee * 65536, S = Ct + ee + 65535, ee = Math.floor(S / 65536), Ct = S - ee * 65536, S = Pe + ee + 65535, ee = Math.floor(S / 65536), Pe = S - ee * 65536, S = Fe + ee + 65535, ee = Math.floor(S / 65536), Fe = S - ee * 65536, Ce += ee - 1 + 37 * (ee - 1), ae[0] = Ce, ae[1] = Oe, ae[2] = Xe, ae[3] = Ve, ae[4] = at, ae[5] = ht, ae[6] = Et, ae[7] = vt, ae[8] = It, ae[9] = yt, ae[10] = ut, ae[11] = rt, ae[12] = pt, ae[13] = Ct, ae[14] = Pe, ae[15] = Fe;
          }
          function A(ae, G) {
            w(ae, G, G);
          }
          function R(ae, G) {
            const Z = i();
            let S;
            for (S = 0; S < 16; S++) Z[S] = G[S];
            for (S = 253; S >= 0; S--) A(Z, Z), S !== 2 && S !== 4 && w(Z, Z, G);
            for (S = 0; S < 16; S++) ae[S] = Z[S];
          }
          function T(ae, G) {
            const Z = i();
            let S;
            for (S = 0; S < 16; S++) Z[S] = G[S];
            for (S = 250; S >= 0; S--) A(Z, Z), S !== 1 && w(Z, Z, G);
            for (S = 0; S < 16; S++) ae[S] = Z[S];
          }
          function D(ae, G) {
            const Z = i(),
              S = i(),
              ee = i(),
              Ce = i(),
              Oe = i(),
              Xe = i(),
              Ve = i(),
              at = i(),
              ht = i();
            y(Z, ae[1], ae[0]), y(ht, G[1], G[0]), w(Z, Z, ht), O(S, ae[0], ae[1]), O(ht, G[0], G[1]), w(S, S, ht), w(ee, ae[3], G[3]), w(ee, ee, c), w(Ce, ae[2], G[2]), O(Ce, Ce, Ce), y(Oe, S, Z), y(Xe, Ce, ee), O(Ve, Ce, ee), O(at, S, Z), w(ae[0], Oe, Xe), w(ae[1], at, Ve), w(ae[2], Ve, Xe), w(ae[3], Oe, at);
          }
          function M(ae, G, Z) {
            for (let S = 0; S < 4; S++) h(ae[S], G[S], Z);
          }
          function q(ae, G) {
            const Z = i(),
              S = i(),
              ee = i();
            R(ee, G[2]), w(Z, G[0], ee), w(S, G[1], ee), g(ae, S), ae[31] ^= _(Z) << 7;
          }
          function W(ae, G, Z) {
            p(ae[0], l), p(ae[1], s), p(ae[2], s), p(ae[3], l);
            for (let S = 255; S >= 0; --S) {
              const ee = Z[S / 8 | 0] >> (S & 7) & 1;
              M(ae, G, ee), D(G, ae), D(ae, ae), M(ae, G, ee);
            }
          }
          function x(ae, G) {
            const Z = [i(), i(), i(), i()];
            p(Z[0], u), p(Z[1], f), p(Z[2], s), w(Z[3], u, f), W(ae, Z, G);
          }
          function C(ae) {
            if (ae.length !== n.SEED_LENGTH) throw new Error(`ed25519: seed must be ${n.SEED_LENGTH} bytes`);
            const G = (0, t.hash)(ae);
            G[0] &= 248, G[31] &= 127, G[31] |= 64;
            const Z = new Uint8Array(32),
              S = [i(), i(), i(), i()];
            x(S, G), q(Z, S);
            const ee = new Uint8Array(64);
            return ee.set(ae), ee.set(Z, 32), {
              publicKey: Z,
              secretKey: ee
            };
          }
          n.generateKeyPairFromSeed = C;
          function B(ae) {
            const G = (0, e.randomBytes)(32, ae),
              Z = C(G);
            return (0, r.wipe)(G), Z;
          }
          n.generateKeyPair = B;
          function X(ae) {
            if (ae.length !== n.SECRET_KEY_LENGTH) throw new Error(`ed25519: secret key must be ${n.SECRET_KEY_LENGTH} bytes`);
            return new Uint8Array(ae.subarray(32));
          }
          n.extractPublicKeyFromSecretKey = X;
          const J = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
          function V(ae, G) {
            let Z, S, ee, Ce;
            for (S = 63; S >= 32; --S) {
              for (Z = 0, ee = S - 32, Ce = S - 12; ee < Ce; ++ee) G[ee] += Z - 16 * G[S] * J[ee - (S - 32)], Z = Math.floor((G[ee] + 128) / 256), G[ee] -= Z * 256;
              G[ee] += Z, G[S] = 0;
            }
            for (Z = 0, ee = 0; ee < 32; ee++) G[ee] += Z - (G[31] >> 4) * J[ee], Z = G[ee] >> 8, G[ee] &= 255;
            for (ee = 0; ee < 32; ee++) G[ee] -= Z * J[ee];
            for (S = 0; S < 32; S++) G[S + 1] += G[S] >> 8, ae[S] = G[S] & 255;
          }
          function $(ae) {
            const G = new Float64Array(64);
            for (let Z = 0; Z < 64; Z++) G[Z] = ae[Z];
            for (let Z = 0; Z < 64; Z++) ae[Z] = 0;
            V(ae, G);
          }
          function se(ae, G) {
            const Z = new Float64Array(64),
              S = [i(), i(), i(), i()],
              ee = (0, t.hash)(ae.subarray(0, 32));
            ee[0] &= 248, ee[31] &= 127, ee[31] |= 64;
            const Ce = new Uint8Array(64);
            Ce.set(ee.subarray(32), 32);
            const Oe = new t.SHA512();
            Oe.update(Ce.subarray(32)), Oe.update(G);
            const Xe = Oe.digest();
            Oe.clean(), $(Xe), x(S, Xe), q(Ce, S), Oe.reset(), Oe.update(Ce.subarray(0, 32)), Oe.update(ae.subarray(32)), Oe.update(G);
            const Ve = Oe.digest();
            $(Ve);
            for (let at = 0; at < 32; at++) Z[at] = Xe[at];
            for (let at = 0; at < 32; at++) for (let ht = 0; ht < 32; ht++) Z[at + ht] += Ve[at] * ee[ht];
            return V(Ce.subarray(32), Z), Ce;
          }
          n.sign = se;
          function ne(ae, G) {
            const Z = i(),
              S = i(),
              ee = i(),
              Ce = i(),
              Oe = i(),
              Xe = i(),
              Ve = i();
            return p(ae[2], s), N(ae[1], G), A(ee, ae[1]), w(Ce, ee, o), y(ee, ee, ae[2]), O(Ce, ae[2], Ce), A(Oe, Ce), A(Xe, Oe), w(Ve, Xe, Oe), w(Z, Ve, ee), w(Z, Z, Ce), T(Z, Z), w(Z, Z, ee), w(Z, Z, Ce), w(Z, Z, Ce), w(ae[0], Z, Ce), A(S, ae[0]), w(S, S, Ce), m(S, ee) && w(ae[0], ae[0], d), A(S, ae[0]), w(S, S, Ce), m(S, ee) ? -1 : (_(ae[0]) === G[31] >> 7 && y(ae[0], l, ae[0]), w(ae[3], ae[0], ae[1]), 0);
          }
          function oe(ae, G, Z) {
            const S = new Uint8Array(32),
              ee = [i(), i(), i(), i()],
              Ce = [i(), i(), i(), i()];
            if (Z.length !== n.SIGNATURE_LENGTH) throw new Error(`ed25519: signature must be ${n.SIGNATURE_LENGTH} bytes`);
            if (ne(Ce, ae)) return !1;
            const Oe = new t.SHA512();
            Oe.update(Z.subarray(0, 32)), Oe.update(ae), Oe.update(G);
            const Xe = Oe.digest();
            return $(Xe), W(ee, Ce, Xe), x(Ce, Z.subarray(32)), D(ee, Ce), q(S, ee), !b(Z, S);
          }
          n.verify = oe;
          function ye(ae) {
            let G = [i(), i(), i(), i()];
            if (ne(G, ae)) throw new Error("Ed25519: invalid public key");
            let Z = i(),
              S = i(),
              ee = G[1];
            O(Z, s, ee), y(S, s, ee), R(S, S), w(Z, Z, S);
            let Ce = new Uint8Array(32);
            return g(Ce, Z), Ce;
          }
          n.convertPublicKeyToX25519 = ye;
          function Te(ae) {
            const G = (0, t.hash)(ae.subarray(0, 32));
            G[0] &= 248, G[31] &= 127, G[31] |= 64;
            const Z = new Uint8Array(G.subarray(0, 32));
            return (0, r.wipe)(G), Z;
          }
          n.convertSecretKeyToX25519 = Te;
        }(Rd)), Rd;
      }
      var fm;
      function dm() {
        return fm || (fm = 1, function (n) {
          var e = sr && sr.__createBinding || (Object.create ? function (R, T, D, M) {
              M === void 0 && (M = D);
              var q = Object.getOwnPropertyDescriptor(T, D);
              (!q || ("get" in q ? !T.__esModule : q.writable || q.configurable)) && (q = {
                enumerable: !0,
                get: function () {
                  return T[D];
                }
              }), Object.defineProperty(R, M, q);
            } : function (R, T, D, M) {
              M === void 0 && (M = D), R[M] = T[D];
            }),
            t = sr && sr.__setModuleDefault || (Object.create ? function (R, T) {
              Object.defineProperty(R, "default", {
                enumerable: !0,
                value: T
              });
            } : function (R, T) {
              R.default = T;
            }),
            r = sr && sr.__importStar || function () {
              var R = function (T) {
                return R = Object.getOwnPropertyNames || function (D) {
                  var M = [];
                  for (var q in D) Object.prototype.hasOwnProperty.call(D, q) && (M[M.length] = q);
                  return M;
                }, R(T);
              };
              return function (T) {
                if (T && T.__esModule) return T;
                var D = {};
                if (T != null) for (var M = R(T), q = 0; q < M.length; q++) M[q] !== "default" && e(D, T, M[q]);
                return t(D, T), D;
              };
            }(),
            i = sr && sr.__awaiter || function (R, T, D, M) {
              function q(W) {
                return W instanceof D ? W : new D(function (x) {
                  x(W);
                });
              }
              return new (D || (D = Promise))(function (W, x) {
                function C(J) {
                  try {
                    X(M.next(J));
                  } catch (V) {
                    x(V);
                  }
                }
                function B(J) {
                  try {
                    X(M.throw(J));
                  } catch (V) {
                    x(V);
                  }
                }
                function X(J) {
                  J.done ? W(J.value) : q(J.value).then(C, B);
                }
                X((M = M.apply(R, T || [])).next());
              });
            },
            a = sr && sr.__importDefault || function (R) {
              return R && R.__esModule ? R : {
                default: R
              };
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.MULTICODEC_ED25519_LENGTH = n.MULTICODEC_ED25519_HEADER = n.MULTICODEC_ED25519_BASE = n.MULTICODEC_ED25519_ENCODING = n.DID_METHOD = n.DID_PREFIX = n.DID_DELIMITER = n.KEY_PAIR_SEED_LENGTH = n.DATA_ENCODING = n.JSON_ENCODING = n.JWT_ENCODING = n.JWT_DELIMITER = n.JWT_IRIDIUM_TYP = n.JWT_IRIDIUM_ALG = n.JWTHeaderType = void 0, n.generateKeyPair = d, n.decodeJSON = p, n.encodeJSON = v, n.encodeIss = h, n.decodeIss = g, n.encodeSig = b, n.decodeSig = m, n.encodeData = _, n.decodeData = N, n.encodeJWT = O, n.decodeJWT = y, n.signJWT = w, n.verifyJWT = A;
          const l = r(FA()),
            s = $o(),
            o = vr(),
            c = a(Qc()),
            u = r(yn()),
            f = uy();
          n.JWTHeaderType = "dapp", n.JWT_IRIDIUM_ALG = "EdDSA", n.JWT_IRIDIUM_TYP = "JWT", n.JWT_DELIMITER = ".", n.JWT_ENCODING = "base64url", n.JSON_ENCODING = "utf8", n.DATA_ENCODING = "utf8", n.KEY_PAIR_SEED_LENGTH = 32, n.DID_DELIMITER = ":", n.DID_PREFIX = "did", n.DID_METHOD = "key", n.MULTICODEC_ED25519_ENCODING = "base58btc", n.MULTICODEC_ED25519_BASE = "z", n.MULTICODEC_ED25519_HEADER = "K36", n.MULTICODEC_ED25519_LENGTH = 32;
          function d() {
            return c.default.sign.keyPair();
          }
          function p(R) {
            return (0, s.safeJsonParse)((0, f.okxtoString)((0, f.okxfromString)(R, n.JWT_ENCODING), n.JSON_ENCODING));
          }
          function v(R) {
            return (0, f.okxtoString)((0, f.okxfromString)((0, s.safeJsonStringify)(R), n.JSON_ENCODING), n.JWT_ENCODING);
          }
          function h(R) {
            u.logDebug(`publicKey: ${(0, o.toHexString)(R)}`);
            var T = (0, f.okxtoString)(R, n.MULTICODEC_ED25519_ENCODING);
            return [n.DID_PREFIX, n.DID_METHOD, T].join(n.DID_DELIMITER);
          }
          function g(R) {
            const [T, D, M] = R.split(n.DID_DELIMITER);
            if (T !== n.DID_PREFIX || D !== n.DID_METHOD) throw new Error('Issuer must be a DID with method "key"');
            if (M === void 0) throw new Error("multicodec is undefined");
            const q = (0, f.okxfromString)(M, n.MULTICODEC_ED25519_ENCODING);
            if (q === void 0 || q.length !== n.MULTICODEC_ED25519_LENGTH) throw new Error("Issuer must be a public key with length 32 bytes");
            return q;
          }
          function b(R) {
            return (0, f.okxtoString)(R, n.JWT_ENCODING);
          }
          function m(R) {
            return (0, f.okxfromString)(R, n.JWT_ENCODING);
          }
          function _(R) {
            return (0, f.okxfromString)([v(R.header), v(R.payload)].join(n.JWT_DELIMITER), n.DATA_ENCODING);
          }
          function N(R) {
            var T, D;
            const M = (0, f.okxtoString)(R, n.DATA_ENCODING).split(n.JWT_DELIMITER),
              q = p((T = M[0]) !== null && T !== void 0 ? T : "{}"),
              W = p((D = M[1]) !== null && D !== void 0 ? D : "{}");
            return {
              header: q,
              payload: W
            };
          }
          function O(R) {
            return [v(R.header), v(R.payload), b(R.signature)].join(n.JWT_DELIMITER);
          }
          function y(R) {
            var T, D, M;
            const q = R.split(n.JWT_DELIMITER),
              W = p((T = q[0]) !== null && T !== void 0 ? T : "{}"),
              x = p((D = q[1]) !== null && D !== void 0 ? D : "{}"),
              C = m((M = q[2]) !== null && M !== void 0 ? M : "{}"),
              B = (0, f.okxfromString)(q.slice(0, 2).join(n.JWT_DELIMITER), n.DATA_ENCODING);
            return {
              header: W,
              payload: x,
              signature: C,
              data: B
            };
          }
          function w(R, T, D, M) {
            return i(this, arguments, void 0, function* (q, W, x, C, B = Math.floor(Date.now())) {
              const X = {
                  alg: n.JWT_IRIDIUM_ALG,
                  typ: n.JWT_IRIDIUM_TYP
                },
                J = h(C.publicKey),
                V = B + x,
                se = {
                  iss: J,
                  sub: q,
                  aud: W,
                  act: "authenticate user",
                  iat: B,
                  exp: V
                },
                ne = _({
                  header: X,
                  payload: se
                });
              u.logDebug(`get sec kp: ${C.secretKey} {${C.secretKey.length}}`);
              const oe = c.default.sign.detached(ne, C.secretKey);
              return O({
                header: X,
                payload: se,
                signature: oe
              });
            });
          }
          function A(R) {
            return i(this, void 0, void 0, function* () {
              const {
                header: T,
                payload: D,
                data: M,
                signature: q
              } = y(R);
              if (T.alg !== n.JWT_IRIDIUM_ALG || T.typ !== n.JWT_IRIDIUM_TYP) throw new Error("JWT must use EdDSA algorithm");
              const W = g(D.iss);
              return l.verify(W, M, q);
            });
          }
        }(sr)), sr;
      }
      var Xn = {},
        hm;
      function pm() {
        if (hm) return Xn;
        hm = 1;
        var n = Xn && Xn.__createBinding || (Object.create ? function (b, m, _, N) {
            N === void 0 && (N = _);
            var O = Object.getOwnPropertyDescriptor(m, _);
            (!O || ("get" in O ? !m.__esModule : O.writable || O.configurable)) && (O = {
              enumerable: !0,
              get: function () {
                return m[_];
              }
            }), Object.defineProperty(b, N, O);
          } : function (b, m, _, N) {
            N === void 0 && (N = _), b[N] = m[_];
          }),
          e = Xn && Xn.__setModuleDefault || (Object.create ? function (b, m) {
            Object.defineProperty(b, "default", {
              enumerable: !0,
              value: m
            });
          } : function (b, m) {
            b.default = m;
          }),
          t = Xn && Xn.__importStar || function () {
            var b = function (m) {
              return b = Object.getOwnPropertyNames || function (_) {
                var N = [];
                for (var O in _) Object.prototype.hasOwnProperty.call(_, O) && (N[N.length] = O);
                return N;
              }, b(m);
            };
            return function (m) {
              if (m && m.__esModule) return m;
              var _ = {};
              if (m != null) for (var N = b(m), O = 0; O < N.length; O++) N[O] !== "default" && n(_, m, N[O]);
              return e(_, m), _;
            };
          }(),
          r = Xn && Xn.__awaiter || function (b, m, _, N) {
            function O(y) {
              return y instanceof _ ? y : new _(function (w) {
                w(y);
              });
            }
            return new (_ || (_ = Promise))(function (y, w) {
              function A(D) {
                try {
                  T(N.next(D));
                } catch (M) {
                  w(M);
                }
              }
              function R(D) {
                try {
                  T(N.throw(D));
                } catch (M) {
                  w(M);
                }
              }
              function T(D) {
                D.done ? y(D.value) : O(D.value).then(A, R);
              }
              T((N = N.apply(b, m || [])).next());
            });
          },
          i = Xn && Xn.__importDefault || function (b) {
            return b && b.__esModule ? b : {
              default: b
            };
          };
        Object.defineProperty(Xn, "__esModule", {
          value: !0
        }), Xn.ConnectionSplitPackages = void 0;
        const a = $c(),
          l = i(Ed()),
          s = vr(),
          o = $o(),
          c = t(yn()),
          u = yn(),
          f = 2,
          d = 63e3,
          p = "ConnectionReceiveKey",
          v = "ConnectionSendKey",
          h = "ConnectionSenderVersionKey";
        class g {
          constructor(m) {
            this.splitMessageSendArray = new Map(), this.splitMessageReceivedArray = new Map(), this.splitMessageSenderVersionMap = new Map(), this.splitPackageCache = l.default.createInstance({
              name: a.OKXCONNECTOR_STORAGE_PROTOCOL_CACHE + m
            });
          }
          init(m) {
            return r(this, void 0, void 0, function* () {
              if (yield this.recoverFromCache(), this.splitMessageSendArray.size > 0) {
                for (const [_, N] of this.splitMessageSendArray.entries()) for (let O = 0; O < N.length;) {
                  const y = N[O];
                  try {
                    yield m((0, o.safeJsonStringify)(y), _), c.logDebug(`Successfully sent payload: ${(0, o.safeJsonStringify)(y)} to topic: ${_}`), N.splice(O, 1);
                  } catch (w) {
                    c.logError(`Failed to send payload: ${(0, o.safeJsonStringify)(y)} to topic: ${_}`, w), y.retryCount = (y.retryCount || 0) + 1, y.retryCount > 3 ? (c.logError(`Payload failed after 3 retries: ${(0, o.safeJsonStringify)(y)}`), N.splice(O, 1)) : O++;
                  }
                }
                yield this.syncCache();
              }
            });
          }
          tryParseMessageSplitPayload(m) {
            var _;
            let N;
            try {
              if (m.trimStart().startsWith("{")) {
                let O = (0, o.safeJsonParse)(m);
                if (O && O.protocol_version && O.protocol_version >= 2) {
                  let y = O;
                  y.package_group_id && ((_ = y.package_group_id) === null || _ === void 0 ? void 0 : _.length) > 0 && (N = O);
                }
              } else (0, u.logDebug)("not split packages");
            } catch {
              (0, u.logDebug)("not split packages");
            }
            return N;
          }
          updateTopicSenderVersion(m, _) {
            return r(this, void 0, void 0, function* () {
              this.splitMessageSenderVersionMap.set(m, _), yield this.syncCache(), (0, u.logDebug)("get update topic sender version: ", m, _);
            });
          }
          sendSplitPackages(m, _, N, O) {
            return r(this, void 0, void 0, function* () {
              if (!m) {
                c.logError("sendSplitPackages invalid topic");
                return;
              }
              let y = this.splitMessageSenderVersionMap.get(m),
                w = _.length;
              try {
                if (w < d) throw new Error(`no need to split (size:${w})`);
                if (!y || y && y < f) throw new Error(`version not support split (version: ${y})`);
                const A = [];
                let R = d;
                for (let M = 0; M < _.length; M += R) M + R < _.length ? A.push(_.slice(M, M + R)) : A.push(_.slice(M));
                let T = (0, s.generateGroupId)(),
                  D = A.map((M, q) => ({
                    topicId: m,
                    protocol_version: f,
                    total_count: A.length,
                    package_index: q,
                    package_group_id: T,
                    content: M
                  }));
                this.mergePackageArray(!0, D);
                for (let M = 0; M < D.length;) {
                  const q = D[M],
                    W = (0, o.safeJsonStringify)(q);
                  try {
                    yield O(W, m), c.logDebug(`Successfully sent payload: ${W} to topic: ${m}`), D.splice(M, 1);
                  } catch (x) {
                    c.logError(`Failed to send payload: ${W} to topic: ${m}`, x), q.retryCount = (q.retryCount || 0) + 1, q.retryCount > 3 ? (c.logError(`Payload failed after 3 retries: ${W}`), D.splice(M, 1)) : M++;
                  }
                }
                this.splitMessageSendArray.set(m, []), yield this.syncCache();
              } catch (A) {
                (0, u.logDebug)("send split packages no split"), (0, u.logDebug)(A), yield N(m, _);
              }
            });
          }
          onReceivedPackageCheck(m) {
            return r(this, void 0, void 0, function* () {
              this.mergePackageArray(!1, [m]);
              let _ = new Map(),
                N = m.topicId;
              this.splitMessageReceivedArray.forEach((y, w) => {
                w == m.topicId && y.forEach(A => {
                  if (A.messageObject.package_group_id) {
                    let R = _.get(A.messageObject.package_group_id);
                    R || (R = new Array()), R.push(A), _.set(A.messageObject.package_group_id, R);
                  }
                });
              }), (0, u.logDebug)("on received message, check message cache");
              let O = {
                isSplitPackage: !1
              };
              if (m.messageObject.package_group_id) {
                O.isSplitPackage = !0;
                let y = _.get(m.messageObject.package_group_id);
                if (y != null && y.length) {
                  let w = new Set();
                  if (y.forEach(A => {
                    A.messageObject.package_index !== void 0 && w.add(A.messageObject.package_index);
                  }), w.size == m.messageObject.total_count) {
                    y.sort((D, M) => (D.messageObject.package_index || D.messageObject.package_index === 0) && (M.messageObject.package_index || M.messageObject.package_index === 0) ? D.messageObject.package_index - M.messageObject.package_index : 0);
                    let A = y.reduce((D, M) => (D.push(M.messageObject.content), D), []),
                      R = y.reduce((D, M) => (D.push(M.messageId), D), []);
                    O.isSplitPackage = !0, O.finalMessage = A.join(""), O.completeMessageIdList = R;
                    let T = this.splitMessageReceivedArray.get(N);
                    T && (T = T.filter(D => !R.includes(D.messageId)), this.splitMessageReceivedArray.set(N, T)), yield this.syncCache();
                  }
                }
              }
              return O;
            });
          }
          mergePackageArray(m, _) {
            return r(this, void 0, void 0, function* () {
              if ((0, u.logDebug)("append sending array"), m) {
                let O = _.filter(y => {
                  let w = y.topicId,
                    A = !0,
                    R = this.splitMessageSendArray.get(w);
                  return R == null || R.forEach(T => {
                    T.package_group_id == y.package_group_id && T.total_count == y.total_count && T.package_index == y.package_index && (A = !1);
                  }), A;
                });
                if (O.length > 0) {
                  let y = O[0].topicId,
                    w = this.splitMessageSendArray.get(y);
                  w || (w = new Array()), w = w.concat(O), this.splitMessageSendArray.set(y, w), (0, u.logDebug)("append sending array (after filted): ", w);
                }
              } else {
                let O = _.filter(y => {
                  let w = y.topicId,
                    A = !0,
                    R = this.splitMessageReceivedArray.get(w);
                  return R == null || R.forEach(T => {
                    T.messageId == y.messageId && (A = !1);
                  }), A;
                });
                if (O.length > 0) {
                  let y = O[0].topicId,
                    w = this.splitMessageReceivedArray.get(y);
                  w || (w = new Array()), w = w.concat(O), this.splitMessageReceivedArray.set(y, w), (0, u.logDebug)("append received array (after filted): ", w);
                }
              }
            });
          }
          syncCache() {
            return r(this, void 0, void 0, function* () {
              (0, u.logDebug)("sync split message cache"), yield this.splitPackageCache.setItem(p, this.splitMessageReceivedArray), yield this.splitPackageCache.setItem(v, this.splitMessageSendArray), yield this.splitPackageCache.setItem(h, this.splitMessageSenderVersionMap);
            });
          }
          recoverFromCache() {
            return r(this, void 0, void 0, function* () {
              let m = yield this.splitPackageCache.getItem(p);
              m ? this.splitMessageReceivedArray = m : this.splitMessageReceivedArray = new Map();
              let _ = yield this.splitPackageCache.getItem(v);
              _ ? this.splitMessageSendArray = _ : this.splitMessageSendArray = new Map();
              let N = yield this.splitPackageCache.getItem(h);
              N ? this.splitMessageSenderVersionMap = N : this.splitMessageSenderVersionMap = new Map();
            });
          }
        }
        return Xn.ConnectionSplitPackages = g, Xn;
      }
      var gm;
      function vm() {
        if (gm) return or;
        gm = 1;
        var n = or && or.__createBinding || (Object.create ? function (O, y, w, A) {
            A === void 0 && (A = w);
            var R = Object.getOwnPropertyDescriptor(y, w);
            (!R || ("get" in R ? !y.__esModule : R.writable || R.configurable)) && (R = {
              enumerable: !0,
              get: function () {
                return y[w];
              }
            }), Object.defineProperty(O, A, R);
          } : function (O, y, w, A) {
            A === void 0 && (A = w), O[A] = y[w];
          }),
          e = or && or.__setModuleDefault || (Object.create ? function (O, y) {
            Object.defineProperty(O, "default", {
              enumerable: !0,
              value: y
            });
          } : function (O, y) {
            O.default = y;
          }),
          t = or && or.__importStar || function () {
            var O = function (y) {
              return O = Object.getOwnPropertyNames || function (w) {
                var A = [];
                for (var R in w) Object.prototype.hasOwnProperty.call(w, R) && (A[A.length] = R);
                return A;
              }, O(y);
            };
            return function (y) {
              if (y && y.__esModule) return y;
              var w = {};
              if (y != null) for (var A = O(y), R = 0; R < A.length; R++) A[R] !== "default" && n(w, y, A[R]);
              return e(w, y), w;
            };
          }(),
          r = or && or.__awaiter || function (O, y, w, A) {
            function R(T) {
              return T instanceof w ? T : new w(function (D) {
                D(T);
              });
            }
            return new (w || (w = Promise))(function (T, D) {
              function M(x) {
                try {
                  W(A.next(x));
                } catch (C) {
                  D(C);
                }
              }
              function q(x) {
                try {
                  W(A.throw(x));
                } catch (C) {
                  D(C);
                }
              }
              function W(x) {
                x.done ? T(x.value) : R(x.value).then(M, q);
              }
              W((A = A.apply(O, y || [])).next());
            });
          };
        Object.defineProperty(or, "__esModule", {
          value: !0
        }), or.ConnectionManager = void 0;
        const i = Ad(),
          a = em(),
          l = $c(),
          s = nm(),
          o = zc(),
          c = Wi(),
          u = wf(),
          f = vr(),
          d = im(),
          p = dm(),
          v = $o(),
          h = t(yn()),
          g = yn(),
          b = ku(),
          m = ll(),
          _ = pm();
        class N {
          constructor(y = void 0) {
            this.events = new c.EventEmitter(), this.splitManager = new _.ConnectionSplitPackages("dapp"), this.connectorEnable = !1, this.connectStorage = new u.Storage(l.OKXCONNECTOR_CACHE_KEY_DAPP + y, l.OKXCONNECTOR_CACHE_KEY_DAPP), this.tonsdkConnectStorage = new u.Storage(l.OKXCONNECTOR_TON_KEY + y, l.OKXCONNECTOR_TON_KEY), this.crypto = new d.SessionCrypto();
            let w = (0, m.isInTMA)();
            if ((0, g.logDebug)("do init:", w), h.reportLog("connection manager do init"), w) try {
              const A = this.getCachedCryptoKeyPair();
              (0, g.logDebug)("use same pk:", A), this.crypto = new d.SessionCrypto(A);
            } catch {
              this.connectStorage.clearCache(), h.reportEvent(b.OKXReportType.LOG, "cache_fail", "cache failed");
            }
            this.jwtKeyPair = this.getCachedJWTKeyPair(), this.saveJWTKeyPair(this.jwtKeyPair), this.connector = new i.OKXWalletConnector(o.OKXCONNECTOR_WS_URL_1), this.packageId = Date.now(), this.connectedWalletPK = "", this.currentTopic = "", h.logDebug(`this.connectedWalletPK  constructor   ${this.connectedWalletPK}`);
          }
          refreshPackageId() {
            let y = Date.now();
            y == this.packageId && (this.packageId = y + 1), this.packageId = y;
          }
          saveCryptoKeyPair(y) {
            let w = (0, v.safeJsonStringify)(y);
            this.connectStorage.encryptStoreMsg(w, l.OKXCONNECTOR_CRYPTO_KEY);
          }
          getCachedCryptoKeyPair() {
            const w = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_CRYPTO_KEY);
            return typeof w == "string" ? (h.logDebug("get cached crypto key:"), h.logDebug(w), (0, v.safeJsonParse)(w)) : (this.connectStorage.clearCache(), null);
          }
          saveJWTKeyPair(y) {
            var w = {
              publicKey: (0, f.toHexString)(y.publicKey),
              secretKey: (0, f.toHexString)(y.secretKey)
            };
            h.logDebug("save jwt kp");
            let A = (0, v.safeJsonStringify)(w);
            h.logDebug(A), this.connectStorage.encryptStoreMsg(A, l.OKXCONNECTOR_JWT_KEY);
          }
          getCachedJWTKeyPair() {
            try {
              const A = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_JWT_KEY);
              if (typeof A == "string") {
                h.logDebug("get cached jwt kp:"), h.logDebug(A);
                let R = (0, v.safeJsonParse)(A);
                h.logDebug("save jwt kp"), h.logDebug(R);
                var y = {
                  publicKey: (0, f.hexToByteArray)(R.publicKey),
                  secretKey: (0, f.hexToByteArray)(R.secretKey)
                };
                return y;
              } else return (0, p.generateKeyPair)();
            } catch {
              return h.reportEvent(b.OKXReportType.LOG, "cache_fail", "cache failed"), (0, p.generateKeyPair)();
            }
          }
          isWalletPKReady() {
            return h.logDebug(`isWalletPKReady  ===> ${this.connectedWalletPK}`), this.connectedWalletPK.length > 0;
          }
          makeJWT(y) {
            return r(this, void 0, void 0, function* () {
              return yield (0, p.signJWT)(y, s.OKXCONNECTOR_JWT_SIDE, s.OKXCONNECTOR_JWT_TTL, this.jwtKeyPair);
            });
          }
          parsePackage(y) {
            return r(this, arguments, void 0, function* (w, A = !1) {
              var R, T, D, M, q, W, x, C, B, X, J, V, $;
              if (this.events.emit(w.id, w), !A) {
                yield this.sendACK(w.id, !0);
                let se = (R = this.connectStorage.getItem(l.OKXCONNECTOR_TOKEN_CACHE)) === null || R === void 0 ? void 0 : R.content;
                if (se) {
                  let ne = w;
                  if (!((D = (T = ne.params) === null || T === void 0 ? void 0 : T.data) === null || D === void 0) && D.messageId) {
                    ne.method && ne.method === a.CONNECT_METHOD_PUSH && ((0, g.logDebug)("checkExpire: update expire when get push"), this.updateExpireLimit(se));
                    let oe = this.splitManager.tryParseMessageSplitPayload((q = (M = ne.params) === null || M === void 0 ? void 0 : M.data) === null || q === void 0 ? void 0 : q.message);
                    if (oe) {
                      let ye = {
                          topicId: (x = (W = ne.params) === null || W === void 0 ? void 0 : W.data) === null || x === void 0 ? void 0 : x.topic,
                          messageId: (B = (C = ne.params) === null || C === void 0 ? void 0 : C.data) === null || B === void 0 ? void 0 : B.messageId,
                          messageObject: oe,
                          publishedAt: (J = (X = ne.params) === null || X === void 0 ? void 0 : X.data) === null || J === void 0 ? void 0 : J.publishedAt
                        },
                        Te = yield this.splitManager.onReceivedPackageCheck(ye);
                      Te.completeMessageIdList && Te.completeMessageIdList.forEach(ae => r(this, void 0, void 0, function* () {
                        this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), ae, se);
                      }));
                    } else this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), ($ = (V = ne.params) === null || V === void 0 ? void 0 : V.data) === null || $ === void 0 ? void 0 : $.messageId, se);
                  }
                }
              }
            });
          }
          restoreConnect(y) {
            return r(this, void 0, void 0, function* () {
              if (h.reportLog("connection manager restore connection"), h.logDebug(`connectionManager  restoreConenct   ${y}`), typeof y != "string" || y.length === 0) throw new Error("CONNECTION: invalid topic");
              h.logDebug("connectionManager  restoreConenct   disconnect"), yield this.disconnect(!0), this.connectStorage.saveContent(y, l.OKXCONNECTOR_TOKEN_CACHE), h.logDebug("connectionManager  restoreConenct   conect"), yield this.connect(!0);
            });
          }
          getConnectInfo() {
            var y = (0, f.generateTopic)();
            return h.logDebug(`generate topic token: ${y}`), h.reportLog("connection manager generate connection info"), this.currentTopic = y, {
              channelId: y,
              clientId: this.crypto.stringifyKeypair().publicKey
            };
          }
          connect() {
            return r(this, arguments, void 0, function* (y = !1) {
              this.timeLog = new Date().getTime(), (0, g.logDebug)("ConnectTime---enter->", this.timeLog), h.reportLog("connection manager begin connect");
              let w = this.connectStorage.getItem(l.OKXCONNECTOR_TOKEN_CACHE);
              var A = this.currentTopic;
              if (h.logDebug(`generate topic token: ${A}`), y) {
                typeof w != "undefined" && w !== null && (h.logDebug(`read last connect id: ${w}`), A = w.content);
                var R = this.connectStorage.getItem(l.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
                R && (this.connectedWalletPK = R.content, (0, g.logDebug)(`connectionManager connect() this.connectedWalletPK : ${this.connectedWalletPK}`)), h.reportLog("connection manager do restore connection");
              }
              if (y) try {
                const D = this.getCachedCryptoKeyPair();
                D && (this.crypto = new d.SessionCrypto(D));
              } catch {
                throw h.logError("get crypto key pair from cache failed"), h.reportEvent(b.OKXReportType.LOG, "cache_fail", "cache failed"), this.connectStorage.clearCache(), new Error("crypto cache failed");
              }
              h.logDebug(`use crypto client id: ${this.crypto.stringifyKeypair().publicKey}`), this.connectStorage.saveContent(A, l.OKXCONNECTOR_TOKEN_CACHE);
              var T = yield this.makeJWT(A);
              return h.logDebug(`generate jwt token: ${T}`), this.connectStorage.saveContent(T, "jwt"), new Promise((D, M) => {
                this.connector.onOpen(() => r(this, void 0, void 0, function* () {
                  h.logDebug("1. connector on open"), h.reportLog("1. connect ws open");
                  const q = new Date().getTime();
                  (0, g.logDebug)("ConnectTime---open->", q - this.timeLog), this.events.once(this.packageId.toString(), W => r(this, void 0, void 0, function* () {
                    if (W && W.error) {
                      h.logError("failed when login"), h.reportLog("2. connect login failed"), yield this.connector.disconnect();
                      var x = new Error();
                      x.message = W.error.message, x.name = W.error.code.toString(), M(x);
                    }
                    this.refreshPackageId(), this.events.once(this.packageId.toString(), B => r(this, void 0, void 0, function* () {
                      if (B && B.error) {
                        h.logError("failed when subscribe"), h.reportLog("3. connect subscribe failed"), yield this.connector.disconnect();
                        var X = new Error();
                        X.message = B.error.message, X.name = B.error.code.toString(), M(X);
                      }
                      this.refreshPackageId(), h.logDebug(`4. subscribe callback then send fetch: ${this.packageId}`), h.reportLog("4. subscribe callback then send fetch");
                      const J = new Date().getTime();
                      (0, g.logDebug)("ConnectTime--subscribe callback->", J - this.timeLog), yield this.sendFetchAndConsumeMessages(this.packageId.toString(), A), h.logDebug(`5. splitmanager init: ${this.packageId}`), h.reportLog("5. splitmanager init"), yield this.splitManager.init(this.sendRaw.bind(this)), y && (this.checkExpire(A) ? ((0, g.logDebug)("disconnect From topic expire"), setTimeout(() => {
                        this.activateDisconnect();
                      }, 1e3)) : ((0, g.logDebug)("extends expire check"), this.updateExpireLimit(A))), D();
                    })), h.logDebug(`3. login callback then send subscribe: ${this.packageId}`), h.reportLog("3. connect subscribe failed");
                    const C = new Date().getTime();
                    (0, g.logDebug)("ConnectTime---login callback->", C - this.timeLog), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                      h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect().catch(B => {
                        (0, g.logDebug)("ConnectionManager connect error", B), M(B);
                      });
                    }), {
                      id: this.packageId.toString(),
                      jsonrpc: o.CONNECT_JSONRPC_VER,
                      method: a.CONNECT_METHOD_SUB,
                      params: {
                        topic: A
                      }
                    });
                  })), h.logDebug("2. login called"), h.reportLog("2. connection manager connect call login"), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                    h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect().catch(W => {
                      (0, g.logDebug)("ConnectionManager connect error", W), M(W);
                    });
                  }), {
                    id: this.packageId.toString(),
                    jsonrpc: o.CONNECT_JSONRPC_VER,
                    method: a.CONNECT_METHOD_LOGIN,
                    params: {
                      token: T
                    }
                  }), this.connector.addPackageParse(W => {
                    var x;
                    if (h.logDebug("connect: parse package"), h.logDebug(W), !("params" in W) || !("data" in W.params)) {
                      this.parsePackage(W, !0);
                      return;
                    }
                    let C = (x = W.params.data) === null || x === void 0 ? void 0 : x.message;
                    if (typeof C != "undefined" && C.length > 0) {
                      C = C.replace(/'/g, '"');
                      let B = (0, v.safeJsonParse)(C);
                      typeof B != "string" && "clientId" in B && B.clientId && B.clientId.length > 0 && (this.connectedWalletPK = B.clientId, h.logDebug(`this.connectedWalletPK  addPackageParse   ${this.connectedWalletPK}`), this.connectStorage.saveContent(this.connectedWalletPK, l.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE), this.saveCryptoKeyPair(this.crypto.stringifyKeypair()));
                    }
                    this.parsePackage(W, W.method === a.CONNECT_METHOD_RECEIVE);
                  });
                })), this.connector.connect().catch(q => {
                  (0, g.logDebug)("ConnectionManager connect error", q), M(q);
                }), this.connectorEnable = !0;
              });
            });
          }
          sendSubscribe(y) {
            return r(this, void 0, void 0, function* () {
              this.refreshPackageId(), yield this.connector.send(() => r(this, void 0, void 0, function* () {}), {
                id: this.packageId.toString(),
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_SUB,
                params: {
                  topic: y
                }
              });
            });
          }
          sendDisconnect(y) {
            return r(this, void 0, void 0, function* () {
              return new Promise((w, A) => r(this, void 0, void 0, function* () {
                if (this.refreshPackageId(), !this.connectorEnable) {
                  h.logDebug("skip disconnect before connected relay"), w();
                  return;
                }
                this.events.once(this.packageId.toString(), T => r(this, void 0, void 0, function* () {
                  h.logDebug("CONNECT: disconnect command send"), this.connectorEnable = !1, w();
                }));
                const R = {
                  id: this.packageId.toString(),
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  method: a.CONNECT_METHOD_DISCONNECT,
                  params: {
                    message: {
                      topic: y,
                      ttl: o.OKXCONNECTOR_MESSAGE_DISCONNECT_TTL
                    }
                  }
                };
                yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  h.logDebug("CONNECT: skip reconnect send");
                }), R);
              }));
            });
          }
          sendRecvDisconnect(y) {
            return r(this, void 0, void 0, function* () {
              this.refreshPackageId();
              const w = {
                id: this.packageId.toString(),
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_RECV_DISCONNECT,
                params: {
                  topic: y
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), w);
            });
          }
          disconnect() {
            return r(this, arguments, void 0, function* (y = !1) {
              try {
                yield this.sendDisconnect(this.currentTopic);
              } catch (w) {
                h.logError("send disconnect command failed", w);
              }
              yield this.connector.disconnect(), h.reportLog("connect disconnect"), this.connectStorage.clearCache(l.OKXCONNECTOR_TOKEN_CACHE), y || (this.connectStorage.clearCache(l.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE), this.connectedWalletPK = "", (0, g.logDebug)(`connectionManager disconnect() this.connectedWalletPK : ${this.connectedWalletPK}`));
            });
          }
          updateProtocolVersion(y, w) {
            this.splitManager.updateTopicSenderVersion(y, w);
          }
          addListener(y, w, A) {
            this.connector.addListener((0, v.safeJsonStringify)(y), R => {
              if (R = R.replace(/'/g, '"'), h.logDebug(`addListener ===> ${R}`), typeof R != "undefined" && R.length > 0) {
                var T = (0, v.safeJsonParse)(R),
                  D = T.message;
                let M;
                return D.trimStart().startsWith("{") ? M = D : (T.clientId && T.clientId.length > 0 && (this.connectedWalletPK = T.clientId, this.connectStorage.saveContent(this.connectedWalletPK, l.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE), h.logDebug(`this.connectedWalletPK  addListener   ${this.connectedWalletPK}`), h.logDebug(`this.cryptoKey  addListener   ${(0, f.toHexString)(this.crypto.keyPair.publicKey)}`), this.saveCryptoKeyPair(this.crypto.stringifyKeypair())), M = this.crypto.decrypt(D, this.connectedWalletPK)), h.logDebug(`addListener ===> ${M}`), M;
              }
            }, w, A, R => new Promise((T, D) => r(this, void 0, void 0, function* () {
              let M = this.splitManager.tryParseMessageSplitPayload(R.message);
              if (M) {
                let q = {
                    topicId: R.topic,
                    messageId: R == null ? void 0 : R.messageId,
                    messageObject: M,
                    publishedAt: R == null ? void 0 : R.publishedAt
                  },
                  W = yield this.splitManager.onReceivedPackageCheck(q);
                T(W);
              } else T({
                isSplitPackage: !1
              });
            })));
          }
          sendRaw(y) {
            return r(this, void 0, void 0, function* () {
              h.logDebug(`message send =====> ${y}`), h.reportLog("connect send raw msg");
              let w = y;
              h.logDebug(`message send =====encrypt message.length>>>> ${w.length}`);
              let A = this.connectStorage.getItem(l.OKXCONNECTOR_TOKEN_CACHE);
              h.logDebug(`message send =====topic>>>> ${A == null ? void 0 : A.content}`), this.refreshPackageId();
              const R = {
                id: this.packageId.toString(),
                method: a.CONNECT_METHOD_PUBLISH,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                params: {
                  message: {
                    topic: A == null ? void 0 : A.content,
                    message: w,
                    ttl: o.OKXCONNECTOR_MESSAGE_TTL
                  }
                }
              };
              return this.events.once(this.packageId.toString(), T => r(this, void 0, void 0, function* () {
                T && T.error ? h.logError(`@${new Date().toUTCString()} >>> failed when send msg`) : T && !T.error && h.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
              })), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R), this.packageId;
            });
          }
          sendEncryptedMsg(y, w) {
            return r(this, arguments, void 0, function* (A, R, T = o.OKXCONNECTOR_MESSAGE_TTL) {
              this.refreshPackageId();
              const D = {
                id: this.packageId.toString(),
                method: a.CONNECT_METHOD_PUBLISH,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                params: {
                  message: {
                    topic: A,
                    message: R,
                    ttl: T
                  }
                }
              };
              this.events.once(this.packageId.toString(), M => r(this, void 0, void 0, function* () {
                M && M.error ? h.logError(`@${new Date().toUTCString()} >>> failed when send msg`) : M && !M.error && h.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
              })), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), D);
            });
          }
          send(y) {
            return r(this, arguments, void 0, function* (w, A = o.OKXCONNECTOR_MESSAGE_TTL) {
              if (h.logDebug(`message send =====> ${w}`), h.reportLog("connect send msg"), !this.isWalletPKReady()) throw new Error("connection not finish");
              let R = this.crypto.encrypt(w, this.connectedWalletPK);
              h.logDebug(`message send =====encrypt message.length>>>> ${R.length}`), h.reportEvent(b.OKXReportType.LOG, "msg_size", R.length.toString());
              let T = this.connectStorage.getItem(l.OKXCONNECTOR_TOKEN_CACHE);
              return h.logDebug(`message send =====topic>>>> ${T == null ? void 0 : T.content}`), yield this.splitManager.sendSplitPackages(T == null ? void 0 : T.content, R, this.sendEncryptedMsg.bind(this), this.sendRaw.bind(this)), this.packageId;
            });
          }
          sendACK(y, w) {
            return r(this, arguments, void 0, function* (A, R, T = void 0) {
              if (R === !0) {
                const D = {
                  id: A,
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  result: !0
                };
                yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                }), D);
              } else if (T) {
                const D = {
                  id: A,
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  error: {
                    code: T.code,
                    message: T.message
                  }
                };
                yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                }), D);
              }
            });
          }
          sendReceive(y, w, A) {
            return r(this, void 0, void 0, function* () {
              const R = {
                id: y,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_RECEIVE,
                params: {
                  data: {
                    messageId: w,
                    topic: A
                  }
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R);
            });
          }
          sendFetchAndConsumeMessages(y, w) {
            return r(this, void 0, void 0, function* () {
              this.events.once(y, T => r(this, void 0, void 0, function* () {
                var D, M;
                if (T.result) {
                  var q = T.result.hasMore,
                    W = T.result.data;
                  const x = T.result.disconnectedTopics;
                  if (x) try {
                    for (let C = 0; C < x.length; C++) {
                      const B = x[C];
                      if (B.topic) {
                        (0, g.logDebug)("send receive disconnect:", B.topic), yield this.sendRecvDisconnect(B.topic);
                        let X = (0, v.safeJsonStringify)({
                            requestId: B.publishedAt.toString(),
                            method: "disconnect"
                          }),
                          J = {
                            messageId: B.publishedAt.toString(),
                            message: (0, v.safeJsonStringify)({
                              message: X
                            }),
                            topic: B.topic,
                            publishedAt: B.publishedAt
                          };
                        yield this.connector.getMsgPayloadFromHistory(J);
                      }
                    }
                  } catch (C) {
                    h.logError("disconnect topic fails", C);
                  }
                  if (W) for (let C = 0; C < W.length; C++) {
                    let B = W[C];
                    if (B && B.topic == w) {
                      let X = B.messageId;
                      h.reportLog("5. get fetch result"), this.splitManager.tryParseMessageSplitPayload(B.message) ? (yield this.connector.getMsgPayloadFromHistory(B), h.logDebug("skip receive")) : (yield this.connector.getMsgPayloadFromHistory(B), this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), X, w));
                    }
                  }
                  q && (this.refreshPackageId(), yield this.sendFetchAndConsumeMessages(this.packageId.toString(), w));
                } else h.logDebug(`CONNECT: get error rsp ${(D = T.error) === null || D === void 0 ? void 0 : D.code} : ${(M = T.error) === null || M === void 0 ? void 0 : M.message}`);
              })), h.logDebug("5. send fetch more"), h.reportLog("5. send fetch more");
              const A = new Date().getTime();
              (0, g.logDebug)("ConnectTime---5->", A - this.timeLog);
              const R = {
                id: y,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_FETCHMSG,
                params: {
                  data: {
                    topic: w
                  }
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return h.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R);
            });
          }
          cleanCache() {
            h.reportLog("connection cache clean called"), this.connectStorage.clearCache();
          }
          saveSessionContent(y, w) {
            w || this.connectStorage.clearCache(l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
            let A = (0, v.safeJsonStringify)(w);
            this.connectStorage.encryptStoreMsg(A, l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
          }
          getSessionContent(y) {
            try {
              let w = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
              if (w) return (0, v.safeJsonParse)(w);
            } catch {
              this.connectStorage.clearCache(l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
            }
          }
          getCurrentConnectionReady() {
            let y = !1;
            try {
              this.getCachedCryptoKeyPair() && (y = !0);
            } catch {
              h.logError("check connection ready failed");
            }
            return this.isWalletPKReady() && y;
          }
          getCryptoKeyEnable() {
            let y = !1;
            try {
              this.getCachedCryptoKeyPair() && (y = !0);
            } catch {
              h.logError("check connection ready failed");
            }
            return y;
          }
          checkExpire(y) {
            let w = !1;
            if (y.length == 0) return (0, g.logDebug)("checkExpire: invalid topic"), w;
            let A = this.getSessionContent(l.OKXCONNECTOR_STORAGE_TOPIC_EXPIRE_CACHE);
            return A && A.topic ? A.topic == y ? Date.now() > A.timestamp && ((0, g.logDebug)("checkExpire: connection is Expired"), w = !0) : ((0, g.logDebug)("checkExpire: not same connection"), w = !1) : ((0, g.logDebug)("checkExpire: not topic records"), this.updateExpireLimit(y), w = !1), w;
          }
          updateExpireLimit(y) {
            (0, g.logDebug)(`update expire limit for topic: ${y}`);
            let w = {
              topic: y,
              timestamp: Date.now() + o.OKXCONNECTOR_SESSION_LIVE_TTL
            };
            this.saveSessionContent(l.OKXCONNECTOR_STORAGE_TOPIC_EXPIRE_CACHE, w);
          }
          activateDisconnect() {
            return r(this, void 0, void 0, function* () {
              let y = (0, v.safeJsonStringify)({
                  requestId: "",
                  method: "disconnect"
                }),
                w = {
                  messageId: "",
                  message: (0, v.safeJsonStringify)({
                    message: y
                  }),
                  topic: this.currentTopic,
                  publishedAt: 0
                };
              yield this.connector.getMsgPayloadFromHistory(w);
            });
          }
        }
        return or.ConnectionManager = N, or;
      }
      var ar = {},
        ts = {},
        ym;
      function HA() {
        return ym || (ym = 1, Object.defineProperty(ts, "__esModule", {
          value: !0
        }), ts.WalletConnectionManagerEvent = ts.WalletConnectionManagerTopicInfoCacheKey = void 0, ts.WalletConnectionManagerTopicInfoCacheKey = "wcmtic", ts.WalletConnectionManagerEvent = {
          RECEIVE_REQUEST: "payload"
        }), ts;
      }
      var mm;
      function jA() {
        if (mm) return ar;
        mm = 1;
        var n = ar && ar.__createBinding || (Object.create ? function (O, y, w, A) {
            A === void 0 && (A = w);
            var R = Object.getOwnPropertyDescriptor(y, w);
            (!R || ("get" in R ? !y.__esModule : R.writable || R.configurable)) && (R = {
              enumerable: !0,
              get: function () {
                return y[w];
              }
            }), Object.defineProperty(O, A, R);
          } : function (O, y, w, A) {
            A === void 0 && (A = w), O[A] = y[w];
          }),
          e = ar && ar.__setModuleDefault || (Object.create ? function (O, y) {
            Object.defineProperty(O, "default", {
              enumerable: !0,
              value: y
            });
          } : function (O, y) {
            O.default = y;
          }),
          t = ar && ar.__importStar || function () {
            var O = function (y) {
              return O = Object.getOwnPropertyNames || function (w) {
                var A = [];
                for (var R in w) Object.prototype.hasOwnProperty.call(w, R) && (A[A.length] = R);
                return A;
              }, O(y);
            };
            return function (y) {
              if (y && y.__esModule) return y;
              var w = {};
              if (y != null) for (var A = O(y), R = 0; R < A.length; R++) A[R] !== "default" && n(w, y, A[R]);
              return e(w, y), w;
            };
          }(),
          r = ar && ar.__awaiter || function (O, y, w, A) {
            function R(T) {
              return T instanceof w ? T : new w(function (D) {
                D(T);
              });
            }
            return new (w || (w = Promise))(function (T, D) {
              function M(x) {
                try {
                  W(A.next(x));
                } catch (C) {
                  D(C);
                }
              }
              function q(x) {
                try {
                  W(A.throw(x));
                } catch (C) {
                  D(C);
                }
              }
              function W(x) {
                x.done ? T(x.value) : R(x.value).then(M, q);
              }
              W((A = A.apply(O, y || [])).next());
            });
          };
        Object.defineProperty(ar, "__esModule", {
          value: !0
        }), ar.WalletConnectionManager = void 0;
        const i = Ad(),
          a = em(),
          l = $c(),
          s = nm(),
          o = zc(),
          c = HA(),
          u = pm(),
          f = Wi(),
          d = wf(),
          p = vr(),
          v = im(),
          h = dm(),
          g = $o(),
          b = t(yn()),
          m = yn(),
          _ = tn();
        class N {
          constructor() {
            this.events = new f.EventEmitter(), this.communicateEvents = new f.EventEmitter(), this.splitManager = new u.ConnectionSplitPackages("wallet"), b.logDebug("connect manager construct"), this.connectStorage = new d.Storage(l.OKXCONNECTOR_CACHE_KEY), this.jwtKeyPair = this.getCachedJWTKeyPair(), this.saveJWTKeyPair(this.jwtKeyPair), this.connector = new i.OKXWalletConnector(o.OKXCONNECTOR_WS_URL_1), this.packageId = Date.now(), this.sessionCryptoInfoMap = new Map(), this.inLogin = !1, this.isLogined = !1;
          }
          refreshPackageId(y = 0) {
            let w = Date.now() + y;
            w == this.packageId && (this.packageId = w + 1), this.packageId = w;
          }
          saveCryptoKeyPair(y, w) {
            let A = (0, g.safeJsonStringify)(w);
            this.connectStorage.encryptStoreMsg(A, l.OKXCONNECTOR_CRYPTO_KEY + y);
          }
          getCachedCryptoKeyPair(y) {
            const A = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_CRYPTO_KEY + y);
            return typeof A == "string" ? (b.logDebug("get cached crypto key:"), b.logDebug(A), (0, g.safeJsonParse)(A)) : (this.connectStorage.clearCache(), null);
          }
          saveJWTKeyPair(y) {
            var w = {
              publicKey: (0, p.toHexString)(y.publicKey),
              secretKey: (0, p.toHexString)(y.secretKey)
            };
            b.logDebug("save jwt kp");
            let A = (0, g.safeJsonStringify)(w);
            b.logDebug(A), this.connectStorage.encryptStoreMsg(A, l.OKXCONNECTOR_JWT_KEY), b.logDebug("after save jwt kp");
          }
          getCachedJWTKeyPair() {
            const w = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_JWT_KEY);
            if (typeof w == "string") {
              b.logDebug("get cached jwt kp:"), b.logDebug(w);
              let R = (0, g.safeJsonParse)(w);
              b.logDebug("save jwt kp"), b.logDebug(R);
              var A = {
                publicKey: (0, p.hexToByteArray)(R.publicKey),
                secretKey: (0, p.hexToByteArray)(R.secretKey)
              };
              return A;
            } else return (0, h.generateKeyPair)();
          }
          isTopicPublicKeyExist(y) {
            return b.logDebug(`isTopicPublicKeyExist  ===> ${y}`), this.sessionCryptoInfoMap.get(y);
          }
          makeJWT(y) {
            return r(this, void 0, void 0, function* () {
              return yield (0, h.signJWT)(y, s.OKXCONNECTOR_JWT_WALLET_SIDE, s.OKXCONNECTOR_JWT_TTL, this.jwtKeyPair);
            });
          }
          parseInternalMsg(y) {
            try {
              let A = (0, g.safeJsonParse)(y)["ivur-igbfft-ptjip"];
              if (A && A.length > 0) return (0, _.base64decode)(A, !0).toString();
            } catch (w) {
              b.logError("parse internal msg", w);
            }
          }
          updateClientId(y, w) {
            let A = this.sessionCryptoInfoMap.get(y);
            if ((0, m.logDebug)("updateClientId", A, y, w), A && w && w.length > 0) {
              if (A.cid) {
                let R = (0, p.getLastSixMd5Hash)(w);
                A.cid == R ? A.dappPublicKey = w : b.logError("cid check failed", A, y, w);
              } else A.dappPublicKey = w;
              this.syncCacheSessionInfo();
            }
            return !1;
          }
          parsePackage(y, w) {
            return r(this, arguments, void 0, function* (A, R, T = !1) {
              var D, M, q, W, x, C, B, X, J, V, $, se, ne, oe, ye, Te, ae;
              this.events.emit(R.id, R);
              let G = this.sessionCryptoInfoMap.get(A);
              b.logDebug("get sessionInfo for decrypt topic:", A), b.logDebug("get sessionInfo for decrypt:", R.id, A, G, this.sessionCryptoInfoMap);
              let Z = !1;
              if (G && R.params.data && !((D = R.params.data) === null || D === void 0) && D.message) if (!((M = R.params.data) === null || M === void 0) && M.isInternalData) {
                let S = (q = R.params.data) === null || q === void 0 ? void 0 : q.message,
                  ee = (W = R.params.data) === null || W === void 0 ? void 0 : W.topic,
                  Ce = this.parseInternalMsg(S);
                (0, m.logDebug)("parse internal origin: ", Ce), Ce && Ce.length > 0 && this.communicateEvents.emit("origin", Ce, ee);
              } else try {
                let S = (x = R.params.data) === null || x === void 0 ? void 0 : x.message;
                if (R.method && R.method === a.CONNECT_METHOD_PUSH && ((0, m.logDebug)("checkExpire: update expire when get push"), this.updateExpireLimit(A)), S.trimStart().startsWith("{")) {
                  let ee = this.splitManager.tryParseMessageSplitPayload(S);
                  if (ee) {
                    (0, m.logDebug)("parse split msg object: ", ee), Z = !0;
                    let Ce = {
                        topicId: (B = (C = R.params) === null || C === void 0 ? void 0 : C.data) === null || B === void 0 ? void 0 : B.topic,
                        messageId: (J = (X = R.params) === null || X === void 0 ? void 0 : X.data) === null || J === void 0 ? void 0 : J.messageId,
                        messageObject: ee,
                        publishedAt: ($ = (V = R.params) === null || V === void 0 ? void 0 : V.data) === null || $ === void 0 ? void 0 : $.publishedAt
                      },
                      Oe = yield this.splitManager.onReceivedPackageCheck(Ce);
                    if (Oe.completeMessageIdList && Oe.completeMessageIdList.forEach(Xe => r(this, void 0, void 0, function* () {
                      this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), Xe, A);
                    })), Oe.finalMessage) {
                      let Xe = G.crypto.decryptWallet(Oe.finalMessage, G.dappPublicKey);
                      (0, m.logDebug)("<<< receive msg from split:", A, Xe), this.communicateEvents.emit(A, Xe);
                    }
                  } else {
                    let Ce = (0, g.safeJsonParse)(S);
                    if (Ce.method) {
                      if (Ce.method == "session_info") {
                        let Oe = Ce.params.sessionInfo,
                          Xe = (0, _.base64decode)(Oe, !1);
                        (0, m.logDebug)("wallet connection manager requset base64Content:", Xe), (0, m.logDebug)("base64Content:" + Xe);
                        let Ve = Xe.toObject();
                        this.updateClientId(A, Ve.clientId);
                      }
                      (0, m.logDebug)("<<< parse raw msg:", A, Ce), this.communicateEvents.emit(A, S);
                    }
                  }
                } else {
                  let ee = G.crypto.decryptWallet((se = R.params.data) === null || se === void 0 ? void 0 : se.message, G.dappPublicKey);
                  (0, m.logDebug)("<<< receive msg:", A, ee), this.communicateEvents.emit(A, ee);
                }
              } catch {
                let ee = G.crypto.decryptWallet((ne = R.params.data) === null || ne === void 0 ? void 0 : ne.message, G.dappPublicKey);
                (0, m.logDebug)("<<< receive msg:", A, ee), this.communicateEvents.emit(A, ee);
              }
              if (!T && (yield this.sendACK(R.id, !0), A && !Z)) {
                let S = R;
                !((ye = (oe = S.params) === null || oe === void 0 ? void 0 : oe.data) === null || ye === void 0) && ye.messageId && (this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), (ae = (Te = S.params) === null || Te === void 0 ? void 0 : Te.data) === null || ae === void 0 ? void 0 : ae.messageId, A));
              }
            });
          }
          recovrySessionInfoFromCache() {
            let y = this.connectStorage.getAndDecrypt(c.WalletConnectionManagerTopicInfoCacheKey);
            if (b.logDebug("get cached sessionInfos:", y), y) {
              let w = (0, g.safeJsonParse)(y);
              for (let A in w) {
                let R = w[A];
                b.logDebug("make topicItem:", R);
                let T = {
                  topic: A,
                  crypto: new v.SessionCrypto({
                    publicKey: R.cryptoKeyPair.publicKey,
                    secretKey: R.cryptoKeyPair.secretKey
                  }),
                  dappPublicKey: R.dappPublicKey,
                  cid: R.cid
                };
                this.sessionCryptoInfoMap.set(A, T);
              }
            }
            b.logDebug("get cached sessionInfos map:", this.sessionCryptoInfoMap);
          }
          syncCacheSessionInfo() {
            let y = {};
            for (let [A, R] of this.sessionCryptoInfoMap) b.logDebug("for each Keys", A), R && (y[A] = {
              cryptoKeyPair: R.crypto.stringifyKeypair(),
              dappPublicKey: R.dappPublicKey,
              cid: R.cid
            });
            let w = (0, g.safeJsonStringify)(y);
            b.logDebug("sync cache sessionInfos:", w), this.connectStorage.encryptStoreMsg(w, c.WalletConnectionManagerTopicInfoCacheKey);
          }
          cacheSessionInfo(y, w, A = !0) {
            let R = w.dappPublicKey,
              T = [];
            for (let [D, M] of this.sessionCryptoInfoMap) b.logDebug("for each Keys", D), M.dappPublicKey == R && (b.logDebug("duplicated dapp public key:", D, R), T.push(D));
            for (let [D, M] of this.sessionCryptoInfoMap) T.includes(D) && this.sessionCryptoInfoMap.delete(D);
            return b.logDebug("cleaned connect session cache:", this.sessionCryptoInfoMap), this.sessionCryptoInfoMap.set(y, w), b.logDebug("cache sessionInfo:", y, w, this.sessionCryptoInfoMap), A && this.syncCacheSessionInfo(), T;
          }
          updateProtocolVersion(y, w) {
            this.splitManager.updateTopicSenderVersion(y, w);
          }
          appendTopic(y, w, A) {
            return r(this, void 0, void 0, function* () {
              return (0, m.logDebug)("4.1. get append Topic:", y), new Promise((R, T) => r(this, void 0, void 0, function* () {
                if (!this.isLogined) {
                  var D = new Error();
                  D.message = "connection is not logined", D.name = "append error", T(D);
                  return;
                }
                let M = {
                    topic: y,
                    crypto: new v.SessionCrypto(),
                    dappPublicKey: w || "",
                    cid: A
                  },
                  q = this.cacheSessionInfo(y, M, !1);
                yield this.subscribeTopics(Array.from([y])), this.refreshPackageId(), b.logDebug(`5. subscribe callback then fetch append message: ${this.packageId}, ${y}`), b.reportLog("5. subscribe callback then fetch append message");
                const W = new Date().getTime();
                (0, m.logDebug)("Append --subscribe callback->", W - this.timeLog), R(q);
              }));
            });
          }
          confirmAppendingTopics() {
            this.syncCacheSessionInfo();
          }
          connect() {
            return r(this, void 0, void 0, function* () {
              this.timeLog = new Date().getTime(), (0, m.logDebug)("[Wallet] ConnectTime---enter->", this.timeLog), b.reportLog("wallet connect connect called");
              let y = Date.now().toString();
              var w = yield this.makeJWT(y);
              return b.logDebug(`generate jwt token: ${w}`), this.connectStorage.saveContent(w, "jwt"), this.recovrySessionInfoFromCache(), new Promise((A, R) => {
                this.inLogin = !0, this.connector.onOpen(() => r(this, void 0, void 0, function* () {
                  b.logDebug("1. connector on open"), b.reportLog("1. wallet connect connect on open");
                  const T = new Date().getTime();
                  (0, m.logDebug)("ConnectTime---open->", T - this.timeLog), this.events.once(this.packageId.toString(), D => r(this, void 0, void 0, function* () {
                    if (D && D.error) {
                      b.logError("failed when login"), yield this.connector.disconnect();
                      var M = new Error();
                      M.message = D.error.message, M.name = D.error.code.toString(), R(M);
                    } else this.isLogined = !0, A(), b.logDebug("3. subscribe cached topics", this.sessionCryptoInfoMap), b.reportLog("3. wallet connect connect subscribe cached topics"), this.sessionCryptoInfoMap.size > 0 && (yield this.subscribeTopics(Array.from(this.sessionCryptoInfoMap.keys())));
                  })), b.logDebug("2. login called"), b.reportLog("2. wallet connect login called"), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                    return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                  }), {
                    id: this.packageId.toString(),
                    jsonrpc: o.CONNECT_JSONRPC_VER,
                    method: a.CONNECT_METHOD_LOGIN,
                    params: {
                      token: w
                    }
                  });
                })), this.connector.connect().catch(T => {
                  (0, m.logDebug)("WalletConnectionManager connect error", T), R(T);
                }), this.connector.addPackageParse(T => {
                  var D, M;
                  if (b.logDebug("connect: parse package"), b.logDebug(T), !("params" in T) || !("data" in T.params)) {
                    this.parsePackage("", T, !0);
                    return;
                  }
                  !((D = T.params.data) === null || D === void 0) && D.topic && this.parsePackage((M = T.params.data) === null || M === void 0 ? void 0 : M.topic, T, T.method === a.CONNECT_METHOD_RECEIVE);
                });
              });
            });
          }
          getSessionPublicKey(y) {
            if (this.isTopicPublicKeyExist(y)) {
              let w = this.sessionCryptoInfoMap.get(y);
              if (w) return (0, p.toHexString)(w.crypto.keyPair.publicKey);
            }
          }
          getCurrentCachedTopicIdList() {
            return Array.from(this.sessionCryptoInfoMap.keys());
          }
          sendDisconnect(y) {
            return r(this, void 0, void 0, function* () {
              this.refreshPackageId();
              const w = {
                id: this.packageId.toString(),
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_DISCONNECT,
                params: {
                  message: {
                    topic: y,
                    ttl: o.OKXCONNECTOR_MESSAGE_DISCONNECT_TTL
                  }
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), w);
            });
          }
          sendRecvDisconnect(y) {
            return r(this, void 0, void 0, function* () {
              this.refreshPackageId();
              const w = {
                id: this.packageId.toString(),
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_RECV_DISCONNECT,
                params: {
                  topic: y
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), w);
            });
          }
          disconnect() {
            return r(this, arguments, void 0, function* (y = !1) {
              yield this.connector.disconnect(), this.connectStorage.clearCache(l.OKXCONNECTOR_TOKEN_CACHE), y || this.connectStorage.clearCache(l.OKXCONNECTOR_CRYPTO_SENDER_PK_CACHE);
            });
          }
          sendRaw(y, w) {
            return r(this, void 0, void 0, function* () {
              w && (yield this.sendMsg(w, y, o.OKXCONNECTOR_MESSAGE_TTL));
            });
          }
          sendMsg(y, w, A) {
            return r(this, void 0, void 0, function* () {
              if (w) {
                this.refreshPackageId();
                const R = {
                  id: this.packageId.toString(),
                  method: a.CONNECT_METHOD_PUBLISH,
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  params: {
                    message: {
                      topic: y,
                      message: w,
                      ttl: A
                    }
                  }
                };
                this.events.once(this.packageId.toString(), T => r(this, void 0, void 0, function* () {
                  T && T.error ? b.logError(`@${new Date().toUTCString()} >>> failed when send msg`) : T && !T.error && b.logDebug(`CONNECTION @[${new Date().toUTCString()}] >>> send msg with id ${this.packageId} successed`);
                })), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                }), R);
              }
            });
          }
          send(y, w) {
            return r(this, arguments, void 0, function* (A, R, T = !1, D = o.OKXCONNECTOR_MESSAGE_TTL, M = !1) {
              var q, W;
              if (b.logDebug(`message send =====> ${R}`), !this.isTopicPublicKeyExist(A)) throw new Error("connection not finish");
              let x = (q = this.sessionCryptoInfoMap.get(A)) === null || q === void 0 ? void 0 : q.dappPublicKey,
                C = (W = this.sessionCryptoInfoMap.get(A)) === null || W === void 0 ? void 0 : W.crypto,
                B;
              M && (B = {
                message: R
              });
              let X = !1;
              if (C && x && !M) {
                let J = C.encryptWallet(R, x);
                X = !0, B = {
                  message: J
                };
              }
              if (B) {
                T && C && (B.clientId = (0, p.toHexString)(C.keyPair.publicKey));
                let J = (0, g.safeJsonStringify)(B);
                !M && X ? yield this.splitManager.sendSplitPackages(A, J, this.sendMsg.bind(this), this.sendRaw.bind(this)) : yield this.sendMsg(A, J, D);
              }
            });
          }
          sendACK(y, w) {
            return r(this, arguments, void 0, function* (A, R, T = void 0) {
              if (R === !0) {
                const D = {
                  id: A,
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  result: !0
                };
                yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                }), D);
              } else if (T) {
                const D = {
                  id: A,
                  jsonrpc: o.CONNECT_JSONRPC_VER,
                  error: {
                    code: T.code,
                    message: T.message
                  }
                };
                yield this.connector.send(() => r(this, void 0, void 0, function* () {
                  return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                }), D);
              }
            });
          }
          sendReceive(y, w, A) {
            return r(this, void 0, void 0, function* () {
              const R = {
                id: y,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_RECEIVE,
                params: {
                  data: {
                    messageId: w,
                    topic: A
                  }
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R);
            });
          }
          sendUnsubscribe(y) {
            return r(this, void 0, void 0, function* () {
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), {
                id: this.packageId.toString(),
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_UNSUB,
                params: {
                  topic: y
                }
              });
              try {
                yield this.sendDisconnect(y);
              } catch (w) {
                b.logError("send disconnect command failed", w);
              }
              this.sessionCryptoInfoMap.delete(y), this.syncCacheSessionInfo();
            });
          }
          sendFetchAndConsumeMessages(y, w) {
            return r(this, void 0, void 0, function* () {
              this.events.once(y, T => r(this, void 0, void 0, function* () {
                var D, M;
                if (T.result) {
                  var q = T.result.hasMore,
                    W = T.result.data;
                  if (W) for (let x = 0; x < W.length; x++) {
                    let C = W[x];
                    if (C && C.topic == w) {
                      let B = C.messageId;
                      yield this.connector.getMsgPayloadFromHistory(C), this.refreshPackageId(), yield this.sendReceive(this.packageId.toString(), B, w);
                    }
                  }
                  q && (this.refreshPackageId(), yield this.sendFetchAndConsumeMessages(this.packageId.toString(), w));
                } else b.logDebug(`CONNECT: get error rsp ${(D = T.error) === null || D === void 0 ? void 0 : D.code} : ${(M = T.error) === null || M === void 0 ? void 0 : M.message}`);
              })), b.logDebug("5. send fetch more");
              const A = new Date().getTime();
              (0, m.logDebug)("ConnectTime---5->", A - this.timeLog);
              const R = {
                id: y,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_FETCHMSG,
                params: {
                  data: {
                    topic: w
                  }
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R);
            });
          }
          sendBatchFetchAndConsumeMessages(y, w) {
            return r(this, void 0, void 0, function* () {
              this.events.once(y, T => r(this, void 0, void 0, function* () {
                var D, M;
                if (T.result) {
                  var q = T.result.hasMore,
                    W = T.result.data;
                  const x = T.result.disconnectedTopics;
                  if (x) try {
                    for (let C = 0; C < x.length; C++) {
                      const B = x[C];
                      if (B.topic) {
                        (0, m.logDebug)("send receive disconnect:", B.topic), yield this.sendRecvDisconnect(B.topic);
                        let X = (0, g.safeJsonStringify)({
                            requestId: B.publishedAt.toString(),
                            method: a.CONNECT_METHOD_DISCONNECT
                          }),
                          J = {
                            messageId: B.publishedAt.toString(),
                            message: (0, g.safeJsonStringify)({
                              message: X
                            }),
                            topic: B.topic,
                            publishedAt: B.publishedAt
                          };
                        yield this.connector.getMsgPayloadFromHistory(J);
                      }
                    }
                  } catch (C) {
                    b.logError("disconnect topic fails", C);
                  }
                  if (W) for (let C = 0; C < W.length; C++) {
                    let B = W[C];
                    if (B && B.topic) if (this.splitManager.tryParseMessageSplitPayload(B.message)) yield this.connector.getMsgPayloadFromHistory(B);else {
                      let J = B.messageId;
                      yield this.connector.getMsgPayloadFromHistory(B), this.refreshPackageId(C), yield this.sendReceive(this.packageId.toString(), J, B.topic);
                    }
                  }
                  q && (this.refreshPackageId(), yield this.sendBatchFetchAndConsumeMessages(this.packageId.toString(), w));
                } else b.logDebug(`CONNECT: get error rsp ${(D = T.error) === null || D === void 0 ? void 0 : D.code} : ${(M = T.error) === null || M === void 0 ? void 0 : M.message}`);
              })), b.logDebug("5. send fetch more"), b.reportLog("5. send fetch more");
              const A = new Date().getTime();
              (0, m.logDebug)("ConnectTime---5->", A - this.timeLog);
              const R = {
                id: y,
                jsonrpc: o.CONNECT_JSONRPC_VER,
                method: a.CONNECT_METHOD_BATCH_FETCHMSG,
                params: {
                  topics: w,
                  withInternalData: !0
                }
              };
              yield this.connector.send(() => r(this, void 0, void 0, function* () {
                b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
              }), R);
            });
          }
          cleanCache() {
            return r(this, void 0, void 0, function* () {
              this.connectStorage.clearCache();
            });
          }
          saveSessionContent(y, w) {
            w || this.connectStorage.clearCache(l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
            let A = (0, g.safeJsonStringify)(w);
            this.connectStorage.encryptStoreMsg(A, l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
          }
          getSessionContent(y) {
            let w = this.connectStorage.getAndDecrypt(l.OKXCONNECTOR_SESSION_PREFIX_KEY + y);
            if (w) return (0, g.safeJsonParse)(w);
          }
          subscribeTopics(y) {
            return r(this, void 0, void 0, function* () {
              (0, m.logDebug)("4. topicid list", y), b.reportLog("4. topicid list"), this.refreshPackageId();
              const w = new Date().getTime();
              return (0, m.logDebug)("ConnectTime--subscribe callback->", w - this.timeLog), new Promise((A, R) => r(this, void 0, void 0, function* () {
                let T = 0;
                for (let D = 0; D < y.length; ++D) {
                  let M = y[D];
                  this.refreshPackageId(D), this.events.once(this.packageId.toString(), W => r(this, void 0, void 0, function* () {
                    if (W && W.error) {
                      b.logError("failed when subscribe"), yield this.connector.disconnect();
                      var x = new Error();
                      x.message = W.error.message, x.name = W.error.code.toString(), T += 1, T == y.length && A();
                    }
                    this.refreshPackageId(D);
                    const C = new Date().getTime();
                    (0, m.logDebug)("ConnectTime--subscribe callback->", C - this.timeLog), T += 1, T == y.length && (b.logDebug(`5. send fetch msg: ${this.packageId}, ${M}`), yield this.sendBatchFetchAndConsumeMessages(this.packageId.toString(), y), yield this.splitManager.init(this.sendRaw.bind(this)), this.checkExpire(M) ? ((0, m.logDebug)("disconnect From topic expire"), yield this.activateDisconnect(M)) : ((0, m.logDebug)("extends expire check"), this.updateExpireLimit(M)), A());
                  })), b.logDebug(`3. login callback then send subscribe: ${this.packageId}, ${M}`), b.reportLog("3. login callback then send subscribe");
                  const q = new Date().getTime();
                  (0, m.logDebug)("ConnectTime---login callback->", q - this.timeLog), yield this.connector.send(() => r(this, void 0, void 0, function* () {
                    return b.logDebug("CONNECT: reconnect before send"), yield this.connector.connect();
                  }), {
                    id: this.packageId.toString(),
                    jsonrpc: o.CONNECT_JSONRPC_VER,
                    method: a.CONNECT_METHOD_SUB,
                    params: {
                      topic: M
                    }
                  });
                }
              }));
            });
          }
          checkExpire(y) {
            let w = !1;
            if (y.length == 0) return (0, m.logDebug)("checkExpire: invalid topic"), w;
            let A = this.getSessionContent(l.OKXCONNECTOR_STORAGE_TOPIC_WALLET_EXPIRE_CACHE);
            if (A && A instanceof Object) try {
              let T = new Map(Object.entries(A)).get(y);
              T ? Date.now() > T && ((0, m.logDebug)("checkExpire: connection is Expired"), w = !0) : ((0, m.logDebug)("checkExpire: not same connection"), w = !1);
            } catch {
              (0, m.logDebug)("checkExpire: cache error"), w = !1;
            } else (0, m.logDebug)("checkExpire: not topic records"), this.updateExpireLimit(y), w = !1;
            return w;
          }
          updateExpireLimit(y) {
            (0, m.logDebug)(`update expire limit for topic: ${y}`);
            try {
              let w = this.getSessionContent(l.OKXCONNECTOR_STORAGE_TOPIC_WALLET_EXPIRE_CACHE),
                A = new Map();
              w && (A = new Map(Object.entries(w)));
              let R = Date.now() + o.OKXCONNECTOR_SESSION_LIVE_TTL;
              A.set(y, R), this.saveSessionContent(l.OKXCONNECTOR_STORAGE_TOPIC_WALLET_EXPIRE_CACHE, Object.fromEntries(A));
            } catch {
              (0, m.logDebug)("update cache failed");
            }
          }
          activateDisconnect(y) {
            return r(this, void 0, void 0, function* () {
              let w = (0, g.safeJsonStringify)({
                  requestId: "",
                  method: a.CONNECT_METHOD_DISCONNECT
                }),
                A = {
                  messageId: "",
                  message: (0, g.safeJsonStringify)({
                    message: w
                  }),
                  topic: y,
                  publishedAt: 0
                };
              yield this.connector.getMsgPayloadFromHistory(A);
            });
          }
        }
        return ar.WalletConnectionManager = N, ar;
      }
      var ns = {},
        Td = {},
        bm;
      function qi() {
        return bm || (bm = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.CONNECTOR_TYPE = n.STANDARD_INJECT_WALLET = n.OTHER_INJECT_WALLET = n.OKX_TG_WALLET = n.OKX_APP_WALLET = n.OKX_INJECT_WALLET = void 0, n.getTagByappName = r;
          const e = Jt(),
            t = Pu();
          n.OKX_INJECT_WALLET = "okx_inject_wallet", n.OKX_APP_WALLET = "okx_app_wallet", n.OKX_TG_WALLET = "okx_tg_wallet", n.OTHER_INJECT_WALLET = "other_inject_wallet", n.STANDARD_INJECT_WALLET = "standard_inject_wallet", n.CONNECTOR_TYPE = {
            WS: {
              OKX_APP_WALLET: 100,
              OKX_TG_WALLET: 110
            },
            INJECT: {
              OKX_INJECT_WALLET: 200,
              STANDARD_INJECT_WALLET: 210
            },
            KEYLESS: {
              APPLE_WALLET: 300,
              GOOGLE_WALLET: 310
            }
          };
          function r(i) {
            var a = "";
            if (i) switch (i) {
              case e.OKXWalletName:
                a = n.OKX_APP_WALLET;
                break;
              case t.OKXMiniWalletName:
                a = n.OKX_TG_WALLET;
                break;
              case t.OKXInjectWalletName:
                a = n.OKX_INJECT_WALLET;
            }
            return a || i || "";
          }
        }(Td)), Td;
      }
      var Na = {},
        wm;
      function xm() {
        if (wm) return Na;
        wm = 1, Object.defineProperty(Na, "__esModule", {
          value: !0
        }), Na.buildNameSpacesByConnectResponse = e, Na.buildRequestAccountNameSpacesByConnectResponse = t, Na.buildAccountNameSpaces = r;
        const n = yn();
        function e(i) {
          return t(i);
        }
        function t(i) {
          let a = {};
          (0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse start connectResponse111>>", JSON.stringify(i));
          let l = i.payload.responses.find(c => c.name === "requestAccounts");
          if (l && l.accounts) {
            let c = [];
            for (const u of l.accounts) u.namespace === "ton" ? u.data && u.data.ton_addr && u.data.ton_addr.address && u.data.ton_addr.address.length > 0 && ((0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse start TON>>", JSON.stringify(u)), c.push(u)) : ((0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse start other>>", JSON.stringify(u)), c.push(u));
            l.accounts = c;
          }
          const s = i.payload.responses.find(c => c.name === "ton_addr"),
            o = i.payload.responses.find(c => c.name === "ton_proof");
          if (s && !l) {
            (0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse adapt ton data >>");
            let c = s.address;
            c = "ton:" + s.network + ":" + c;
            let u = {
              ton_addr: s
            };
            o && (u.ton_proof = o), l = {
              name: "requestAccounts",
              accounts: [{
                namespace: "ton",
                addresses: [c],
                methods: ["ton_sendTransaction"],
                extra: {},
                data: u
              }]
            };
          }
          return (0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse end universalResponse>>>", JSON.stringify(l)), r(l.accounts, a), a;
        }
        function r(i, a) {
          i.forEach(l => {
            var s = [],
              o = [];
            l.addresses.forEach(c => {
              var u = c.split(":");
              if ((0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse addressArr>>", u.length), u.length >= 3) {
                let f = u.slice(0, 2).join(":");
                s.push(f), o.push(c), (0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse chain:>>", f, "addressItem:", c);
              }
            }), l.data && l.data.ton_addr && (l.data.ton_addr.name = "ton_addr"), l.data && l.data.ton_proof && (l.data.ton_proof.name = "ton_proof"), a[l.namespace] = {
              chains: s,
              accounts: o,
              methods: l.methods,
              extra: l.extra,
              payload: l.data
            }, (0, n.logDebug)("buildRequestAccountNameSpacesByConnectResponse result>>", JSON.stringify(a));
          });
        }
        return Na;
      }
      var _m;
      function WA() {
        if (_m) return ns;
        _m = 1;
        var n = ns && ns.__awaiter || function (c, u, f, d) {
          function p(v) {
            return v instanceof f ? v : new f(function (h) {
              h(v);
            });
          }
          return new (f || (f = Promise))(function (v, h) {
            function g(_) {
              try {
                m(d.next(_));
              } catch (N) {
                h(N);
              }
            }
            function b(_) {
              try {
                m(d.throw(_));
              } catch (N) {
                h(N);
              }
            }
            function m(_) {
              _.done ? v(_.value) : p(_.value).then(g, b);
            }
            m((d = d.apply(c, u || [])).next());
          });
        };
        Object.defineProperty(ns, "__esModule", {
          value: !0
        }), ns.Engine = void 0;
        const e = Jt(),
          t = zc(),
          r = tn(),
          i = qi(),
          a = vm(),
          l = xm(),
          s = Pu();
        class o {
          constructor(u) {
            this.connectors = [], this.useConnector = void 0, this.sessionRetryTimer = null, this.connectionManager = new a.ConnectionManager(u), this.addConnectionListener();
          }
          getConnector() {
            if (this.useConnector) return this.useConnector;
          }
          setAccountChangeListener(u) {
            this.accountChangeListener = u, (0, r.logDebug)("setAccountChangeListener: engine", u);
            for (const f of this.connectors) f.setAccountChangeListener(u);
          }
          registerConnector(u) {
            this.connectors = u;
            for (const f of u) f.setConnectionManager(this.connectionManager);
          }
          getAllConnectors() {
            return this.connectors;
          }
          hasWsConnector() {
            for (const u of this.connectors) if (this.isWsConnector(u)) return !0;
            return !1;
          }
          isWsConnector(u) {
            return u ? Object.values(i.CONNECTOR_TYPE.WS).includes(u.getType()) : !1;
          }
          isInjectedConnector(u) {
            return u ? Object.values(i.CONNECTOR_TYPE.INJECT).includes(u.getType()) || Object.values(i.CONNECTOR_TYPE.KEYLESS).includes(u.getType()) : !1;
          }
          universalConnect(u, f, d) {
            return n(this, void 0, void 0, function* () {
              return this.addConnectionListener(), new Promise((p, v) => n(this, void 0, void 0, function* () {
                var h, g, b, m, _;
                try {
                  (0, r.logDebug)("engine universalConnect request :", JSON.stringify(u)), (0, r.logDebug)("engine universalConnect sessionConfig :", JSON.stringify(f));
                  let N = [];
                  u.forEach(x => {
                    let C = x.name;
                    (C.startsWith("requestAccounts") || C.startsWith("ton")) && N.push(x);
                  }), (0, r.logDebug)("engine universalConnect universalRequest :", JSON.stringify(N));
                  const O = this.connectionManager.getConnectInfo(),
                    y = Date.now().toString();
                  let w = (h = f.openUniversalUrl) !== null && h !== void 0 ? h : !1,
                    A = (g = f.openAppLinkType) !== null && g !== void 0 ? g : e.OpenAppLinkType.UniversalLink;
                  const R = {
                      protocolVer: Number(e.tonConnectSdkVersion),
                      topic: O.channelId,
                      clientId: O.clientId,
                      requestId: y,
                      dAppInfo: this.fixDappName(f.dappInfo),
                      requests: N,
                      redirect: (b = f == null ? void 0 : f.redirect) !== null && b !== void 0 ? b : "none"
                    },
                    T = (0, r.encodeConnectParams)(R);
                  R.redirect = (m = f == null ? void 0 : f.redirect) !== null && m !== void 0 ? m : "none", (0, r.logDebug)("engine universalConnect ==>>universalConnectRequest:", JSON.stringify(R));
                  let D = "",
                    M = "";
                  if (w) {
                    let x = (0, r.getOKXLink)(R, f.useMini, f.tmaReturnUrl);
                    D = x.universalLink, M = x.deepLink || "", (0, r.logDebug)("engine universalConnect ==>>openOKXLink:", D);
                  }
                  const q = () => this.connectors.length == 1 && this.isInjectedConnector(this.connectors[0]) ? this.connectors[0].openWallet({
                    connectRequest: R
                  }, A) : f.useMini ? (0, r.openOKXTMAWalletlinkWithFallback)(D) : (0, r.openOKXDeeplinkWithFallback)(M, D, A);
                  (0, r.logDebug)("engine universalConnect ==>>openOKXLink:", D);
                  const W = (0, r.isIos)();
                  if (W && w && ((0, r.logDebug)(`engine universalConnect ==>>isIOS: ${W}   openUniversalLink: ${w}`), q()), this.addOnConnectResultListener((x, C) => {
                    var B, X, J, V;
                    try {
                      this.stopSendSessionRetry(), this.addOnConnectResultListener(void 0);
                      let ne = x;
                      if (ne.method == "connect") {
                        (0, r.logDebug)("engin  universalConnect success connectResponse:>>>", JSON.stringify(ne));
                        let oe = (0, l.buildNameSpacesByConnectResponse)(ne);
                        if (oe) {
                          let ye;
                          !((X = (B = ne.payload) === null || B === void 0 ? void 0 : B.responses) === null || X === void 0) && X[0] && "walletName" in ne.payload.responses[0] && (ye = ne.payload.responses[0].walletName);
                          let Te = (J = ne.payload) === null || J === void 0 ? void 0 : J.wallet.appName;
                          var $ = "";
                          switch (Te) {
                            case s.OKXWalletName:
                              $ = i.OKX_APP_WALLET;
                              break;
                            case s.OKXMiniWalletName:
                              $ = i.OKX_TG_WALLET;
                              break;
                          }
                          var se;
                          if (C ? se = C : $ && (se = this.connectors.find(Z => Z.getTag() === $)), !se) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
                          let ae = Object.assign({
                              topic: O.channelId,
                              sessionConfig: f,
                              namespaces: oe
                            }, ne.payload && {
                              wallet: Object.assign(Object.assign({}, ne.payload.wallet), {
                                walletName: ye
                              })
                            }),
                            G = ne.payload.responses.find(Z => Z.name === "requestAccounts");
                          G && G.connectRequestMethods && (ae.signResponse = G.connectRequestMethods), (0, r.logDebug)("engin  universalConnect success session:>>>", JSON.stringify(ae)), this.isWsConnector(se) && ((0, r.logDebug)("engine update protocol version"), this.connectionManager.updateProtocolVersion(O.channelId, ne.payload.wallet.maxProtocolVersion)), this.deviceInfo = Object.assign({}, ae.wallet), p(ae), this.setUseConnector(se), (0, r.reportEvent)(r.OKXReportType.PAGE_IN, r.Report_OKXConnectSDKExtension_ConnectDapp_ConnectSuccess_View, $);
                        } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
                      } else if (ne.method == "connect_error" && ((V = ne.payload) === null || V === void 0 ? void 0 : V.code) != null) throw new e.OKXConnectError(ne.payload.code);
                    } catch (ne) {
                      v(ne);
                    }
                  }), this.hasWsConnector()) {
                    yield (_ = this.connectionManager) === null || _ === void 0 ? void 0 : _.disconnect(!1);
                    try {
                      yield this.connectionManager.connect();
                    } catch (x) {
                      throw (0, r.logDebug)("Engine universalConnect error", x), x;
                    }
                    (0, r.logDebug)("engin  universalConnect ==>> connectInfoAndUrl:", d), this.sendSession(T, R.topic, w);
                  }
                  if (!W && w && q(), (0, r.logDebug)("engin  universalConnect ==>> connectInfoAndUrl:", d), d) {
                    const x = {
                      connectRequest: R,
                      redirect: f.redirect,
                      tmaReturnUrl: f.tmaReturnUrl
                    };
                    (0, r.logDebug)("universalConnect connectInfoAndUrl info :", JSON.stringify(x)), d(x);
                  }
                } catch (N) {
                  (0, r.logDebug)("Engine universalConnect catch error", N), v(N);
                }
              }));
            });
          }
          fixDappName(u) {
            try {
              if (u.name.toLowerCase() === "dapp portal") {
                let f = document.title;
                if (f || (f = this.getOGSiteName()), f) return Object.assign(Object.assign({}, u), {
                  name: u.name + " - " + f
                });
              }
              return u;
            } catch {
              return u;
            }
          }
          getOGSiteName() {
            let u = document.getElementsByTagName("meta"),
              f = ["og:site_name", "og:title", "twitter:title"];
            for (let d of u) {
              let p = d.getAttribute("property");
              for (let v of f) if (p == v) return d.getAttribute("content");
            }
          }
          addOnConnectResultListener(u) {
            for (const f of this.connectors) this.isInjectedConnector(f) && f.setOnConnectResultListener(u);
            this.connectResultListener = u;
          }
          openWallet(u, f, d) {
            var p;
            f ? f.openWallet(u, d) : (p = this.getConnector()) === null || p === void 0 || p.openWallet(u, d);
          }
          send(u, f, d) {
            return n(this, void 0, void 0, function* () {
              var p, v, h, g, b, m, _, N, O;
              let y;
              "chainId" in u && u.chainId != null && (y = u.chainId.toString());
              try {
                if ((0, r.reportEvent)(r.OKXReportType.LOG, r.Report_OKXConnectSDK_RequestStart_Log, "", (v = (p = this.getConnector()) === null || p === void 0 ? void 0 : p.getTag()) !== null && v !== void 0 ? v : "", u.method, (g = (h = this.deviceInfo) === null || h === void 0 ? void 0 : h.platform) !== null && g !== void 0 ? g : "", y), !this.getConnector()) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
                (b = this.getConnector()) === null || b === void 0 || b.send(u, {
                  resolve: w => {
                    var A, R, T, D, M, q, W, x, C;
                    (A = f == null ? void 0 : f.resolve) === null || A === void 0 || A.call(f, w), "error" in w && w.error ? (0, r.reportEvent)(r.OKXReportType.LOG, r.Report_OKXConnectSDK_RequestError_Log, "", (T = (R = this.getConnector()) === null || R === void 0 ? void 0 : R.getTag()) !== null && T !== void 0 ? T : "", u.method, (M = (D = this.deviceInfo) === null || D === void 0 ? void 0 : D.platform) !== null && M !== void 0 ? M : "", y) : (0, r.reportEvent)(r.OKXReportType.LOG, r.Report_OKXConnectSDK_RequestSuccess_Log, "", (W = (q = this.getConnector()) === null || q === void 0 ? void 0 : q.getTag()) !== null && W !== void 0 ? W : "", u.method, (C = (x = this.deviceInfo) === null || x === void 0 ? void 0 : x.platform) !== null && C !== void 0 ? C : "", y);
                  },
                  onAck: () => {
                    var w;
                    (w = f == null ? void 0 : f.onAck) === null || w === void 0 || w.call(f);
                  }
                });
              } catch (w) {
                throw (0, r.reportEvent)(r.OKXReportType.LOG, r.Report_OKXConnectSDK_RequestError_Log, "", (_ = (m = this.getConnector()) === null || m === void 0 ? void 0 : m.getTag()) !== null && _ !== void 0 ? _ : "", u.method, (O = (N = this.deviceInfo) === null || N === void 0 ? void 0 : N.platform) !== null && O !== void 0 ? O : "", y), w;
              }
            });
          }
          clearData() {
            var u;
            (u = this.getConnector()) === null || u === void 0 || u.clearData();
          }
          addDisconnectListener(u) {
            var f;
            (f = this.getConnector()) === null || f === void 0 || f.addDisconnectListener(u);
          }
          saveSessionContent(u, f) {
            this.connectionManager.saveSessionContent(u, f);
          }
          getSessionContent(u) {
            var f,
              d = this.connectionManager.getSessionContent(u);
            if (d) {
              var p = "";
              if (typeof d == "object" && (p = (0, i.getTagByappName)((f = d.wallet) === null || f === void 0 ? void 0 : f.appName)), this.connectors.find(v => v.getTag() === p)) return d;
            }
          }
          setConnectConnector(u) {
            var f = (0, i.getTagByappName)(u == null ? void 0 : u.appName);
            f && this.setUseConnector(this.connectors.find(d => d.getTag() === f));
          }
          setUseConnector(u) {
            this.useConnector = u, this.isWsConnector(u) && u.addConnectionListener();
          }
          setSessionConnectingListener(u) {
            this.sessionConnectingListener = u;
          }
          restoreconnect(u, f) {
            return n(this, void 0, void 0, function* () {
              this.getConnector() ? this.getConnector().restoreconnect(u, d => {
                var p, v;
                f(d), d && (this.deviceInfo = Object.assign({}, d.wallet), (0, r.reportEvent)(r.OKXReportType.PAGE_IN, r.Report_OKXConnectSDKExtension_ConnectDapp_ConnectSuccess_View, (v = (p = this.getConnector()) === null || p === void 0 ? void 0 : p.getTag()) !== null && v !== void 0 ? v : ""));
              }) : f(null);
            });
          }
          restoreconnectFromTopic(u) {
            return n(this, void 0, void 0, function* () {
              this.isWsConnector(this.getConnector()) && (yield this.getConnector().restoreconnectFromTopic(u));
            });
          }
          getCurrentConnectionReady(u) {
            var f;
            return !!(!((f = this.getConnector()) === null || f === void 0) && f.getCurrentConnectionReady(u));
          }
          connectManagerDisconnect() {
            return n(this, arguments, void 0, function* (u = !1) {
              var f, d;
              this.getConnector() ? (f = this.getConnector()) === null || f === void 0 || f.connectManagerDisconnect(u) : yield (d = this.connectors.find(p => this.isWsConnector(p))) === null || d === void 0 ? void 0 : d.connectManagerDisconnect(u), this.stopSendSessionRetry(), this.setUseConnector(void 0);
            });
          }
          sendSession(u, f, d) {
            return n(this, void 0, void 0, function* () {
              (0, r.logDebug)("[Connect] sendSession called:", u);
              const p = Date.now().toString();
              let v = {
                method: "session_info",
                params: {
                  protocolVersion: t.CONNECT_PROTOCOL_VER,
                  sessionInfo: u
                }
              };
              yield this.connectionManager.sendRaw(JSON.stringify(Object.assign(Object.assign({}, v), {
                requestId: p
              }))), this.sessionRetryTimer && clearInterval(this.sessionRetryTimer), d || (this.sessionRetryTimer = setInterval(() => n(this, void 0, void 0, function* () {
                const h = Date.now().toString();
                (0, r.logDebug)("[Connect] Retrying sendSession..."), yield this.connectionManager.sendSubscribe(f), yield this.connectionManager.sendRaw(JSON.stringify(Object.assign(Object.assign({}, v), {
                  requestId: h
                })));
              }), t.OKXCONNECTOR_MESSAGE_TTL));
            });
          }
          stopSendSessionRetry() {
            this.sessionRetryTimer && (clearInterval(this.sessionRetryTimer), this.sessionRetryTimer = null, (0, r.logDebug)("[Connect] Stopped retry for session"));
          }
          addConnectionListener() {
            var u;
            (u = this.connectionManager) === null || u === void 0 || u.addListener("sdk_response", (f, d) => {
              var p = (0, r.safeJsonParse)(d);
              (0, r.logDebug)(`Engine ==>> addListener ==> success ==> ${p}`), p.method === "connect" ? this.connectResultListener && this.connectResultListener(p) : p.method === "connect_error" ? this.connectManagerDisconnect(!1).catch(() => {}).finally(() => {
                this.connectResultListener && this.connectResultListener(p);
              }) : p.method === "session_connecting" && ((0, r.logDebug)("Engine ==>> handleResponse_4  ===> sessionConnectingListener"), this.sessionConnectingListener && ((0, r.logDebug)("Engine ==>> handleResponse_4  ===> sessionConnectingListener not null"), this.sessionConnectingListener(), this.sessionConnectingListener = void 0));
            }, function () {});
          }
        }
        return ns.Engine = o, ns;
      }
      var Em;
      function XA() {
        return Em || (Em = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.Storage = n.Engine = n.WalletConnectionManager = n.ConnectionManager = n.OKXWalletConnector = void 0;
          var e = Ad();
          Object.defineProperty(n, "OKXWalletConnector", {
            enumerable: !0,
            get: function () {
              return e.OKXWalletConnector;
            }
          });
          var t = vm();
          Object.defineProperty(n, "ConnectionManager", {
            enumerable: !0,
            get: function () {
              return t.ConnectionManager;
            }
          });
          var r = jA();
          Object.defineProperty(n, "WalletConnectionManager", {
            enumerable: !0,
            get: function () {
              return r.WalletConnectionManager;
            }
          });
          var i = WA();
          Object.defineProperty(n, "Engine", {
            enumerable: !0,
            get: function () {
              return i.Engine;
            }
          });
          var a = wf();
          Object.defineProperty(n, "Storage", {
            enumerable: !0,
            get: function () {
              return a.Storage;
            }
          });
        }(ed)), ed;
      }
      var rs = {},
        Mn = {},
        Cm;
      function is() {
        if (Cm) return Mn;
        Cm = 1, Object.defineProperty(Mn, "__esModule", {
          value: !0
        }), Mn.BtcMethods = Mn.SuiMethods = Mn.TONMethods = Mn.AptosMethods = Mn.SOLANAMethods = Mn.Eip55Methods = void 0, Mn.hasOKXInjectedProvider = n;
        function n() {
          return typeof e("okxwallet") != "undefined";
        }
        function e(t) {
          const r = (i, a) => {
            const [l, ...s] = a.split("."),
              o = i[l];
            if (o) return s.length === 0 ? o : r(o, s.join("."));
          };
          if (typeof window != "undefined") return r(window, t);
        }
        return Mn.Eip55Methods = ["personal_sign", "eth_signTypedData_v4", "eth_sendTransaction", "wallet_addEthereumChain", "wallet_watchAsset", "wallet_switchEthereumChain", "eth_requestAccounts", "eth_accounts", "eth_chainId"], Mn.SOLANAMethods = ["solana_signTransaction", "solana_signMessage", "solana_signAllTransactions", "solana_signAndSendTransaction"], Mn.AptosMethods = ["aptos_signMessage", "aptos_signTransaction", "aptos_signAndSubmitTransaction"], Mn.TONMethods = ["ton_sendTransaction"], Mn.SuiMethods = ["sui_signMessage", "sui_signPersonalMessage", "sui_signTransactionBlock", "sui_signAndExecuteTransactionBlock"], Mn.BtcMethods = ["btc_signMessage", "btc_signPsbts", "btc_send", "btc_sendInscription", "btc_signAndPushPsbt", "btc_inscribeTransfer", "btc_sendRunes"], Mn;
      }
      var os = {},
        ss = {},
        Dd = {},
        Om;
      function pi() {
        return Om || (Om = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.mediaNotTouch = n.mediaTouch = n.maxWidth = void 0, n.isDevice = a, n.media = l, n.mediaMin = s, n.mediaMax = o, n.mediaMinMax = c;
          const e = xd(),
            t = Iu(),
            r = ll(),
            i = yn();
          n.maxWidth = {
            mobile: 440,
            tablet: 1020
          };
          function a(u) {
            var f;
            const d = (0, r.getWindow)();
            if (!d) return u === "desktop";
            if ((0, t.isTmaPlatform)("weba")) return !0;
            const p = d.innerWidth;
            switch (u) {
              case "desktop":
                return p > n.maxWidth.tablet;
              case "tablet":
                return p > n.maxWidth.mobile;
              default:
              case "mobile":
                let v = p <= n.maxWidth.mobile || (0, e.isOS)("ios", "android", "ipad");
                if (v) {
                  const h = !!(!((f = (0, r.getWindow)()) === null || f === void 0) && f.TelegramWebviewProxy),
                    g = navigator.maxTouchPoints || 0;
                  h && g === 0 && (v = !1), (0, i.logDebug)("isDevice mobile isTelegram and maxTouchPoints:", v, h, g);
                }
                return v;
            }
          }
          function l(u) {
            switch (u) {
              case "mobile":
                return `@media (max-width: ${n.maxWidth.mobile}px)`;
              case "tablet":
                return `@media (max-width: ${n.maxWidth.tablet}px) (min-width: ${n.maxWidth.mobile}px)`;
              default:
              case "desktop":
                return `@media (min-width: ${n.maxWidth.tablet}px)`;
            }
          }
          function s(u) {
            return `@media (min-width: ${u}px)`;
          }
          function o(u) {
            return `@media (max-width: ${u}px)`;
          }
          function c(u, f) {
            return `@media (min-width: ${u}px) and (max-width: ${f}px)`;
          }
          n.mediaTouch = "@media (hover: none)", n.mediaNotTouch = "@media not all and (hover: none)";
        }(Dd)), Dd;
      }
      var Am;
      function qA() {
        if (Am) return ss;
        Am = 1;
        var n = ss && ss.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(ss, "__esModule", {
          value: !0
        }), ss.Eip155Provider = void 0;
        const e = Jt(),
          t = tn(),
          r = pi(),
          i = is();
        class a {
          constructor() {
            this.accountChangedEVMHandler = null;
          }
          send(s) {
            return n(this, void 0, void 0, function* () {
              var o;
              try {
                (0, t.logDebug)("Eip155Provider send request:", (0, t.safeJsonStringify)(s)), yield this.restoreConnect();
                let c = null;
                switch (s.method) {
                  case "personal_sign":
                    s.params && "message" in s.params && (c = {
                      method: s.method,
                      params: [s.params.message, s.address]
                    });
                    break;
                  case "eth_sendTransaction":
                  case "wallet_addEthereumChain":
                  case "wallet_switchEthereumChain":
                    s.params && (c = {
                      method: s.method,
                      params: [s.params]
                    });
                    break;
                  case "eth_signTypedData_v4":
                    s.params && "typedDataJson" in s.params && !((o = s.params) === null || o === void 0) && o.typedDataJson && typeof s.params.typedDataJson == "string" && (c = {
                      method: s.method,
                      params: [s.address, s.params.typedDataJson]
                    });
                    break;
                  case "wallet_watchAsset":
                    s.params && (c = {
                      method: s.method,
                      params: s.params
                    });
                    break;
                  default:
                    c = {
                      method: s.method,
                      params: s.injectParams
                    };
                }
                if (c) {
                  if ((s.method === "wallet_switchEthereumChain" || s.method === "wallet_addEthereumChain") && s.params && "chainId" in s.params) {
                    (0, t.logDebug)("Eip155Provider send request switch requestParams:", (0, t.safeJsonStringify)(c));
                    const u = parseInt(s.params.chainId, 16).toString();
                    yield window.okxwallet.request(c);
                    const f = `eip155:${u}:${s.address}`;
                    return (0, t.logDebug)("Eip155Provider send request switch result:", f), {
                      result: f,
                      method: s.method
                    };
                  } else {
                    const u = (0, t.getChainId)(s.chainId),
                      f = `0x${Number(u).toString(16)}`;
                    if ((0, t.logDebug)("Eip155Provider current chainId:", u, f), f) {
                      yield window.okxwallet.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                          chainId: f
                        }]
                      }), (0, t.logDebug)("Eip155Provider send request requestParams:", f, (0, t.safeJsonStringify)(c));
                      const d = yield window.okxwallet.request(c);
                      return (0, t.logDebug)("Eip155Provider send request result:", (0, t.safeJsonStringify)(d)), {
                        result: d,
                        method: s.method
                      };
                    }
                  }
                } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
              } catch (c) {
                throw (0, t.logDebug)("Eip155Provider encountered an error:", c), c;
              }
            });
          }
          restoreConnect() {
            return (0, r.isDevice)("mobile") ? window.okxwallet.request({
              method: "eth_requestAccounts"
            }) : Promise.resolve();
          }
          parseConnectResponse(s, o, c, u, f, d) {
            return n(this, void 0, void 0, function* () {
              try {
                let p = [];
                u.forEach(g => {
                  g.namespace === e.NameSpaceKeyEip155 && p.push(...g.chains);
                });
                let v = [],
                  h = {};
                return p.forEach(g => {
                  let b = (0, t.getChainId)(g),
                    m = f.address.find(_ => _.chainId === b && _.coinType === 60 || _.namespaceChainId === g);
                  m && (v.push(g + ":" + m.address), h[g] = {
                    publicKey: m.publicKey
                  });
                }), v && v.length > 0 ? {
                  namespace: e.NameSpaceKeyEip155,
                  addresses: v,
                  methods: [...i.Eip55Methods],
                  extra: h
                } : void 0;
              } catch (p) {
                throw p;
              }
            });
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              return window.okxwallet.request({
                method: "eth_requestAccounts"
              });
            });
          }
          singleConnect() {
            return this.connect();
          }
          addAccountChangedListener(s) {
            console.log("window.okxwallet configEventWithKey: eip155"), this.accountChangedEVMHandler = o => {
              console.log("window.okxwallet configEventWithKey_evm:", Date.now(), "eip155", o), o && o.length > 0 && s();
            }, window.okxwallet.on("accountsChanged", this.accountChangedEVMHandler);
          }
          removeListener() {
            this.accountChangedEVMHandler && window.okxwallet.removeListener("accountsChanged", this.accountChangedEVMHandler);
          }
        }
        return ss.Eip155Provider = a, ss;
      }
      var Rm;
      function JA() {
        return Rm || (Rm = 1, function (n) {
          var e = os && os.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = os && os.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(qA(), n);
        }(os)), os;
      }
      var as = {},
        Pd = {},
        Nm;
      function GA() {
        return Nm || (Nm = 1, Object.defineProperty(Pd, "__esModule", {
          value: !0
        })), Pd;
      }
      var Id = {},
        Sm;
      function VA() {
        return Sm || (Sm = 1, Object.defineProperty(Id, "__esModule", {
          value: !0
        })), Id;
      }
      var Tm;
      function zA() {
        return Tm || (Tm = 1, function (n) {
          var e = as && as.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = as && as.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(GA(), n), t(VA(), n);
        }(as)), as;
      }
      var cs = {},
        ls = {},
        Dm;
      function $A() {
        if (Dm) return ls;
        Dm = 1;
        var n = ls && ls.__awaiter || function (a, l, s, o) {
          function c(u) {
            return u instanceof s ? u : new s(function (f) {
              f(u);
            });
          }
          return new (s || (s = Promise))(function (u, f) {
            function d(h) {
              try {
                v(o.next(h));
              } catch (g) {
                f(g);
              }
            }
            function p(h) {
              try {
                v(o.throw(h));
              } catch (g) {
                f(g);
              }
            }
            function v(h) {
              h.done ? u(h.value) : c(h.value).then(d, p);
            }
            v((o = o.apply(a, l || [])).next());
          });
        };
        Object.defineProperty(ls, "__esModule", {
          value: !0
        }), ls.SuiStandardProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = pi();
        class i {
          constructor(l) {
            this.wallet = l;
          }
          getVersion() {
            return this.wallet.version;
          }
          supportChains(l) {
            return l.length === 1 && l[0] === e.SUI_CHAINS.MAINNET;
          }
          send(l) {
            return n(this, void 0, void 0, function* () {
              try {
                (0, t.logDebug)("suiProvider send request:", JSON.stringify(l));
                const s = l.method;
                let o;
                if (l.injectParams && this.wallet) {
                  let c = l.injectParams;
                  switch (s) {
                    case "sui_signTransactionBlock":
                      let u;
                      if (this.wallet.features["sui:signTransaction"]) u = yield this.wallet.features["sui:signTransaction"].signTransaction(c);else if (this.wallet.features["sui:signTransactionBlock"]) u = yield this.wallet.features["sui:signTransactionBlock"].signTransactionBlock(c);else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      o = {
                        method: "sui_signTransactionBlock",
                        result: u == null ? void 0 : u.signature
                      };
                      break;
                    case "sui_signAndExecuteTransactionBlock":
                      let f;
                      if (this.wallet.features["sui:signAndExecuteTransaction"]) f = yield this.wallet.features["sui:signAndExecuteTransaction"].signAndExecuteTransaction(c);else if (this.wallet.features["sui:signAndExecuteTransactionBlock"]) f = yield this.wallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(c);else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      o = {
                        method: "sui_signAndExecuteTransactionBlock",
                        result: f.digest
                      };
                      break;
                    case "sui_signMessage":
                      o = {
                        method: "sui_signMessage",
                        result: (yield this.wallet.features["sui:signMessage"].signMessage(c)).signature
                      };
                      break;
                    case "sui_signPersonalMessage":
                      o = {
                        method: "sui_signPersonalMessage",
                        result: (yield this.wallet.features["sui:signPersonalMessage"].signPersonalMessage(c)).signature
                      };
                      break;
                  }
                }
                return o;
              } catch (s) {
                throw (0, t.logDebug)("suiProvider send error:", s), s;
              }
            });
          }
          addAccountChangedListener() {}
          removeListener() {}
          disconnect() {
            return n(this, void 0, void 0, function* () {});
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              return this.wallet.features["standard:connect"].connect();
            });
          }
          restoreConnect() {
            return (0, r.isDevice)("mobile") ? this.connect() : Promise.resolve();
          }
          getAccount() {
            return n(this, void 0, void 0, function* () {
              var l, s;
              let o = yield this.connect();
              if (!o) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
              l = o == null ? void 0 : o.address;
              let c = (s = o == null ? void 0 : o.publicKey) !== null && s !== void 0 ? s : "";
              c instanceof Uint8Array && (c = this.normalizeUint8Array(c), c = btoa(String.fromCharCode(...c)));
              let u = {};
              return u[e.SUI_CHAINS.MAINNET] = {
                publicKey: c
              }, {
                namespace: e.NameSpaceKeySui,
                addresses: [`${e.SUI_CHAINS.MAINNET}:${o.address}`],
                methods: o.features,
                extra: u
              };
            });
          }
          normalizeUint8Array(l) {
            return l.length === 33 && l[0] === 0 ? l.slice(1) : l;
          }
        }
        return ls.SuiStandardProvider = i, ls;
      }
      var us = {},
        fs = {},
        Ji = {},
        Pm;
      function Im() {
        if (Pm) return Ji;
        Pm = 1, Object.defineProperty(Ji, "__esModule", {
          value: !0
        }), Ji.AptosNetwork = Ji.UserResponseStatus = void 0, Ji.getArgs = t;
        const n = Jt();
        var e;
        (function (i) {
          i.APPROVED = "Approved", i.REJECTED = "Rejected";
        })(e || (Ji.UserResponseStatus = e = {}));
        function t(i) {
          if (typeof i == "object" && i !== null && "status" in i) {
            if (i.status === e.REJECTED) throw new n.OKXConnectError(n.OKX_CONNECT_ERROR_CODES.USER_REJECTS_ERROR);
            return i.args;
          }
          return i;
        }
        var r;
        return function (i) {
          i.MAINNET = "mainnet", i.TESTNET = "testnet", i.DEVNET = "devnet";
        }(r || (Ji.AptosNetwork = r = {})), Ji;
      }
      var Bm;
      function QA() {
        if (Bm) return fs;
        Bm = 1;
        var n = fs && fs.__awaiter || function (a, l, s, o) {
          function c(u) {
            return u instanceof s ? u : new s(function (f) {
              f(u);
            });
          }
          return new (s || (s = Promise))(function (u, f) {
            function d(h) {
              try {
                v(o.next(h));
              } catch (g) {
                f(g);
              }
            }
            function p(h) {
              try {
                v(o.throw(h));
              } catch (g) {
                f(g);
              }
            }
            function v(h) {
              h.done ? u(h.value) : c(h.value).then(d, p);
            }
            v((o = o.apply(a, l || [])).next());
          });
        };
        Object.defineProperty(fs, "__esModule", {
          value: !0
        }), fs.AptosStandardProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = Im();
        class i {
          constructor(l) {
            this.wallet = l, this.mainNetWorkInfo = {
              chainId: "1",
              name: r.AptosNetwork.MAINNET
            };
          }
          getVersion() {
            return this.wallet.version;
          }
          supportChains(l) {
            return l.length === 1 && l[0] === e.APTOS_CHAINS.MAINNET;
          }
          send(l) {
            return n(this, void 0, void 0, function* () {
              var s, o, c, u, f;
              try {
                try {
                  (0, t.logDebug)("AptosStandardProvider send request:", JSON.stringify(l));
                } catch {}
                yield this.confirmNetwrok(l.chainId);
                const d = l.method;
                let p;
                if (l.injectParams && this.wallet) {
                  let v = l.injectParams;
                  switch (d) {
                    case "aptos_signTransaction":
                      let h;
                      if (this.wallet.features["aptos:signTransaction"]) {
                        if ("rawTransaction" in v) {
                          const m = yield this.wallet.features["aptos:signTransaction"].signTransaction(v);
                          h = (0, r.getArgs)(p);
                        } else if (this.wallet.features["aptos:signTransaction"].version === "1.1") {
                          const m = v,
                            _ = {
                              payload: m.data,
                              expirationTimestamp: (s = m.options) === null || s === void 0 ? void 0 : s.expirationTimestamp,
                              expirationSecondsFromNow: (o = m.options) === null || o === void 0 ? void 0 : o.expirationSecondsFromNow,
                              gasUnitPrice: (c = m == null ? void 0 : m.options) === null || c === void 0 ? void 0 : c.gasUnitPrice,
                              maxGasAmount: (u = m == null ? void 0 : m.options) === null || u === void 0 ? void 0 : u.maxGasAmount,
                              sequenceNumber: (f = m == null ? void 0 : m.options) === null || f === void 0 ? void 0 : f.accountSequenceNumber,
                              sender: m.sender
                            },
                            N = yield this.wallet.features["aptos:signTransaction"].signTransaction(_);
                          h = (0, r.getArgs)(p);
                        } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      p = {
                        method: "aptos_signTransaction",
                        injectResult: h
                      };
                      break;
                    case "aptos_signMessage":
                      let g;
                      if (this.wallet.features["aptos:signMessage"]) {
                        let m = yield this.wallet.features["aptos:signMessage"].signMessage(v);
                        g = (0, r.getArgs)(m);
                      } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      p = {
                        method: "aptos_signMessage",
                        injectResult: g
                      };
                      break;
                    case "aptos_signAndSubmitTransaction":
                      let b;
                      if (this.wallet.features["aptos:signAndSubmitTransaction"]) {
                        if (this.wallet.features["aptos:signAndSubmitTransaction"].version == "1.0.0") {
                          if ("standardV1Transaction" in v) {
                            let m = yield this.wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction(v.standardV1Transaction);
                            b = (0, r.getArgs)(m);
                          }
                        } else if (this.wallet.features["aptos:signAndSubmitTransaction"].version == "1.1.0") {
                          if ("standardV11Transaction" in v) {
                            let m = l.params,
                              _ = yield this.wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction(v.standardV11Transaction);
                            b = (0, r.getArgs)(_);
                          }
                        } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      p = {
                        method: "aptos_signAndSubmitTransaction",
                        result: b.hash.toString()
                      };
                      break;
                  }
                }
                return p;
              } catch (d) {
                throw (0, t.logDebug)("aptosProvider send error:", d), d;
              }
            });
          }
          removeListener() {
            this.wallet.features["aptos:onAccountChange"] && this.wallet.features["aptos:onAccountChange"].onAccountChange(l => {});
          }
          addAccountChangedListener(l) {
            this.accountChangedListener = l;
          }
          setAccountChangedListener() {
            if (this.wallet.features["aptos:onAccountChange"] && this.accountChangedListener) try {
              this.wallet.features["aptos:onAccountChange"].onAccountChange(l => {
                var s, o;
                try {
                  this.accountChangedListener((o = (s = (0, r.getArgs)(l)) === null || s === void 0 ? void 0 : s.address) === null || o === void 0 ? void 0 : o.toString());
                } catch {
                  this.accountChangedListener(void 0);
                }
              });
            } catch (l) {
              (0, t.logDebug)(`aptosStandardProvider addAccountChangedListener: error ${l.toString()}`);
            }
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              return this.wallet.features["aptos:connect"].connect();
            });
          }
          getAccount() {
            return n(this, void 0, void 0, function* () {
              let l = (0, r.getArgs)(yield this.connect()),
                s = l.address;
              typeof s == "object" && s.toString && (s = s.toString()), s instanceof Uint8Array && (s = this.normalizeUint8Array(s), s = btoa(String.fromCharCode(...s)));
              let o = l.publicKey.toString();
              this.setAccountChangedListener();
              let c = {};
              return c[e.APTOS_CHAINS.MAINNET] = {
                publicKey: o
              }, {
                namespace: e.NameSpaceKeyAptos,
                addresses: [`${e.APTOS_CHAINS.MAINNET}:${s}`],
                methods: [],
                extra: c
              };
            });
          }
          normalizeUint8Array(l) {
            return l.length === 33 && l[0] === 0 ? l.slice(1) : l;
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              if (this.wallet.features["aptos:disconnect"]) return this.wallet.features["aptos:disconnect"].disconnect();
            });
          }
          confirmNetwrok(l) {
            return n(this, void 0, void 0, function* () {
              if (l !== t.chainName2IdMap.get(e.APTOS_CHAINS.MAINNET)) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
              if (this.wallet.features["aptos:network"]) {
                let s = yield this.wallet.features["aptos:network"].network();
                if (s.chainId == 1 && s.name.toLowerCase() == r.AptosNetwork.MAINNET) return Promise.resolve();
                yield this.changeMainNetwork();
              } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
            });
          }
          changeMainNetwork() {
            return n(this, void 0, void 0, function* () {
              if (this.wallet.features["aptos:changeNetwork"]) {
                let l = yield this.wallet.features["aptos:changeNetwork"].changeNetwork(this.mainNetWorkInfo);
                if ((0, r.getArgs)(l).success) return Promise.resolve();
              } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
            });
          }
        }
        return fs.AptosStandardProvider = i, fs;
      }
      var ds = {},
        hs = {},
        hl = {},
        km;
      function Bd() {
        if (km) return hl;
        km = 1, Object.defineProperty(hl, "__esModule", {
          value: !0
        }), hl.WalletReadyState = void 0;
        var n;
        return function (e) {
          e.Installed = "Installed", e.NotDetected = "NotDetected", e.Loadable = "Loadable", e.Unsupported = "Unsupported";
        }(n || (hl.WalletReadyState = n = {})), hl;
      }
      var ps = {},
        pl = {},
        Mm;
      function Km() {
        if (Mm) return pl;
        Mm = 1, Object.defineProperty(pl, "__esModule", {
          value: !0
        }), pl.BaseAptosWalletAdapter = void 0;
        const n = Wi();
        class e extends n.EventEmitter {
          get connected() {
            return !!this.publicAccount.publicKey;
          }
        }
        return pl.BaseAptosWalletAdapter = e, pl;
      }
      var Lm;
      function YA() {
        if (Lm) return ps;
        Lm = 1;
        var n = ps && ps.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(ps, "__esModule", {
          value: !0
        }), ps.MartainWalletAdapter = void 0;
        const e = Km(),
          t = Bd(),
          r = Jt(),
          i = vr(),
          a = tn();
        class l extends e.BaseAptosWalletAdapter {
          get readyState() {
            throw new Error("Method not implemented.");
          }
          constructor() {
            super(), this.name = "Martian", this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/martian.png", this.url = "", this._version = "unknown", this._readyState = typeof window == "undefined" || typeof document == "undefined" ? t.WalletReadyState.Unsupported : t.WalletReadyState.NotDetected, this._provider = typeof window != "undefined" ? window.martian : void 0, this._network = void 0, this._connecting = !1, this._wallet = null, typeof window != "undefined" && this._readyState !== t.WalletReadyState.Unsupported && (0, i.scopePollingDetectionStrategy)(() => window.martian ? (this._readyState = t.WalletReadyState.Installed, this.emit("readyStateChange", this._readyState), !0) : !1);
          }
          get publicAccount() {
            var o, c, u;
            return {
              publicKey: ((o = this._wallet) === null || o === void 0 ? void 0 : o.publicKey) || null,
              address: ((c = this._wallet) === null || c === void 0 ? void 0 : c.address) || null,
              authKey: ((u = this._wallet) === null || u === void 0 ? void 0 : u.authKey) || null
            };
          }
          get connecting() {
            return this._connecting;
          }
          get version() {
            return this._version;
          }
          get network() {
            return {
              name: this._network,
              chainId: this._chainId
            };
          }
          onAccountChange(o) {
            return n(this, void 0, void 0, function* () {
              try {
                const c = this._wallet,
                  u = this._provider || window.martian;
                if (!c || !u) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const f = d => n(this, void 0, void 0, function* () {
                  const {
                    publicKey: p
                  } = yield u == null ? void 0 : u.account();
                  this._wallet = Object.assign(Object.assign({}, this._wallet), {
                    address: d,
                    publicKey: p
                  });
                });
                yield u == null ? void 0 : u.onAccountChange(f);
              } catch (c) {
                throw c.message, c;
              }
              (0, a.logDebug)("MartainWalletAdapter.onAccountChange()");
            });
          }
          onNetworkChange() {
            return n(this, void 0, void 0, function* () {
              (0, a.logDebug)("MartainWalletAdapter.onNetworkChange()");
            });
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              try {
                if (!(this._readyState === t.WalletReadyState.Loadable || this._readyState === t.WalletReadyState.Installed)) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                if (this.connecting) return;
                if (this.connected) {
                  yield this.initNetWork();
                  return;
                }
                this._connecting = !0;
                const o = this._provider || window.martian;
                if ((yield o == null ? void 0 : o.isConnected()) && (yield o == null ? void 0 : o.disconnect()), !(yield o == null ? void 0 : o.connect())) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
                yield this.initNetWork();
              } catch (o) {
                throw o;
              } finally {
                this._connecting = !1;
              }
            });
          }
          initNetWork() {
            return n(this, void 0, void 0, function* () {
              const o = this._provider || window.martian,
                c = yield o == null ? void 0 : o.account();
              if (c) {
                this._wallet = Object.assign(Object.assign({}, c), {
                  isConnected: !0
                });
                const u = yield o == null ? void 0 : o.network(),
                  {
                    chainId: f
                  } = yield o.getChainId();
                this._network = u, this._chainId = f.toString();
              }
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              const o = this._wallet,
                c = this._provider || window.martian;
              if (o) {
                this._wallet = null;
                try {
                  yield c == null ? void 0 : c.disconnect();
                } catch {}
              }
            });
          }
          signAndSubmitTransaction(o, c) {
            return n(this, void 0, void 0, function* () {
              try {
                const u = this._wallet,
                  f = this._provider || window.martian;
                if (!u || !f) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const d = yield f.generateTransaction(u.address || "", o, c);
                if (!d) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "generate transaction error");
                const p = yield f == null ? void 0 : f.signAndSubmitTransaction(d);
                if (!p) throw new Error("No response");
                return {
                  hash: p
                };
              } catch (u) {
                throw u;
              }
            });
          }
          signTransaction(o, c) {
            return n(this, void 0, void 0, function* () {
              try {
                const u = this._wallet,
                  f = this._provider || window.martian;
                if (!u || !f) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const d = yield f.generateTransaction(u.address || "", o, c);
                if (!d) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "generate transaction error");
                const p = yield f == null ? void 0 : f.signTransaction(d);
                if (!p) throw new Error("No response");
                return p;
              } catch (u) {
                throw u;
              }
            });
          }
          signMessage(o) {
            return n(this, void 0, void 0, function* () {
              try {
                const c = this._wallet,
                  u = this._provider || window.martian;
                if (!c || !u) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                if (typeof o != "object" || !o.nonce) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "Invalid signMessage Payload");
                const f = yield u == null ? void 0 : u.signMessage(o);
                if (f) return f;
                throw new Error("Sign Message failed");
              } catch (c) {
                throw c;
              }
            });
          }
        }
        return ps.MartainWalletAdapter = l, ps;
      }
      var gs = {},
        Um;
      function ZA() {
        if (Um) return gs;
        Um = 1;
        var n = gs && gs.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(gs, "__esModule", {
          value: !0
        }), gs.PetraWalletAdapter = void 0;
        const e = Km(),
          t = Bd(),
          r = vr(),
          i = Jt();
        class a extends e.BaseAptosWalletAdapter {
          get readyState() {
            return this._readyState;
          }
          getPerta() {
            var s;
            if (this._provider) return this._provider;
            if (!window.petra) return;
            let o = window.petra;
            if (!(o && (o.isOKExWallet || o.isOkxWallet || ((s = window.okxwallet) === null || s === void 0 ? void 0 : s.aptos) === o))) return this._provider = o, o;
          }
          constructor() {
            super(), this.name = "Petra", this.icon = "https://raw.githubusercontent.com/hippospace/aptos-wallet-adapter/main/logos/petra.png", this.url = "", this._version = "unknown", this._readyState = typeof window == "undefined" || typeof document == "undefined" ? t.WalletReadyState.Unsupported : t.WalletReadyState.NotDetected, this._network = void 0, this._connecting = !1, this._wallet = null, typeof window != "undefined" && this._readyState !== t.WalletReadyState.Unsupported && (0, r.scopePollingDetectionStrategy)(() => this.getPerta() ? (this._readyState = t.WalletReadyState.Installed, !0) : !1);
          }
          get publicAccount() {
            var s, o, c;
            return {
              publicKey: ((s = this._wallet) === null || s === void 0 ? void 0 : s.publicKey) || null,
              address: ((o = this._wallet) === null || o === void 0 ? void 0 : o.address) || null,
              authKey: ((c = this._wallet) === null || c === void 0 ? void 0 : c.authKey) || null
            };
          }
          get connecting() {
            return this._connecting;
          }
          get version() {
            return this._version;
          }
          get network() {
            return {
              name: this._network
            };
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              try {
                if (!(this._readyState === t.WalletReadyState.Loadable || this._readyState === t.WalletReadyState.Installed)) throw new i.OKXConnectError(i.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                if (this.connected) {
                  yield this.initNetWork();
                  return;
                }
                this._connecting = !0;
                const s = this.getPerta(),
                  o = yield s == null ? void 0 : s.connect();
                this._wallet = {
                  address: o == null ? void 0 : o.address,
                  publicKey: o == null ? void 0 : o.publicKey,
                  isConnected: !0
                }, yield this.initNetWork();
              } catch (s) {
                throw s;
              } finally {
                this._connecting = !1;
              }
            });
          }
          initNetWork() {
            return n(this, void 0, void 0, function* () {
              const s = this.getPerta(),
                o = yield s == null ? void 0 : s.network();
              this._network = o;
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              const s = this._wallet,
                o = this.getPerta();
              if (s) {
                this._wallet = null;
                try {
                  yield o == null ? void 0 : o.disconnect();
                } catch {}
              }
            });
          }
          signAndSubmitTransaction(s, o) {
            return n(this, void 0, void 0, function* () {
              try {
                const c = this._wallet,
                  u = this.getPerta();
                if (!c || !u) throw new i.OKXConnectError(i.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const f = yield u.signAndSubmitTransaction(s, o);
                if (f.code) throw new Error(f.message);
                return f;
              } catch (c) {
                throw c;
              }
            });
          }
          signTransaction(s, o) {
            return n(this, void 0, void 0, function* () {
              try {
                const c = this._wallet,
                  u = this.getPerta();
                if (!c || !u) throw new i.OKXConnectError(i.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const f = yield u == null ? void 0 : u.signTransaction(s);
                if (f.code) throw new Error(f.message);
                return f;
              } catch (c) {
                throw c;
              }
            });
          }
          signMessage(s) {
            return n(this, void 0, void 0, function* () {
              try {
                const o = this._wallet,
                  c = this.getPerta();
                if (!o || !c) throw new i.OKXConnectError(i.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                const u = yield c == null ? void 0 : c.signMessage(s);
                if (u) return u;
                throw new Error("Sign Message failed");
              } catch (o) {
                throw o;
              }
            });
          }
          onAccountChange(s) {
            return n(this, void 0, void 0, function* () {
              try {
                const o = this._wallet,
                  c = this.getPerta(),
                  u = f => n(this, void 0, void 0, function* () {
                    var d, p, v, h, g, b;
                    if (f != null && f.publicKey) this._wallet = Object.assign(Object.assign({}, this._wallet), {
                      publicKey: f.publicKey || ((d = this._wallet) === null || d === void 0 ? void 0 : d.publicKey),
                      authKey: f.authKey || ((p = this._wallet) === null || p === void 0 ? void 0 : p.authKey),
                      address: f.address || ((v = this._wallet) === null || v === void 0 ? void 0 : v.address)
                    });else {
                      const m = yield c == null ? void 0 : c.connect();
                      this._wallet = Object.assign(Object.assign({}, this._wallet), {
                        authKey: (m == null ? void 0 : m.authKey) || ((h = this._wallet) === null || h === void 0 ? void 0 : h.authKey),
                        address: (m == null ? void 0 : m.address) || ((g = this._wallet) === null || g === void 0 ? void 0 : g.address),
                        publicKey: (m == null ? void 0 : m.publicKey) || ((b = this._wallet) === null || b === void 0 ? void 0 : b.publicKey)
                      });
                    }
                    s == null || s(this._wallet);
                  });
                c == null || c.onAccountChange(u);
              } catch (o) {
                throw o;
              }
            });
          }
          onNetworkChange() {
            return n(this, void 0, void 0, function* () {
              try {
                const s = this._wallet,
                  o = this.getPerta(),
                  c = u => n(this, void 0, void 0, function* () {
                    u && (this._network = u.networkName);
                  });
              } catch (s) {
                throw s;
              }
            });
          }
        }
        return gs.PetraWalletAdapter = a, gs;
      }
      var Fm;
      function Hm() {
        return Fm || (Fm = 1, function (n) {
          var e = hs && hs.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = hs && hs.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(Bd(), n), t(YA(), n), t(ZA(), n);
        }(hs)), hs;
      }
      var jm;
      function e2() {
        if (jm) return ds;
        jm = 1;
        var n = ds && ds.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(ds, "__esModule", {
          value: !0
        }), ds.AptosThirdpartInjectProvider = void 0;
        const e = Jt(),
          t = Hm(),
          r = tn(),
          i = Im();
        class a {
          constructor(s) {
            this.walletAdapter = s;
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              yield this.walletAdapter.disconnect();
            });
          }
          getVersion() {
            return this.walletAdapter.version;
          }
          getAccount() {
            return n(this, void 0, void 0, function* () {
              yield this.walletAdapter.connect();
              let s = this.walletAdapter.publicAccount,
                o = s.address,
                c = s.publicKey.toString(),
                u = {};
              return u[e.APTOS_CHAINS.MAINNET] = {
                publicKey: c
              }, {
                namespace: e.NameSpaceKeyAptos,
                addresses: [`${e.APTOS_CHAINS.MAINNET}:${o}`],
                methods: [],
                extra: u
              };
            });
          }
          supportChains(s) {
            return this.walletAdapter.readyState !== t.WalletReadyState.Installed ? !1 : s.length === 1 && s[0] === e.APTOS_CHAINS.MAINNET;
          }
          send(s) {
            return n(this, void 0, void 0, function* () {
              try {
                try {
                  (0, r.logDebug)("AptosStandardProvider send request:", JSON.stringify(s));
                } catch {}
                this.confirmNetwrok(s.chainId);
                const o = s.method;
                let c;
                if (s.injectParams && this.walletAdapter) {
                  let u = s.injectParams;
                  switch (o) {
                    case "aptos_signTransaction":
                      c = {
                        method: "aptos_signTransaction",
                        result: yield this.walletAdapter.signTransaction(s.params)
                      };
                      break;
                    case "aptos_signMessage":
                      let d = yield this.walletAdapter.signMessage(u);
                      typeof d == "object" && "signature" in d && (d = d.signature), c = {
                        method: "aptos_signMessage",
                        result: d
                      };
                      break;
                    case "aptos_signAndSubmitTransaction":
                      c = {
                        method: "aptos_signAndSubmitTransaction",
                        result: (yield this.walletAdapter.signAndSubmitTransaction(s.params)).hash
                      };
                      break;
                  }
                }
                return c;
              } catch (o) {
                throw (0, r.logDebug)("aptosProvider send error:", o), o;
              }
            });
          }
          removeListener() {}
          addAccountChangedListener(s) {
            this.walletAdapter.onAccountChange(o => {
              s == null || s(o == null ? void 0 : o.address);
            });
          }
          confirmNetwrok(s) {
            var o;
            if (s !== r.chainName2IdMap.get(e.APTOS_CHAINS.MAINNET)) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
            if (((o = this.walletAdapter.network.name) === null || o === void 0 ? void 0 : o.toLowerCase()) != i.AptosNetwork.MAINNET) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
          }
        }
        return ds.AptosThirdpartInjectProvider = a, ds;
      }
      var Wm;
      function t2() {
        return Wm || (Wm = 1, function (n) {
          var e = us && us.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = us && us.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(QA(), n), t(e2(), n), t(Hm(), n);
        }(us)), us;
      }
      var Xm;
      function n2() {
        return Xm || (Xm = 1, function (n) {
          var e = cs && cs.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = cs && cs.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t($A(), n), t(t2(), n);
        }(cs)), cs;
      }
      var qm;
      function Jm() {
        return qm || (qm = 1, function (n) {
          var e = rs && rs.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = rs && rs.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(is(), n), t(JA(), n), t(zA(), n), t(n2(), n);
        }(rs)), rs;
      }
      var vs = {},
        gl = {},
        ys = {},
        Gm;
      function kd() {
        if (Gm) return ys;
        Gm = 1;
        var n = ys && ys.__awaiter || function (i, a, l, s) {
          function o(c) {
            return c instanceof l ? c : new l(function (u) {
              u(c);
            });
          }
          return new (l || (l = Promise))(function (c, u) {
            function f(v) {
              try {
                p(s.next(v));
              } catch (h) {
                u(h);
              }
            }
            function d(v) {
              try {
                p(s.throw(v));
              } catch (h) {
                u(h);
              }
            }
            function p(v) {
              v.done ? c(v.value) : o(v.value).then(f, d);
            }
            p((s = s.apply(i, a || [])).next());
          });
        };
        Object.defineProperty(ys, "__esModule", {
          value: !0
        }), ys.WsConnector = void 0;
        const e = $o(),
          t = yn();
        class r {
          constructor() {
            this.disconnectListener = [], this.walletName = "", this.walletNameKey = "", this.enable = !0, this.icon = "", this.pendingRequests = new Map(), (0, t.getDefaultReporter)().beginReport();
          }
          setAccountChangeListener(a) {
            this.accountChangeListener = a;
          }
          setConnectionManager(a) {
            this.connectionManager = a;
          }
          addConnectionListener() {
            var a;
            (a = this.connectionManager) === null || a === void 0 || a.addListener("sdk_response", (l, s) => {
              var o = (0, e.safeJsonParse)(s);
              (0, t.logDebug)(`Engine ==>> addListener ==> success ==> ${o}`), this.handleResponse(l, o);
            }, function () {});
          }
          addDisconnectListener(a) {
            this.disconnectListener.push(a);
          }
          connectManagerDisconnect() {
            return n(this, arguments, void 0, function* (a = !1) {
              var l;
              yield (l = this.connectionManager) === null || l === void 0 ? void 0 : l.disconnect(a);
            });
          }
          openWallet(a, l) {}
          bindRequestForPromise(a, l) {
            this.pendingRequests.set(a, l);
          }
          send(a, l, s) {
            return n(this, void 0, void 0, function* () {
              var o, c;
              try {
                delete a.injectParams;
              } catch {}
              (0, t.logDebug)("Engine ==>> send  request==>", JSON.stringify(a));
              const u = this.getRequestId();
              try {
                let f = yield (o = this.connectionManager) === null || o === void 0 ? void 0 : o.send(JSON.stringify(Object.assign(Object.assign({}, a), {
                  requestId: u
                })), s);
                f && ((c = this.connectionManager) === null || c === void 0 || c.events.once(f.toString(), d => {
                  var p;
                  (0, t.logDebug)(`Engine ==> send => onAck => ${(0, e.safeJsonStringify)(d)}`), d && d.result && ((p = l.onAck) === null || p === void 0 || p.call(l));
                })), l.resolve && this.bindRequestForPromise(u, l.resolve);
              } catch (f) {
                return Promise.reject(f);
              }
            });
          }
          restoreconnect(a, l) {
            return n(this, void 0, void 0, function* () {
              var s;
              yield (s = this.connectionManager) === null || s === void 0 ? void 0 : s.restoreConnect(a.topic), l(a);
            });
          }
          restoreconnectFromTopic(a) {
            return n(this, void 0, void 0, function* () {
              var l;
              yield (l = this.connectionManager) === null || l === void 0 ? void 0 : l.restoreConnect(a);
            });
          }
          getRequestId() {
            const a = Date.now().toString();
            return (0, t.logDebug)("Engine ==>> getRequestId ==>", a), a;
          }
          handleResponse(a, l) {
            if ((0, t.logDebug)(`Engine ==>> handleResponse_1  ======>response: ${(0, e.safeJsonStringify)(l)}`, a), "requestId" in l) {
              (0, t.logDebug)("Engine ==>> handleResponse_2  ===> in response");
              let s = l.requestId;
              const o = this.pendingRequests.get(s);
              o ? ((0, t.logDebug)("Engine ==>> handleResponse_3  ===> find resolve:", o), o(l), this.pendingRequests.delete(s)) : ((0, t.logDebug)("Engine ==>> handleResponse_3  ===> not find resolve:"), l.method === "disconnect" && (this.disconnectListener.forEach(c => c()), this.disconnectListener = [], this.clearData()));
            }
          }
          getCurrentConnectionReady() {
            var a;
            return !!(!((a = this.connectionManager) === null || a === void 0) && a.getCurrentConnectionReady());
          }
          saveSessionContent(a, l) {
            var s;
            (s = this.connectionManager) === null || s === void 0 || s.saveSessionContent(a, l);
          }
          getSessionContent(a) {
            var l;
            return (l = this.connectionManager) === null || l === void 0 ? void 0 : l.getSessionContent(a);
          }
          setOnConnectResultListener(a) {
            this.connectResultListener = a;
          }
          getTag() {
            return "";
          }
          toJSON() {
            return "ws-connector";
          }
          clearData() {
            this.pendingRequests.clear();
          }
        }
        return ys.WsConnector = r, ys;
      }
      var Vm;
      function r2() {
        if (Vm) return gl;
        Vm = 1, Object.defineProperty(gl, "__esModule", {
          value: !0
        }), gl.AppwalletConnector = void 0;
        const n = kd(),
          e = qi(),
          t = tn(),
          r = vd(),
          i = Jt();
        class a extends n.WsConnector {
          getType() {
            return e.CONNECTOR_TYPE.WS.OKX_APP_WALLET;
          }
          constructor() {
            super(), this.walletName = "OKX App", this.walletNameKey = "";
          }
          getTag() {
            return e.OKX_APP_WALLET;
          }
          openWallet(s, o) {
            var c;
            let u = o != null ? o : i.OpenAppLinkType.UniversalLink;
            if (s && s.connectRequest) {
              (0, t.logDebug)(`appwallet-connector openwallet before useSHortLink engineConnectInfo.connectRequest JSON ${JSON.stringify(s)}`);
              let f = s.connectRequest;
              (0, t.useShortLink)() || (f = Object.assign(Object.assign({}, s.connectRequest), {
                redirect: (c = s.redirect) !== null && c !== void 0 ? c : "none"
              }));
              let {
                universalLink: d,
                deepLink: p
              } = (0, t.getOKXLink)(f);
              (0, t.openOKXDeeplinkWithFallback)(p, d, u);
            } else (0, t.isOS)("android") ? (0, t.openDeeplinkWithFallback)(r.stackDeepLink, () => {}) : (0, t.openOKXDeeplinkWithFallback)(r.standardDeeplink, r.shortUniversalLink, u);
          }
        }
        return gl.AppwalletConnector = a, gl;
      }
      var ms = {},
        zm;
      function Md() {
        if (zm) return ms;
        zm = 1;
        var n = ms && ms.__awaiter || function (a, l, s, o) {
          function c(u) {
            return u instanceof s ? u : new s(function (f) {
              f(u);
            });
          }
          return new (s || (s = Promise))(function (u, f) {
            function d(h) {
              try {
                v(o.next(h));
              } catch (g) {
                f(g);
              }
            }
            function p(h) {
              try {
                v(o.throw(h));
              } catch (g) {
                f(g);
              }
            }
            function v(h) {
              h.done ? u(h.value) : c(h.value).then(d, p);
            }
            v((o = o.apply(a, l || [])).next());
          });
        };
        Object.defineProperty(ms, "__esModule", {
          value: !0
        }), ms.InjectConnector = void 0;
        const e = Jt(),
          t = tn(),
          r = qi();
        let i = class {
          constructor() {
            this.disconnectListener = [], this.providerMap = new Map(), this.disconnectHandler = null, this.walletName = "", this.icon = "", this.walletNameKey = "", this.enable = !0;
          }
          setAccountChangeListener(l) {
            (0, t.logDebug)("setAccountChangeListener: inject", l), this.accountChangeListener = l;
          }
          setConnectionManager(l) {
            this.connectionManager = l;
          }
          getInjectProvider(l) {
            if (l) {
              for (const [s, o] of this.providerMap.entries()) if (l.includes(s)) return o;
            }
          }
          send(l, s) {
            return n(this, void 0, void 0, function* () {
              var o;
              try {
                (0, t.logDebug)("InjectEngine send  > request:", (0, t.safeJsonStringify)(l));
                let c = l;
                if (c.method === "disconnect") {
                  yield this.disconnect(), this.disconnectListener.forEach(f => f()), this.disconnectListener = [], (o = s.onAck) === null || o === void 0 || o.call(s);
                  return;
                }
                yield this.checkWalletMatch();
                const u = this.getInjectProvider((0, t.getNamespaceKeyByChain)(c.chainId));
                if (u) {
                  u.send(c).then(f => {
                    var d;
                    (0, t.logDebug)("InjectEngine ==>> send > result:", f), (d = s.resolve) === null || d === void 0 || d.call(s, f);
                  }).catch(f => {
                    var d;
                    let p = f.code;
                    p === 4001 && (p = e.OKX_CONNECT_ERROR_CODES.USER_REJECTS_ERROR);
                    let v = {
                      requestId: Date.now().toString(),
                      method: l.method,
                      error: {
                        code: p,
                        message: f.message
                      }
                    };
                    (0, t.logDebug)("InjectEngine ==>> send > errorResponse:", JSON.stringify(v)), (d = s.resolve) === null || d === void 0 || d.call(s, v);
                  });
                  return;
                } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
              } catch (c) {
                return (0, t.logDebug)("InjectEngine ==>> send  ===> error:", c), Promise.reject(c);
              }
            });
          }
          checkWalletMatch() {
            return n(this, void 0, void 0, function* () {
              return new Promise((l, s) => {
                var o;
                let c = (o = this.connectionManager) === null || o === void 0 ? void 0 : o.getSessionContent("connectSession");
                c || s(new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED)), this.restoreconnect(c, u => {
                  u ? l() : s(new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED));
                });
              });
            });
          }
          clearData() {
            this.connectResultListener = void 0;
          }
          addDisconnectListener(l) {
            this.disconnectListener.push(l);
          }
          setOnConnectResultListener(l) {
            this.connectResultListener = l;
          }
          connectManagerDisconnect() {
            return n(this, arguments, void 0, function* (l = !1) {});
          }
          getCurrentConnectionReady(l) {
            return !!l;
          }
          getTag() {
            return r.OKX_INJECT_WALLET;
          }
          toJSON() {
            return "inject-connector";
          }
          getSupportNameSpaces() {
            return Array.from(this.providerMap.keys());
          }
        };
        return ms.InjectConnector = i, ms;
      }
      var vl = {},
        $m;
      function i2() {
        if ($m) return vl;
        $m = 1, Object.defineProperty(vl, "__esModule", {
          value: !0
        }), vl.TgwalletConnector = void 0;
        const n = kd(),
          e = qi(),
          t = tn();
        class r extends n.WsConnector {
          getType() {
            return e.CONNECTOR_TYPE.WS.OKX_TG_WALLET;
          }
          constructor() {
            super(), this.walletName = "OKX Mini Wallet", this.walletNameKey = "";
          }
          getTag() {
            return e.OKX_TG_WALLET;
          }
          openWallet(a, l) {
            var s, o;
            a && a.connectRequest && (o = (0, t.encodeTWAConnectURLParams)(Object.assign(Object.assign({}, a.connectRequest), {
              redirect: "none"
            })));
            var c = (0, t.getTelegramWalletTWAUrl)(o, (s = a == null ? void 0 : a.tmaReturnUrl) !== null && s !== void 0 ? s : "back");
            (0, t.openOKXTMAWalletlinkWithFallback)(c);
          }
        }
        return vl.TgwalletConnector = r, vl;
      }
      var bs = {},
        gi = {},
        Kd,
        Qm;
      function o2() {
        if (Qm) return Kd;
        Qm = 1;
        function n(e) {
          if (e.length >= 255) throw new TypeError("Alphabet too long");
          for (var t = new Uint8Array(256), r = 0; r < t.length; r++) t[r] = 255;
          for (var i = 0; i < e.length; i++) {
            var a = e.charAt(i),
              l = a.charCodeAt(0);
            if (t[l] !== 255) throw new TypeError(a + " is ambiguous");
            t[l] = i;
          }
          var s = e.length,
            o = e.charAt(0),
            c = Math.log(s) / Math.log(256),
            u = Math.log(256) / Math.log(s);
          function f(v) {
            if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
            if (v.length === 0) return "";
            for (var h = 0, g = 0, b = 0, m = v.length; b !== m && v[b] === 0;) b++, h++;
            for (var _ = (m - b) * u + 1 >>> 0, N = new Uint8Array(_); b !== m;) {
              for (var O = v[b], y = 0, w = _ - 1; (O !== 0 || y < g) && w !== -1; w--, y++) O += 256 * N[w] >>> 0, N[w] = O % s >>> 0, O = O / s >>> 0;
              if (O !== 0) throw new Error("Non-zero carry");
              g = y, b++;
            }
            for (var A = _ - g; A !== _ && N[A] === 0;) A++;
            for (var R = o.repeat(h); A < _; ++A) R += e.charAt(N[A]);
            return R;
          }
          function d(v) {
            if (typeof v != "string") throw new TypeError("Expected String");
            if (v.length === 0) return new Uint8Array();
            for (var h = 0, g = 0, b = 0; v[h] === o;) g++, h++;
            for (var m = (v.length - h) * c + 1 >>> 0, _ = new Uint8Array(m); v[h];) {
              var N = v.charCodeAt(h);
              if (N > 255) return;
              var O = t[N];
              if (O === 255) return;
              for (var y = 0, w = m - 1; (O !== 0 || y < b) && w !== -1; w--, y++) O += s * _[w] >>> 0, _[w] = O % 256 >>> 0, O = O / 256 >>> 0;
              if (O !== 0) throw new Error("Non-zero carry");
              b = y, h++;
            }
            for (var A = m - b; A !== m && _[A] === 0;) A++;
            for (var R = new Uint8Array(g + (m - A)), T = g; A !== m;) R[T++] = _[A++];
            return R;
          }
          function p(v) {
            var h = d(v);
            if (h) return h;
            throw new Error("Non-base" + s + " character");
          }
          return {
            encode: f,
            decodeUnsafe: d,
            decode: p
          };
        }
        return Kd = n, Kd;
      }
      var Ld, Ym;
      function Zm() {
        return Ym || (Ym = 1, Ld = o2()("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")), Ld;
      }
      var eb;
      function s2() {
        if (eb) return gi;
        eb = 1;
        var n = gi && gi.__awaiter || function (o, c, u, f) {
            function d(p) {
              return p instanceof u ? p : new u(function (v) {
                v(p);
              });
            }
            return new (u || (u = Promise))(function (p, v) {
              function h(m) {
                try {
                  b(f.next(m));
                } catch (_) {
                  v(_);
                }
              }
              function g(m) {
                try {
                  b(f.throw(m));
                } catch (_) {
                  v(_);
                }
              }
              function b(m) {
                m.done ? p(m.value) : d(m.value).then(h, g);
              }
              b((f = f.apply(o, c || [])).next());
            });
          },
          e = gi && gi.__importDefault || function (o) {
            return o && o.__esModule ? o : {
              default: o
            };
          };
        Object.defineProperty(gi, "__esModule", {
          value: !0
        }), gi.SolProvider = void 0;
        const t = Jt(),
          r = tn(),
          i = e(Zm()),
          a = pi(),
          l = is();
        let s = class {
          constructor() {
            this.accountChangedSolanaPublicKeyHandler = null;
          }
          send(c) {
            return n(this, void 0, void 0, function* () {
              var u;
              try {
                yield this.restoreConnect(), (0, r.logDebug)("SolProvider send request:", JSON.stringify(c));
                const p = c.method;
                let v;
                if (c.injectParams) switch (p) {
                  case "solana_signMessage":
                    if (c.injectParams && typeof c.injectParams == "object" && "message" in c.injectParams) {
                      var f = (u = c.injectParams) === null || u === void 0 ? void 0 : u.message;
                      const h = new TextEncoder().encode(f),
                        g = yield window.okxwallet.solana.signMessage(h, "utf8");
                      return v = {
                        method: c.method,
                        result: i.default.encode(g.signature)
                      }, (0, r.logDebug)("SolProvider send result:", JSON.stringify(g)), v;
                    } else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `param is error method: '${p}'`);
                    break;
                  case "solana_signTransaction":
                    {
                      let h = yield window.okxwallet.solana.signTransaction(c.injectParams);
                      return (0, r.logDebug)("SolProvider send bufferResult:", JSON.stringify(h)), v = {
                        method: c.method,
                        injectResult: h
                      }, (0, r.logDebug)("SolProvider send result:", (0, r.safeJsonStringify)(v)), v;
                    }
                    break;
                  case "solana_signAllTransactions":
                    {
                      let h = yield window.okxwallet.solana.signAllTransactions(c.injectParams);
                      return (0, r.logDebug)("SolProvider send result:", (0, r.safeJsonStringify)(h)), v = {
                        method: c.method,
                        injectResult: h
                      }, v;
                    }
                    break;
                  case "solana_signAndSendTransaction":
                    {
                      var d = yield window.okxwallet.solana.signAndSendTransaction(c.injectParams);
                      return (0, r.logDebug)("SolProvider send result:", (0, r.safeJsonStringify)(d)), v = {
                        method: c.method,
                        injectResult: d
                      }, v;
                    }
                    break;
                  default:
                    throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, `method: '${p}'`);
                } else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `param is error method: '${p}'`);
              } catch (p) {
                throw (0, r.logDebug)("SolProvider send error:", p), p;
              }
            });
          }
          disconnect() {}
          restoreConnect() {
            return (0, a.isDevice)("mobile") ? this.connect() : Promise.resolve();
          }
          parseConnectResponse(c, u, f, d, p, v) {
            return n(this, void 0, void 0, function* () {
              let h = [];
              d.forEach(_ => {
                _.namespace === t.NameSpaceKeySOL && h.push(..._.chains);
              });
              let g = [],
                b = {},
                m = {};
              if (h.forEach(_ => {
                let N = p.address.find(O => O.chainId === "501" && O.coinType === 501 || O.namespaceChainId === _);
                N && (g.push(_ + ":" + N.address), m && "publicKey" in m ? b[_] = m : b[_] = {
                  publicKey: N.publicKey
                });
              }), g && g.length > 0) {
                let _ = {
                  namespace: t.NameSpaceKeySOL,
                  addresses: g,
                  methods: [...l.SOLANAMethods],
                  extra: b
                };
                return (0, r.logDebug)("parseConnectResponse nameSpaceResponse :", JSON.stringify(_)), _;
              }
            });
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              return window.okxwallet.solana.connect();
            });
          }
          singleConnect() {
            return this.connect();
          }
          addAccountChangedListener(c) {
            console.log("window.okxwallet configEventWithKey:", "sol"), this.accountChangedSolanaPublicKeyHandler = u => {
              console.log("window.okxwallet configEventWithKey_solana:", Date.now(), "sol", u), u && c();
            }, window.okxwallet.solana.on("accountChanged", this.accountChangedSolanaPublicKeyHandler);
          }
          removeListener() {
            this.accountChangedSolanaPublicKeyHandler && window.okxwallet.solana.removeListener("accountChanged", this.accountChangedSolanaPublicKeyHandler);
          }
        };
        return gi.SolProvider = s, gi;
      }
      var ws = {},
        tb;
      function a2() {
        if (tb) return ws;
        tb = 1;
        var n = ws && ws.__awaiter || function (c, u, f, d) {
          function p(v) {
            return v instanceof f ? v : new f(function (h) {
              h(v);
            });
          }
          return new (f || (f = Promise))(function (v, h) {
            function g(_) {
              try {
                m(d.next(_));
              } catch (N) {
                h(N);
              }
            }
            function b(_) {
              try {
                m(d.throw(_));
              } catch (N) {
                h(N);
              }
            }
            function m(_) {
              _.done ? v(_.value) : p(_.value).then(g, b);
            }
            m((d = d.apply(c, u || [])).next());
          });
        };
        Object.defineProperty(ws, "__esModule", {
          value: !0
        }), ws.AptosProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = is(),
          i = pi(),
          a = Ed(),
          l = Object.freeze(["637", "70000060", "70000066"]),
          s = new Map();
        s.set("aptos:637", "Mainnet"), s.set("aptos:70000060", "Movement Testnet"), s.set("aptos:70000066", "Movement Mainnet");
        let o = class {
          send(u) {
            return n(this, void 0, void 0, function* () {
              try {
                (0, t.logDebug)("AptosProvider send request:", (0, t.safeJsonStringify)(u)), yield this.restoreConnect();
                let f = yield window.okxwallet.aptos.network(),
                  d = this.searchChainIdToInjectChainName(u.chainId);
                if ((0, t.logDebug)("AptosProvider send network and searchNetwork:", f, "-----", d), !(f && d && f.toLowerCase() === d.toLowerCase())) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Please switch your wallet link to '${d}'`);
                const p = u.method;
                let v;
                switch (p) {
                  case "aptos_signMessage":
                    if (u.injectParams) {
                      let h = yield window.okxwallet.aptos.signMessage(u.injectParams);
                      return v = {
                        method: u.method,
                        result: h.signature,
                        injectResult: h
                      }, (0, t.logDebug)("AptosProvider send result:", (0, t.safeJsonStringify)(v)), v;
                    } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `param is error method: '${p}'`);
                    break;
                  case "aptos_signTransaction":
                    {
                      (0, t.logDebug)("AptosProvider Method>>>> :", p);
                      let h = yield window.okxwallet.aptos.signTransaction(u.params);
                      return v = {
                        method: u.method,
                        result: h
                      }, (0, t.logDebug)("AptosProvider send result:", (0, t.safeJsonStringify)(v)), v;
                    }
                    break;
                  case "aptos_signAndSubmitTransaction":
                    {
                      (0, t.logDebug)("AptosProvider Method>>>> :", p);
                      let h = yield window.okxwallet.aptos.signAndSubmitTransaction(u.params);
                      return v = {
                        method: u.method,
                        result: h.hash
                      }, (0, t.logDebug)("AptosProvider send result:", (0, t.safeJsonStringify)(v)), v;
                    }
                    break;
                  default:
                    throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, ` method: '${p}'`);
                }
              } catch (f) {
                throw (0, t.logDebug)("AptosProvider send error:", f), f;
              }
            });
          }
          searchChainIdToInjectChainName(u) {
            let f = u;
            return s.forEach((d, p) => {
              u.includes(p) && (f = d);
            }), f;
          }
          disconnect() {}
          restoreConnect() {
            return (0, i.isDevice)("mobile") ? this.connect() : Promise.resolve();
          }
          parseConnectResponse(u, f, d, p, v, h) {
            return n(this, void 0, void 0, function* () {
              let g = [];
              p.forEach(N => {
                N.namespace === e.NameSpaceKeyAptos && g.push(...N.chains);
              });
              let b = [],
                m = {};
              (0, t.logDebug)("AptosProvider parseConnectResponse connectChain", JSON.stringify(g));
              let _;
              if (!(0, i.isDevice)("mobile") && g && g.length > 0 && (_ = (yield window.okxwallet.aptos.connect()).publicKey), g.forEach(N => {
                let O = v.address.find(y => l.includes(y.chainId) && y.coinType === 637 || y.namespaceChainId === N);
                O && (b.push(N + ":" + O.address), m[N] = {
                  publicKey: O.publicKey ? O.publicKey : _
                });
              }), (0, t.logDebug)("AptosProvider parseConnectResponse addresses", JSON.stringify(b)), b && b.length > 0) return {
                namespace: e.NameSpaceKeyAptos,
                addresses: b,
                methods: [...r.AptosMethods],
                extra: m
              };
            });
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              return window.okxwallet.aptos.connect();
            });
          }
          singleConnect() {
            return this.connect();
          }
          addAccountChangedListener(u) {
            window.okxwallet.aptos.onAccountChange(f => {
              console.log("window.okxwallet configEventWithKey_aptos:", Date.now(), a.key, JSON.stringify(f)), f && u();
            });
          }
          removeListener() {}
        };
        return ws.AptosProvider = o, ws;
      }
      var xs = {},
        nb;
      function c2() {
        if (nb) return xs;
        nb = 1;
        var n = xs && xs.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(xs, "__esModule", {
          value: !0
        }), xs.TONProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = pi(),
          i = is();
        let a = class {
          constructor() {
            this.signalChainConnectResult = void 0, this.accountChangedTONHandler = null;
          }
          send(s) {
            return n(this, void 0, void 0, function* () {
              try {
                (0, t.logDebug)("TONProvider send request:", (0, t.safeJsonStringify)(s));
                let o = null;
                switch (s.method) {
                  case "ton_sendTransaction":
                    s.params && (o = {
                      method: "sendTransaction",
                      params: [JSON.stringify(s.params)],
                      id: Date.now().toString()
                    }, (0, t.logDebug)("TONProvider tonParams first:", JSON.stringify(o)));
                    break;
                  default:
                    throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
                if (o) {
                  const c = yield window.okxTonWallet.tonconnect.send(o);
                  if ((0, t.logDebug)("TONProvider send request result:", (0, t.safeJsonStringify)(c)), c.error) throw new e.OKXConnectError(c.error.code, c.error.message);
                  return {
                    result: c.result,
                    method: s.method
                  };
                } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
              } catch (o) {
                throw (0, t.logDebug)("TONProvider encountered an error:", o), o;
              }
            });
          }
          restoreConnect() {
            return Promise.resolve();
          }
          parseConnectResponse(s, o, c, u, f, d) {
            return n(this, void 0, void 0, function* () {
              try {
                let p = [];
                u.forEach(g => {
                  g.namespace === e.NameSpaceKeyTON && p.push(...g.chains);
                });
                let v = [],
                  h = {};
                if (p.forEach(g => {
                  let b = (0, t.getChainId)(g),
                    m = f.address.find(_ => _.chainId === "607" && _.coinType === 607 || _.namespaceChainId === g);
                  m && (v.push(g + ":" + m.address), h[g] = {
                    publicKey: m.publicKey
                  });
                }), (0, t.logDebug)("tonprovider parseConnectResponse needPop and addresses: ", s, JSON.stringify(v)), v && v.length > 0) {
                  let g = u.find(m => m.namespace === e.NameSpaceKeyTON);
                  (0, t.logDebug)("tonprovider parseConnectResponse ton: ", JSON.stringify(g));
                  let b;
                  if (g && g.params && d && d.manifestUrl) {
                    this.dappInfo = d;
                    let m = [g.params.ton_addr],
                      _ = {
                        manifestUrl: d.manifestUrl,
                        items: m
                      };
                    (s || o) && g.params.ton_proof && m.push(g.params.ton_proof), (0, t.logDebug)("parseConnectResponse ton connect params: ", JSON.stringify(_)), (0, r.isDevice)("mobile") ? b = yield window.okxTonWallet.tonconnect.connect(2, _) : s || o ? b = yield window.okxTonWallet.tonconnect.connect(2, _) : b = yield window.okxTonWallet.tonconnect.restoreConnection();
                  } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "manifestUrl is nil");
                  if (c && this.signalChainConnectResult && (b = this.signalChainConnectResult, this.signalChainConnectResult = void 0), (0, t.logDebug)("parseConnectResponse ton connect result: ", JSON.stringify(b)), b && g) {
                    if (b.event === "connect_error") throw new e.OKXConnectError(b.payload.code, b.payload.message);
                    {
                      let m = b.payload.items.find(O => O.name === "ton_addr"),
                        _ = b.payload.items.find(O => O.name === "ton_proof");
                      return (0, t.logDebug)("tonprovider connect isSignalChain: ", c), {
                        namespace: e.NameSpaceKeyTON,
                        addresses: v,
                        methods: [...i.TONMethods],
                        extra: h,
                        data: {
                          ton_addr: m,
                          ton_proof: _,
                          manifestUrl: d.manifestUrl
                        }
                      };
                    }
                  }
                }
                return;
              } catch (p) {
                throw (0, t.logDebug)("tonprovider parseConnectResponse error: ", JSON.stringify(p)), p;
              }
            });
          }
          connect(s, o) {
            return n(this, void 0, void 0, function* () {
              if (s && o && o.manifestUrl && s.params) {
                this.dappInfo = o;
                let c = [s.params.ton_addr],
                  u = {
                    manifestUrl: o.manifestUrl,
                    items: c
                  };
                s.params.ton_proof && c.push(s.params.ton_proof), (0, t.logDebug)("tonprovider connect params: ", JSON.stringify(u));
                try {
                  let f = yield window.okxTonWallet.tonconnect.connect(2, u);
                  return (0, t.logDebug)("tonprovider connect tonResult: ", JSON.stringify(f)), this.signalChainConnectResult = f, f;
                } catch (f) {
                  throw (0, t.logDebug)("tonprovider connect error: ", JSON.stringify(f)), new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "tonconnect error");
                }
              } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "manifestUrl or params is nil");
            });
          }
          singleConnect(s, o) {
            return this.connect(s, o);
          }
          addAccountChangedListener(s) {
            console.log("window.okxwallet configEventWithKey:", "ton"), this.accountChangedTONHandler = () => {
              console.log("window.okxwallet configEventWithKey_TON:", Date.now(), "ton"), s();
            }, window.okxTonWallet.tonconnect.on("accountChanged", this.accountChangedTONHandler);
          }
          removeListener() {
            this.accountChangedTONHandler && window.okxTonWallet.tonconnect.off("accountChanged", this.accountChangedTONHandler);
          }
        };
        return xs.TONProvider = a, xs;
      }
      var _s = {},
        rb;
      function l2() {
        if (rb) return _s;
        rb = 1;
        var n = _s && _s.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(_s, "__esModule", {
          value: !0
        }), _s.SuiProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = pi(),
          i = is();
        class a {
          constructor(s = window.okxwallet.sui) {
            this.accountChangedHandler = null, this.wallet = s;
          }
          getSuiPublicKey() {
            return n(this, void 0, void 0, function* () {
              return (yield this.connect()).accounts[0].publicKey;
            });
          }
          parseConnectResponse(s, o, c, u, f, d) {
            return n(this, void 0, void 0, function* () {
              try {
                let p = [];
                u.forEach(b => {
                  b.namespace === e.NameSpaceKeySui && p.push(...b.chains);
                });
                let v = [],
                  h = {};
                if (p.length == 0) return;
                const g = yield this.getSuiPublicKey();
                return p.forEach(b => {
                  var m;
                  let _ = (0, t.getChainId)(b),
                    N = f.address.find(O => O.coinType === 784 || O.namespaceChainId === b);
                  N && (v.push(b + ":" + N.address), h[b] = {
                    publicKey: (m = N.publicKey) !== null && m !== void 0 ? m : g
                  });
                }), v && v.length > 0 ? {
                  namespace: e.NameSpaceKeySui,
                  addresses: v,
                  methods: [...i.SuiMethods],
                  extra: h
                } : void 0;
              } catch (p) {
                throw p;
              }
            });
          }
          restoreConnect() {
            return (0, r.isDevice)("mobile") ? this.connect() : Promise.resolve();
          }
          getSuiWallet() {
            return this.wallet;
          }
          send(s) {
            return n(this, void 0, void 0, function* () {
              try {
                yield this.restoreConnect(), (0, t.logDebug)("suiProvider send request:", JSON.stringify(s));
                const o = s.method;
                let c;
                if (s.injectParams && this.getSuiWallet()) {
                  let u = s.injectParams;
                  switch (o) {
                    case "sui_signTransactionBlock":
                      let f;
                      if (this.getSuiWallet().features["sui:signTransaction"]) f = yield this.getSuiWallet().features["sui:signTransaction"].signTransaction(u);else if (this.getSuiWallet().features["sui:signTransactionBlock"]) f = yield this.getSuiWallet().features["sui:signTransactionBlock"].signTransactionBlock(u);else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      c = {
                        method: "sui_signTransactionBlock",
                        result: f == null ? void 0 : f.signature
                      };
                      break;
                    case "sui_signAndExecuteTransactionBlock":
                      let d;
                      if (this.getSuiWallet().features["sui:signAndExecuteTransaction"]) d = yield this.getSuiWallet().features["sui:signAndExecuteTransaction"].signAndExecuteTransaction(u);else if (this.getSuiWallet().features["sui:signAndExecuteTransactionBlock"]) d = yield this.getSuiWallet().features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(u);else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                      c = {
                        method: "sui_signAndExecuteTransactionBlock",
                        result: d.digest
                      };
                      break;
                    case "sui_signMessage":
                      c = {
                        method: "sui_signMessage",
                        result: (yield this.getSuiWallet().features["sui:signMessage"].signMessage(u)).signature
                      };
                      break;
                    case "sui_signPersonalMessage":
                      c = {
                        method: "sui_signPersonalMessage",
                        result: (yield this.getSuiWallet().features["sui:signPersonalMessage"].signPersonalMessage(u)).signature
                      };
                      break;
                  }
                }
                return c;
              } catch (o) {
                throw (0, t.logDebug)("suiProvider send error:", o), o;
              }
            });
          }
          connect() {
            return n(this, void 0, void 0, function* () {
              var s;
              return (s = this.getSuiWallet()) === null || s === void 0 ? void 0 : s.features["standard:connect"].connect();
            });
          }
          singleConnect() {
            return this.connect();
          }
          addStandardEventListener(s) {
            var o, c;
            !((o = this.getSuiWallet()) === null || o === void 0) && o.features["standard:events"] ? ((0, t.logDebug)("sui-provider standard:events change"), (c = this.getSuiWallet()) === null || c === void 0 || c.features["standard:events"].on("change", u => {
              s(u);
            })) : (0, t.logDebug)("sui-provider standard:events null");
          }
          addAccountChangedListener(s) {
            var o;
            console.log("configEventWithKey:", "sui"), this.getSuiWallet().on && (this.accountChangedHandler = c => {
              console.log("configEventWithKey_sui:", Date.now(), "sui", c), c && s();
            }, (o = this.getSuiWallet()) === null || o === void 0 || o.on("accountChanged", this.accountChangedHandler));
          }
          removeListener() {
            var s;
            this.accountChangedHandler && ((s = this.getSuiWallet()) === null || s === void 0 || s.removeListener("accountChanged", this.accountChangedHandler));
          }
        }
        return _s.SuiProvider = a, _s;
      }
      var Es = {},
        ib;
      function u2() {
        if (ib) return Es;
        ib = 1;
        var n = Es && Es.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(Es, "__esModule", {
          value: !0
        }), Es.BtcProvider = void 0;
        const e = Jt(),
          t = tn(),
          r = is(),
          i = pi();
        class a {
          constructor() {
            this.accountChangedBtcHandler = null;
          }
          connect() {
            return window.okxwallet.unisat.connect();
          }
          switchChain(s) {
            return n(this, void 0, void 0, function* () {
              let o = window.okxwallet.unisat;
              switch (s) {
                case e.BTC_CHAINS.MAINNET:
                  yield o.switchChain("BITCOIN_MAINNET");
                  break;
                case e.BTC_CHAINS.FRACTAL:
                  yield o.switchChain("FRACTAL_BITCOIN_MAINNET");
                  break;
              }
            });
          }
          parseConnectResponse(s, o, c, u, f) {
            return n(this, void 0, void 0, function* () {
              try {
                let d = [];
                u.forEach(m => {
                  m.namespace === e.NameSpaceKeyBtc && d.push(...m.chains);
                });
                let p = [],
                  v = {};
                if (d.length == 0) return;
                const h = (m, _) => m.find(N => {
                    const O = N.name === "bitcoin" && _ === e.BTC_CHAINS.MAINNET || N.name === "fractalbitcoin" && _ === e.BTC_CHAINS.FRACTAL;
                    return N.coinType === 0 && O || N.namespaceChainId === _;
                  }),
                  g = m => n(this, void 0, void 0, function* () {
                    let _ = h(f.address, m);
                    if (!_) return;
                    p.push(m + ":" + _.address);
                    let N = yield this.connect();
                    v[m] = {
                      publicKey: N.publicKey,
                      compressedPublicKey: N.compressedPublicKey
                    };
                  }),
                  b = d.map(g);
                return yield Promise.all(b), p && p.length > 0 ? {
                  namespace: e.NameSpaceKeyBtc,
                  addresses: p,
                  methods: [...r.BtcMethods],
                  extra: v
                } : void 0;
              } catch (d) {
                throw d;
              }
            });
          }
          restoreConnect() {
            return n(this, void 0, void 0, function* () {
              return (0, i.isDevice)("mobile") ? this.connect() : Promise.resolve();
            });
          }
          send(s) {
            return n(this, void 0, void 0, function* () {
              try {
                (0, t.logDebug)("btcProvider send request:", JSON.stringify(s));
                const o = s.method,
                  c = s.chainId;
                yield this.restoreConnect(), yield this.switchChain(c);
                let u;
                if (s.params) switch (o) {
                  case "btc_signMessage":
                    {
                      const {
                          signStr: f,
                          type: d
                        } = s.params || {},
                        p = yield window.okxwallet.unisat.signMessage(f, d);
                      return {
                        method: s.method,
                        result: p
                      };
                    }
                  case "btc_send":
                    {
                      const {
                          from: f,
                          to: d,
                          value: p,
                          satBytes: v
                        } = s.params || {},
                        h = yield window.okxwallet.unisat.send({
                          from: f,
                          to: d,
                          value: p,
                          satBytes: v
                        });
                      return {
                        method: s.method,
                        result: h
                      };
                    }
                  case "btc_signPsbts":
                    {
                      const {
                        psbtHexs: f,
                        options: d
                      } = s.params || {};
                      let p;
                      if (Array.isArray(f) && f.length === 1) {
                        let v;
                        Array.isArray(d) ? v = yield window.okxwallet.unisat.signPsbt(f[0], d.length > 0 && typeof d[0] == "object" ? d[0] : void 0) : v = yield window.okxwallet.unisat.signPsbt(f[0]), p = [v];
                      } else p = yield window.okxwallet.unisat.signPsbts(f, d);
                      return {
                        method: s.method,
                        result: (0, t.safeJsonStringify)(p)
                      };
                    }
                  case "btc_signAndPushPsbt":
                    {
                      const {
                          psbtHex: f,
                          options: d
                        } = s.params || {},
                        p = yield window.okxwallet.unisat.signPsbt(f, d),
                        v = yield window.okxwallet.unisat.pushPsbt(p);
                      return {
                        method: s.method,
                        result: (0, t.safeJsonStringify)({
                          signedPsbt: p,
                          txHash: v
                        })
                      };
                    }
                  case "btc_sendInscription":
                    {
                      const {
                          address: f,
                          inscriptionId: d,
                          options: p
                        } = s.injectParams || {},
                        v = yield window.okxwallet.unisat.sendInscription(f, d, p);
                      return {
                        method: s.method,
                        result: v
                      };
                    }
                  case "btc_inscribeTransfer":
                    if (this.hasFunction("inscribeTransfer")) {
                      const {
                          ticker: f,
                          amount: d
                        } = s.params || {},
                        p = yield window.okxwallet.unisat.inscribeTransfer(f, d);
                      return {
                        method: s.method,
                        result: p
                      };
                    }
                  case "btc_sendRunes":
                    if (this.hasFunction("sendRunes")) {
                      const {
                          address: f,
                          runeid: d,
                          amount: p,
                          options: v
                        } = s.injectParams || {},
                        h = yield window.okxwallet.unisat.sendRunes(f, d, p, v);
                      return {
                        method: s.method,
                        result: h
                      };
                    }
                  default:
                    throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, `method: '${o}' not support`);
                } else throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, `param is error method: '${o}'`);
              } catch (o) {
                throw (0, t.logDebug)("BtcProvider send error:", o), o;
              }
            });
          }
          hasFunction(s) {
            return !!(window.okxwallet && window.okxwallet.unisat && typeof window.okxwallet.unisat[s] == "function");
          }
          singleConnect(s) {
            return n(this, void 0, void 0, function* () {
              return s.chains.length == 1 ? this.connect() : !1;
            });
          }
          addAccountChangedListener(s) {
            this.accountChangedBtcHandler = o => {
              console.log("window.okxwallet btc:", Date.now(), "btc", o), o && o.length > 0 && s();
            }, window.okxwallet.unisat.on("accountsChanged", this.accountChangedBtcHandler);
          }
          removeListener() {
            window.okxwallet.unisat.removeListener("accountsChanged", this.accountChangedBtcHandler);
          }
        }
        return Es.BtcProvider = a, Es;
      }
      var ob;
      function sb() {
        if (ob) return bs;
        ob = 1;
        var n = bs && bs.__awaiter || function (h, g, b, m) {
          function _(N) {
            return N instanceof b ? N : new b(function (O) {
              O(N);
            });
          }
          return new (b || (b = Promise))(function (N, O) {
            function y(R) {
              try {
                A(m.next(R));
              } catch (T) {
                O(T);
              }
            }
            function w(R) {
              try {
                A(m.throw(R));
              } catch (T) {
                O(T);
              }
            }
            function A(R) {
              R.done ? N(R.value) : _(R.value).then(y, w);
            }
            A((m = m.apply(h, g || [])).next());
          });
        };
        Object.defineProperty(bs, "__esModule", {
          value: !0
        }), bs.OkxwalletInjectConnector = void 0;
        const e = Md(),
          t = Jt(),
          r = Jm(),
          i = s2(),
          a = a2(),
          l = c2(),
          s = l2(),
          o = u2(),
          c = tn(),
          u = Pu(),
          f = pi(),
          d = xm(),
          p = qi();
        class v extends e.InjectConnector {
          getType() {
            return p.CONNECTOR_TYPE.INJECT.OKX_INJECT_WALLET;
          }
          constructor() {
            super(), this.walletName = "OKX Wallet", this.walletNameKey = "walletModal.mobileConnectionModal.connectInjected", this.providerMap.set(t.NameSpaceKeyEip155, new r.Eip155Provider()), this.providerMap.set(t.NameSpaceKeySOL, new i.SolProvider()), this.providerMap.set(t.NameSpaceKeyAptos, new a.AptosProvider()), this.providerMap.set(t.NameSpaceKeyTON, new l.TONProvider()), this.providerMap.set(t.NameSpaceKeySui, new s.SuiProvider()), this.providerMap.set(t.NameSpaceKeyBtc, new o.BtcProvider());
          }
          openWallet(g, b) {
            return n(this, void 0, void 0, function* () {
              var m, _, N;
              if ((0, c.logDebug)("InjectEngine connect begin:", JSON.stringify(g)), !g) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR);
              this.dappInfo = g.connectRequest.dAppInfo;
              var O = g.connectRequest;
              try {
                if (window && window.okxwallet) {
                  if (O.requests) {
                    let A = O.requests.find(C => C.name === "requestAccounts"),
                      R = yield window.okxwallet.getVersion(),
                      T = {
                        method: "connect",
                        requestId: O.requestId,
                        payload: {
                          wallet: {
                            platform: (m = navigator.platform) !== null && m !== void 0 ? m : "/",
                            appName: u.OKXInjectWalletName,
                            appVersion: R != null ? R : "1.0.0",
                            maxProtocolVersion: 1
                          },
                          responses: []
                        }
                      },
                      D = {
                        name: "requestAccounts",
                        accounts: []
                      };
                    T.payload.responses.push(D), yield this.disconnect();
                    const M = (_ = A.requiredNamespaces) !== null && _ !== void 0 ? _ : [],
                      q = (N = A.optionalNamespaces) !== null && N !== void 0 ? N : [];
                    let W = !0,
                      x = !1;
                    if (M.length + q.length === 1 && !(0, f.isDevice)("mobile")) {
                      const C = M.length === 1 ? M[0] : q[0],
                        B = this.getInjectProvider(C.namespace);
                      (yield B == null ? void 0 : B.singleConnect(C, this.dappInfo)) && (x = !0, W = !1);
                    }
                    var y = yield this.getAccountByRequestWallets(W, !1, x, M, q);
                    if (y) {
                      if (D.accounts.push(...y), D.accounts.length === 0) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "connect connectAccounts is null");
                    } else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "connect requestWallets is null");
                    this.connectResultListener && (this.disconnectHandler && window.okxwallet.removeListener("disconnect", this.disconnectHandler), this.disconnectHandler = () => {
                      console.log("window.okxwallet disconnect:"), this.disconnectListener.forEach(C => C()), this.disconnectListener = [];
                    }, window.okxwallet.on("disconnect", this.disconnectHandler), this.connectResultListener(T, this));
                  }
                } else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR);
              } catch (A) {
                var w = t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR;
                A instanceof t.OKXConnectError && (w = A.code, A.message), this.connectResultListener && this.connectResultListener({
                  requestId: "-1",
                  method: "connect_error",
                  payload: {
                    code: w
                  }
                }, this);
              }
            });
          }
          checkAccountChanged() {
            return n(this, void 0, void 0, function* () {
              var g;
              try {
                let b = (g = this.connectionManager) === null || g === void 0 ? void 0 : g.getSessionContent("connectSession");
                if (!b) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
                (0, c.logDebug)("inject-connector checkAccountChanged --sessionInfo:", JSON.stringify(b));
                let m = this.getRequireNameSpaceFromSession(b);
                (0, c.logDebug)("inject-connector checkAccountChanged --requiredNamespaces:", JSON.stringify(m));
                let _ = yield this.getAccountByRequestWallets(!1, !0, !1, m, []);
                if ((0, c.logDebug)("inject-connector checkAccountChanged --accounts:", JSON.stringify(_)), _) {
                  let N = {};
                  (0, d.buildAccountNameSpaces)(_, N), this.compareAndModifyNamespaces(b.namespaces, N) || ((0, c.logDebug)("inject-connector checkAccountChanged --result sessionLocal:", JSON.stringify(b)), this.accountChangeListener ? ((0, c.logDebug)("inject-connector checkAccountChanged -accountChangeListener:", this.accountChangeListener), this.accountChangeListener(b)) : ((0, c.logDebug)("inject-connector checkAccountChanged disconnect:"), yield this.disconnect()));
                } else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "connect requestWallets is null");
              } catch (b) {
                throw (0, c.logDebug)("inject-connector restoreconnect catch error", JSON.stringify(b)), b;
              }
            });
          }
          compareAndModifyNamespaces(g, b) {
            let m = !0;
            for (const _ in g) if (b[_]) {
              const N = g[_],
                O = b[_];
              (0, c.logDebug)("inject-connector checkAccountChanged ns1:", JSON.stringify(N)), (0, c.logDebug)("inject-connector checkAccountChanged ns2:", JSON.stringify(O)), JSON.stringify([...N.accounts].sort()) === JSON.stringify([...O.accounts].sort()) || (m = !1, N.accounts = [...O.accounts], N.extra = Object.assign({}, O.extra), N.payload = Object.assign({}, O.payload)), (0, c.logDebug)("inject-connector checkAccountChanged new ns1:", JSON.stringify(N));
            }
            return (0, c.logDebug)(`inject-connector checkAccountChanged compareAndModifyNamespaces ===> ${m}`), m;
          }
          restoreconnect(g, b) {
            var m;
            if (!window.okxwallet) {
              b(null);
              return;
            }
            this.dappInfo = (m = g.sessionConfig) === null || m === void 0 ? void 0 : m.dappInfo, (0, c.logDebug)("inject-connector restoreconnect --sessionInfo:", JSON.stringify(g));
            var _ = this.getRequireNameSpaceFromSession(g);
            (0, c.logDebug)("inject-connector restoreconnect --requiredNamespaces:", JSON.stringify(_)), this.getAccountByRequestWallets(!1, !1, !1, _, []).then(N => {
              (0, c.logDebug)("inject-connector restoreconnect --accounts:", JSON.stringify(N));
              let O = !0;
              for (let A in g.namespaces) {
                var y = N.find(D => D.namespace === A),
                  w = g.namespaces[A].accounts;
                if (!y) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "resotreconnect error: accountItem error");
                let R = w;
                A === t.NameSpaceKeyAptos && R && R.length > 0 && (R = w.map(D => (0, c.replaceChainNameToChainId)(D))), y.addresses.length === R.length && y.addresses.slice().sort().every((D, M) => {
                  if (A === t.NameSpaceKeyAptos) {
                    let q = R.slice().sort()[M];
                    return (0, c.logDebug)("check aptos address -value and aptosAdd--", D, q), q === D;
                  } else return D === R.slice().sort()[M];
                }) || (O = !1);
              }
              if (O) b(g);else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR, "resotreconnect error: address not as same as session");
            }).catch(N => {
              (0, c.logDebug)("inject-connector restoreconnect catch error", JSON.stringify(N)), b(null);
            });
          }
          getRequireNameSpaceFromSession(g) {
            var b,
              m,
              _ = [];
            for (let N in g.namespaces) {
              let O = g.namespaces[N],
                y = {
                  namespace: N,
                  chains: O.chains
                };
              if (N === t.NameSpaceKeyAptos) {
                let w = [];
                O.chains.forEach(A => {
                  let R = (0, c.replaceChainNameToChainId)(A);
                  w.push(R);
                }), y = {
                  namespace: N,
                  chains: w
                };
              } else if (N === t.NameSpaceKeyTON) {
                let w, A;
                !((b = O.payload) === null || b === void 0) && b.ton_proof && (w = (m = O.payload) === null || m === void 0 ? void 0 : m.ton_proof, w.proof.payload && (A = {
                  name: "ton_proof",
                  payload: w.proof.payload
                })), y = {
                  namespace: N,
                  chains: O.chains,
                  params: {
                    ton_addr: {
                      name: "ton_addr"
                    },
                    ton_proof: A
                  }
                };
              }
              _.push(y);
            }
            return _;
          }
          getAccountByRequestWallets(g, b, m, _, N) {
            return n(this, void 0, void 0, function* () {
              try {
                var O = [],
                  y = [];
                if ((0, f.isDevice)("mobile")) {
                  var w = yield window.okxwallet.connectWallet(g, {
                    requiredNamespaces: _,
                    optionalNamespaces: N
                  });
                  O.push(w);
                } else O = yield window.okxwallet.requestWallets(g);
                var A = [...(_ != null ? _ : []), ...(N != null ? N : [])];
                let R = O[0];
                (0, c.logDebug)(" InjectEngine connect connectAccounts:", JSON.stringify(R));
                let T;
                if (A && R && R.address) for (const [M, q] of this.providerMap.entries()) {
                  let W = yield q.parseConnectResponse(g, b, m, A, R, this.dappInfo);
                  W && (T = M, y.push(W));
                }
                let D = _.every(M => {
                  let q = y.find(W => W.namespace === M.namespace);
                  return q ? M.chains.every(x => !!q.addresses.find(B => B.startsWith(x + ":"))) : !1;
                });
                if ((0, c.logDebug)("InjectEngine connect requiredNamespaces:", JSON.stringify(_)), (0, c.logDebug)("InjectEngine connect accountResult:", JSON.stringify(y)), !D) throw yield this.disconnect(), new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
                return (0, f.isDevice)("mobile") || (this.configEventWithKey(T), yield window.okxwallet.requestWallets(g)), y;
              } catch (R) {
                throw R && typeof R == "object" && "code" in R && R.code === 4001 ? new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.USER_REJECTS_ERROR) : new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
              }
            });
          }
          configEventWithKey(g) {
            var b, m;
            for (let _ in this.providerMap) (b = this.providerMap.get(_)) === null || b === void 0 || b.removeListener();
            (m = this.getInjectProvider(g)) === null || m === void 0 || m.addAccountChangedListener(() => {
              this.checkAccountChanged().catch(_ => {
                console.log("window.okxwallet configEventWithKey error: ", _);
              });
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              (0, c.logDebug)("InjectEngine ==>> disconnect  okxwallet.disconnect()"), window.okxwallet && (yield window.okxwallet.disconnect(), (0, c.logDebug)("InjectEngine ==>> disconnect end okxwallet.disconnect()"));
            });
          }
        }
        return bs.OkxwalletInjectConnector = v, bs;
      }
      var Cs = {},
        ab;
      function f2() {
        if (ab) return Cs;
        ab = 1;
        var n = Cs && Cs.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Cs, "__esModule", {
          value: !0
        }), Cs.OkxwalletInjectTonsdkConnector = void 0;
        const e = Jt(),
          t = tn(),
          r = pi(),
          i = sb(),
          a = qi();
        class l extends i.OkxwalletInjectConnector {
          getType() {
            return a.CONNECTOR_TYPE.INJECT.OKX_INJECT_WALLET;
          }
          constructor() {
            super(), this.walletName = "OKX Wallet extension", this.walletNameKey = "walletModal.mobileConnectionModal.connectInjected";
          }
          checkWalletMatch() {
            return n(this, void 0, void 0, function* () {
              var o, c, u;
              (o = this.connectionManager) === null || o === void 0 || o.tonsdkConnectStorage.synchronizedCache();
              let f = (c = this.connectionManager) === null || c === void 0 ? void 0 : c.tonsdkConnectStorage.getItem("ton_connect_info_adapter_universal");
              if (!f || !(f != null && f.content)) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
              const d = f == null ? void 0 : f.content;
              let p = JSON.parse(d),
                v = p.connectEvent.payload.items.find(g => "name" in g ? g.name === "ton_addr" : !1);
              this.dappInfo = p.dappInfo;
              let h;
              if (v && "address" in v && (h = v.address), !h) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
              if ((0, t.logDebug)(`inject-connector localTonaddress : ${h}`), (0, r.isDevice)("mobile")) {
                let g;
                g = {
                  namespace: e.NameSpaceKeyTON,
                  chains: [e.TON_CHAINS.MAINNET],
                  params: {
                    ton_addr: {
                      name: "ton_addr"
                    }
                  }
                };
                let b = yield this.getAccountByRequestWallets(!1, !1, !1, [g], []);
                if (b && b.length == 1) {
                  let _ = (u = b[0].data) === null || u === void 0 ? void 0 : u.ton_addr,
                    N = _ == null ? void 0 : _.address;
                  if (h === N) return;
                }
              } else {
                let g = yield window.okxTonWallet.tonconnect.restoreConnection();
                if (g.event === "connect" && g.payload.items.find(m => m.name === "ton_addr").address == h) return;
              }
              throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.WALLET_NOT_SUPPORTED);
            });
          }
        }
        return Cs.OkxwalletInjectTonsdkConnector = l, Cs;
      }
      var Os = {},
        cb;
      function d2() {
        if (cb) return Os;
        cb = 1;
        var n = Os && Os.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(Os, "__esModule", {
          value: !0
        }), Os.ThirdpartInjectConnector = void 0;
        const e = Md(),
          t = Jt(),
          r = qi(),
          i = tn();
        class a extends e.InjectConnector {
          getType() {
            return this.walletName === t.AptosGoogleWalletName ? r.CONNECTOR_TYPE.KEYLESS.GOOGLE_WALLET : this.walletName === t.AptosAppleWalletName ? r.CONNECTOR_TYPE.KEYLESS.APPLE_WALLET : r.CONNECTOR_TYPE.INJECT.STANDARD_INJECT_WALLET;
          }
          constructor(s) {
            super(), this.walletName = s.walletName, s.wallets.forEach((o, c) => {
              this.providerMap.set(c, o);
            }), this.icon = s.icon;
          }
          registerWallet(s, o) {
            this.providerMap.set(s, o);
          }
          getTag() {
            var s;
            return r.STANDARD_INJECT_WALLET + ((s = this.walletName) !== null && s !== void 0 ? s : "");
          }
          getWalletVersion() {
            return n(this, void 0, void 0, function* () {
              const s = this.providerMap.values().next().value;
              if (!s) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR);
              return s.getVersion();
            });
          }
          openWallet(s, o) {
            return n(this, void 0, void 0, function* () {
              var c, u;
              if ((0, i.logDebug)("InjectEngine connect begin:", JSON.stringify(s)), !s) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR);
              this.dappInfo = s.connectRequest.dAppInfo;
              var f = s.connectRequest;
              try {
                if (f.requests) {
                  let p = f.requests.find(b => b.name === "requestAccounts");
                  const v = (c = p.requiredNamespaces) !== null && c !== void 0 ? c : [],
                    h = (u = p.optionalNamespaces) !== null && u !== void 0 ? u : [];
                  let g;
                  if (v.length + h.length === 1) {
                    const b = v.length === 1 ? v[0] : h[0],
                      m = this.providerMap.get(b.namespace);
                    if (this.addListener(b.namespace), m) g = yield this.getResponseByConnect(m);else throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "openWallet: provider not found");
                  }
                  this.connectResultListener && g && this.connectResultListener(g, this);
                }
              } catch (p) {
                var d = t.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR;
                p instanceof t.OKXConnectError && (d = p.code, p.message), this.connectResultListener && this.connectResultListener({
                  requestId: "-1",
                  method: "connect_error",
                  payload: {
                    code: d
                  }
                });
              }
            });
          }
          getResponseByConnect(s) {
            return n(this, void 0, void 0, function* () {
              var o, c;
              let u = {
                  method: "connect",
                  requestId: Date.now().toString(),
                  payload: {
                    wallet: {
                      platform: (o = navigator.platform) !== null && o !== void 0 ? o : "/",
                      appName: r.STANDARD_INJECT_WALLET + this.walletName,
                      appVersion: (c = this.getWalletVersion()) !== null && c !== void 0 ? c : "1.0.0",
                      maxProtocolVersion: 1
                    },
                    responses: []
                  }
                },
                f = {
                  name: "requestAccounts",
                  accounts: []
                };
              return u.payload.responses.push(f), f.accounts.push(yield this.getAccount(s)), u;
            });
          }
          getAccount(s) {
            return n(this, void 0, void 0, function* () {
              return s.getAccount();
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              yield Promise.all([...this.providerMap.values()].map(s => s.disconnect()));
            });
          }
          onDisconnect() {
            this.disconnectListener.forEach(s => s()), this.disconnectListener = [];
          }
          restoreconnect(s, o) {
            const c = Object.keys(s.namespaces);
            if (!(c.length === 1)) {
              o(null);
              return;
            }
            const f = this.getInjectProvider(c[0]);
            if (!f) return o(null);
            f.getAccount().then(d => {
              var p;
              let v = (p = d == null ? void 0 : d.addresses) !== null && p !== void 0 ? p : [""];
              s.namespaces[c[0]].accounts[0].includes(v[0]) ? o(s) : o(null);
            }).catch(d => {
              o(null);
            });
          }
          checkAccountChanged(s, o) {
            return n(this, void 0, void 0, function* () {
              var c, u;
              try {
                let f = (c = this.connectionManager) === null || c === void 0 ? void 0 : c.getSessionContent("connectSession");
                if (o && f.namespaces[s].accounts.includes(o)) return;
                let d = this.getInjectProvider(s);
                if (d) {
                  let p = yield this.getResponseByConnect(d);
                  if (p && f) {
                    let h = p.payload.responses[0].accounts[0];
                    f.namespaces[s].accounts = h.addresses, f.namespaces[s].extra = h.extra, f.namespaces[s].rpcMap = void 0, f.namespaces[s].methods = h.methods, (u = this.accountChangeListener) === null || u === void 0 || u.call(this, f);
                  }
                }
              } catch {
                yield this.disconnect();
              }
            });
          }
          addListener(s) {
            var o, c;
            for (let u in this.providerMap) (o = this.providerMap.get(u)) === null || o === void 0 || o.removeListener();
            (c = this.getInjectProvider(s)) === null || c === void 0 || c.addAccountChangedListener(u => {
              u ? this.checkAccountChanged(s, u).catch(f => {}) : this.onDisconnect();
            });
          }
          supportNamespaceAndChains(s, o) {
            let c = this.providerMap.get(s);
            return c ? c.supportChains(o) : !1;
          }
        }
        return Os.ThirdpartInjectConnector = a, Os;
      }
      var lb;
      function h2() {
        return lb || (lb = 1, function (n) {
          var e = vs && vs.__createBinding || (Object.create ? function (u, f, d, p) {
              p === void 0 && (p = d);
              var v = Object.getOwnPropertyDescriptor(f, d);
              (!v || ("get" in v ? !f.__esModule : v.writable || v.configurable)) && (v = {
                enumerable: !0,
                get: function () {
                  return f[d];
                }
              }), Object.defineProperty(u, p, v);
            } : function (u, f, d, p) {
              p === void 0 && (p = d), u[p] = f[d];
            }),
            t = vs && vs.__exportStar || function (u, f) {
              for (var d in u) d !== "default" && !Object.prototype.hasOwnProperty.call(f, d) && e(f, u, d);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.ThirdpartInjectConnector = n.OkxwalletInjectTonsdkConnector = n.OkxwalletInjectConnector = n.WsConnector = n.TgwalletConnector = n.InjectConnector = n.AppwalletConnector = void 0;
          var r = r2();
          Object.defineProperty(n, "AppwalletConnector", {
            enumerable: !0,
            get: function () {
              return r.AppwalletConnector;
            }
          }), t(qi(), n);
          var i = Md();
          Object.defineProperty(n, "InjectConnector", {
            enumerable: !0,
            get: function () {
              return i.InjectConnector;
            }
          });
          var a = i2();
          Object.defineProperty(n, "TgwalletConnector", {
            enumerable: !0,
            get: function () {
              return a.TgwalletConnector;
            }
          });
          var l = kd();
          Object.defineProperty(n, "WsConnector", {
            enumerable: !0,
            get: function () {
              return l.WsConnector;
            }
          });
          var s = sb();
          Object.defineProperty(n, "OkxwalletInjectConnector", {
            enumerable: !0,
            get: function () {
              return s.OkxwalletInjectConnector;
            }
          });
          var o = f2();
          Object.defineProperty(n, "OkxwalletInjectTonsdkConnector", {
            enumerable: !0,
            get: function () {
              return o.OkxwalletInjectTonsdkConnector;
            }
          });
          var c = d2();
          Object.defineProperty(n, "ThirdpartInjectConnector", {
            enumerable: !0,
            get: function () {
              return c.ThirdpartInjectConnector;
            }
          });
        }(vs)), vs;
      }
      var ub;
      function zt() {
        return ub || (ub = 1, function (n) {
          var e = Wo && Wo.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = Wo && Wo.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(XA(), n), t(Jt(), n), t(tn(), n), t(Jm(), n), t(h2(), n);
        }(Wo)), Wo;
      }
      var As = {},
        Rs = {},
        Sr = {},
        fb;
      function p2() {
        if (fb) return Sr;
        fb = 1, Object.defineProperty(Sr, "__esModule", {
          value: !0
        }), Sr.getRpcUrl = e, Sr.getChainId = t, Sr.fromAccountToAddress = r, Sr.convertChainIdToNumber = i, Sr.parseChainId = l, Sr.mergeArrays = s, Sr.syncAddressAvailable = o, Sr.syncAddressHostAvailable = c;
        const n = zt();
        function e(u, f, d) {
          var p;
          const v = l(u);
          return ((p = f.rpcMap) === null || p === void 0 ? void 0 : p[v.reference]) || "";
        }
        function t(u) {
          return u.includes(":") ? u.split(":")[1] : u;
        }
        function r(u) {
          if (!u) return "";
          try {
            let f = u.split(":").slice(2),
              d = f.length > 0 ? f.join(":") : "";
            return (0, n.logDebug)("fromAccountToAddress address and account:", d, u), d;
          } catch {
            return (0, n.logError)("fromAccountToAddress error:", u), "";
          }
        }
        function i(u) {
          return typeof u == "number" ? u : u.includes("0x") ? parseInt(u, 16) : (u = u.includes(":") ? u.split(":")[1] : u, isNaN(Number(u)) ? u : Number(u));
        }
        const a = ":";
        function l(u) {
          const [f, d] = u.split(a);
          return {
            namespace: f,
            reference: d
          };
        }
        function s(u = [], f = []) {
          return [...new Set([...u, ...f])];
        }
        function o(u) {
          return !u || u.appName !== "OKX Wallet" || (0, n.versionCompare)("6.97.0", u.appVersion) > 0 ? !1 : c();
        }
        function c() {
          try {
            return !!window.okxGlobal;
          } catch {
            return !1;
          }
        }
        return Sr;
      }
      var Ns = {},
        db;
      function g2() {
        if (db) return Ns;
        db = 1, Object.defineProperty(Ns, "__esModule", {
          value: !0
        }), Ns.setGlobal = Ns.getGlobal = void 0;
        const n = {},
          e = r => n[r];
        Ns.getGlobal = e;
        const t = (r, i) => {
          n[r] = i;
        };
        return Ns.setGlobal = t, Ns;
      }
      var hb;
      function Tr() {
        return hb || (hb = 1, function (n) {
          var e = Rs && Rs.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = Rs && Rs.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(p2(), n), t(g2(), n);
        }(Rs)), Rs;
      }
      var pb;
      function gb() {
        return pb || (pb = 1, function (n) {
          var e = As && As.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = As && As.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(Y0(), n), t(Tr(), n);
        }(As)), As;
      }
      var vb;
      function yb() {
        return vb || (vb = 1, function (n) {
          var e = jo && jo.__awaiter || function (h, g, b, m) {
              function _(N) {
                return N instanceof b ? N : new b(function (O) {
                  O(N);
                });
              }
              return new (b || (b = Promise))(function (N, O) {
                function y(R) {
                  try {
                    A(m.next(R));
                  } catch (T) {
                    O(T);
                  }
                }
                function w(R) {
                  try {
                    A(m.throw(R));
                  } catch (T) {
                    O(T);
                  }
                }
                function A(R) {
                  R.done ? N(R.value) : _(R.value).then(y, w);
                }
                A((m = m.apply(h, g || [])).next());
              });
            },
            t = jo && jo.__importDefault || function (h) {
              return h && h.__esModule ? h : {
                default: h
              };
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.connectSupportMethods = void 0, n.creatNotSupportMethodItemReplay = o, n.isMobileDiscover = c, n.connectMethodsAdaptOldVersion = u, n.connectMethodsResponseUpdate = f, n.connectMethodsToConnectWalletMethods = d, n.syncResoonseToRequire = v;
          const r = zt(),
            i = t(Zm()),
            a = gb();
          function l(h) {
            return typeof h == "object" && h !== null && Array.isArray(h);
          }
          function s(h) {
            return typeof h == "object" && h !== null && !Array.isArray(h);
          }
          n.connectSupportMethods = Object.freeze(["personal_sign", "sui_signMessage", "sui_signPersonalMessage", "btc_signMessage", "aptos_signMessage", "cosmos_signArbitrary", "tron_signMessage", "tron_signMessageV2", "starknet_signMessage", "sync_all_addresses"]);
          function o(h) {
            let g = new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
            var b = {
              method: h.method,
              chainId: h.chainId,
              error: {
                code: g.code,
                message: g.message
              }
            };
            return b;
          }
          function c() {
            return !!window.okxwallet && window.okxwallet.mobileDiscoverWallet;
          }
          function u(h, g) {
            return e(this, void 0, void 0, function* () {
              var b, m, _, N, O;
              try {
                (0, r.logDebug)("connectMethodsAdaptOldVersion start params :", JSON.stringify(h));
                let w = {};
                if (h.method === "solana_signMessage") {
                  let A = (b = g.namespaces[r.NameSpaceKeySOL]) === null || b === void 0 ? void 0 : b.accounts.filter(function (T) {
                    return T.startsWith(h.chainId);
                  })[0];
                  const R = (0, a.fromAccountToAddress)(A);
                  if (h.params && R && "message" in h.params) {
                    let T = h.params.message;
                    if (((m = g.wallet) === null || m === void 0 ? void 0 : m.appName) == "OKX Wallet") {
                      let D = new TextEncoder().encode(T);
                      T = i.default.encode(D);
                    }
                    return h.params = {
                      message: T,
                      pubkey: R
                    }, h.injectParams = h.params, w = {
                      publicKey: R
                    }, (0, r.logDebug)("solana_signMessage account and address:", JSON.stringify(A), R), (0, r.logDebug)("solana_signMessage callBackParams:", JSON.stringify(w)), w;
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                } else if (h.method === "sui_signMessage" || h.method === "sui_signPersonalMessage") {
                  if ("message" in h.params && h.params.message) {
                    let A = JSON.parse(JSON.stringify(h.params.message)),
                      R = Object.values(A),
                      T = new Uint8Array(R),
                      D = new TextDecoder("utf8"),
                      M = btoa(D.decode(T));
                    return h.params = {
                      message: atob(M)
                    }, h.injectParams = {
                      message: T
                    }, console.log("sui_signMessag suiMessagee suiMessageb64:>>>>", JSON.stringify(h.params), M), h.method === "sui_signMessage" ? w = {
                      messageBytes: M,
                      signature: ""
                    } : h.method === "sui_signPersonalMessage" && (w = {
                      bytes: M,
                      signature: ""
                    }), (0, r.logDebug)("sui_signMessage/sui_signPersonalMessage callBackParams:", JSON.stringify(w)), w;
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                } else if (h.method === "btc_signMessage") {
                  let R = ((_ = g.namespaces[r.NameSpaceKeyBtc]) === null || _ === void 0 ? void 0 : _.accounts.filter(function (D) {
                    return D.startsWith(h.chainId);
                  }))[0];
                  const T = (0, a.fromAccountToAddress)(R);
                  if ((0, r.logDebug)("btc_signMessage account and address:", JSON.stringify(R), T), T) {
                    if ("message" in h.params && h.params.message && typeof h.params.message == "string") h.params = {
                      from: T,
                      signStr: h.params.message
                    };else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                    return h.params.from = T, (0, r.logDebug)("btc_signMessage callBackParams:", JSON.stringify(w)), w;
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                } else if (h.method === "aptos_signMessage") {
                  let A = h.params,
                    R = (N = g.namespaces[r.NameSpaceKeyAptos]) === null || N === void 0 ? void 0 : N.accounts.filter(function (D) {
                      return D.startsWith(h.chainId);
                    })[0],
                    T = (0, a.fromAccountToAddress)(R);
                  if (A && T) {
                    let D = "APTOS",
                      M = "",
                      q = "";
                    var y = D;
                    let W = window.location.protocol + "//" + window.location.hostname;
                    "address" in A && A.address && (y += `
address: ` + T), "application" in A && A.application && (y += `
application: ` + W);
                    let x = 1;
                    "chainId" in A && A.chainId && (A.chainId == "aptos:mainnet" ? x = 1 : A.chainId == "movement:testnet" && (x = 2), y += `
chainId: ` + x), "message" in A && (y += `
message: ` + A.message, M = A.message), "nonce" in A && (y += `
nonce: ` + A.nonce, q = A.nonce);
                    const C = new TextEncoder().encode(y),
                      B = Array.from(C).map(X => X.toString(16).padStart(2, "0")).join("");
                    return h.params = {
                      message: B
                    }, h.injectParams = A, (0, r.logDebug)("aptos_signMessage requestParams:", JSON.stringify(h)), w = {
                      address: T,
                      application: W,
                      chainId: x,
                      fullMessage: y,
                      message: M,
                      nonce: q,
                      prefix: D,
                      signature: ""
                    }, (0, r.logDebug)("aptos_signMessage callBackParams:", JSON.stringify(w)), w;
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                } else if (h.method === "cosmos_signArbitrary") {
                  let A = (O = g == null ? void 0 : g.namespaces[r.NameSpaceKeyCosmos]) === null || O === void 0 ? void 0 : O.accounts.filter(function (M) {
                    return M.startsWith(h.chainId);
                  })[0];
                  const R = (0, a.fromAccountToAddress)(A);
                  let T = h.params.message;
                  const D = btoa(T);
                  if ((0, r.logDebug)("cosmos_signArbitrary account and address:", JSON.stringify(A), R), (0, r.logDebug)("cosmos_signArbitrary cosmosBase64Encoded:", D), T && R) {
                    const M = {
                      chain_id: "",
                      account_number: "0",
                      sequence: "0",
                      fee: {
                        gas: "0",
                        amount: []
                      },
                      msgs: [{
                        type: "sign/MsgSignData",
                        value: {
                          signer: R,
                          data: D
                        }
                      }],
                      memo: ""
                    };
                    return h.params = {
                      signer: R,
                      chain_id: h.chainId.split(":")[1],
                      data: M
                    }, (0, r.logDebug)("cosmos_signArbitrary callBackParams:", JSON.stringify(w)), w;
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                }
                (0, r.logDebug)("sol_handleSignatureData end params:", JSON.stringify(h));
              } catch (w) {
                throw w;
              }
            });
          }
          function f(h, g) {
            return e(this, void 0, void 0, function* () {
              var b;
              try {
                if (h.signResponse) {
                  (0, r.logDebug)("connectMethodsResponseUpdate signResponse:", JSON.stringify(h.signResponse)), (0, r.logDebug)("connectMethodsResponseUpdate session.namespaces:", JSON.stringify(h.namespaces));
                  for (const m of h.signResponse) if ((0, r.logDebug)("connectMethodsResponseUpdate methodItem:", JSON.stringify(m)), "result" in m) if (m.method === "solana_signMessage") {
                    let _ = m.result;
                    (0, r.logDebug)("solana_signMessage methodItem.chainId:", m.chainId);
                    let N = (b = h.namespaces[r.NameSpaceKeySOL]) === null || b === void 0 ? void 0 : b.accounts.filter(function (O) {
                      return (0, r.logDebug)("solana_signMessage account:", O), O.startsWith(m.chainId);
                    })[0];
                    (0, r.logDebug)("solana_signMessage result account:", _, N), _ && N && (m.result = {
                      signature: i.default.decode(_),
                      publicKey: (0, a.fromAccountToAddress)(N)
                    });
                  } else if (m.method === "sui_signMessage" || m.method === "sui_signPersonalMessage") {
                    let _ = g.filter(function (N) {
                      return N.method === m.method;
                    })[0];
                    if (_ && _.params && "message" in _.params) {
                      let N = _.params.message,
                        O = btoa(N);
                      console.log("sui_signMessag suiMessagee suiMessageb64:>>>>", N, O), m.method === "sui_signMessage" ? m.result = {
                        messageBytes: O,
                        signature: m.result
                      } : m.method === "sui_signPersonalMessage" && (m.result = {
                        bytes: O,
                        signature: m.result
                      });
                    }
                  } else if (m.method === "aptos_signMessage") {
                    if (m.chainId = (0, r.replaceChainIdToChainName)(m.chainId), m.result = JSON.parse(m.result), console.log("aptos_signMessage result methodItem.result before:>>>>", JSON.stringify(m.result)), m.result && "signature" in m.result) {
                      let _ = m.result.signature;
                      _ && _.startsWith("0x") && (_ = _.slice(2, _.length), m.result.signature = _);
                    }
                    console.log("aptos_signMessage result methodItem.result after:>>>>", JSON.stringify(m.result));
                  } else if (m.method === "cosmos_signArbitrary") m.result = JSON.parse(m.result);else if (m.method == "starknet_signMessage") {
                    let _ = m.result;
                    typeof _ == "string" && (_ = JSON.parse(_)), m.result = [_.signedDataR, _.signedDataS];
                  } else m.method == "sync_all_addresses" && (m.result = v(m.result));
                }
              } catch (m) {
                throw (0, r.logDebug)("connectMethodsResponseUpdate signResponse Error:", JSON.stringify(m)), m;
              }
            });
          }
          function d(h, g) {
            return e(this, void 0, void 0, function* () {
              try {
                (0, r.logDebug)("connectMethodsToConnectWalletMethods requestMethods:", JSON.stringify(h));
                const N = [];
                if (h && h.length > 1) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "connectAndSign/openModalAndSign signRequest only support one data");
                if (!g && h && h.length > 0) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Connect request params error , RequestMethods cannot be added when the NameSpace is empty");
                for (const O of h) if (O.method === "aptos_signMessage" && (O.chainId = (0, r.replaceChainNameToChainId)(O.chainId)), O.method === "wallet_addEthereumChain") {
                  var b = g == null ? void 0 : g.some(y => y.namespace.includes("eip155"));
                  if (!b) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Connect request params error, When using '${O.method}', the EVM chain needs to be included in the NameSpace`);
                } else if (O.method === "sync_all_addresses") {
                  if ((0, a.syncAddressHostAvailable)()) O.chainId = "";else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
                } else if (!!!(g != null && g.some(w => w.chains.some(A => A.includes(`${O.chainId}`))))) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Connect request params error, When using '${O.method}', NameSpace must contain '${O.chainId}'`);
                for (const O of h) {
                  if (!n.connectSupportMethods.includes(O.method)) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect requestMethods not support method, method: '${O.method}'`);
                  if (O.method === "wallet_addEthereumChain") {
                    if (Array.isArray(O.params)) {
                      const y = O.params;
                      if (y && y.length === 1) {
                        const w = y[0];
                        s(w) && (O.params = w);
                      } else throw y && y.length > 1 ? new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params only support one data, method: '${O.method}'`) : new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is nil, method: '${O.method}'`);
                    }
                  } else if (O.method === "personal_sign") {
                    if (l(O.params)) {
                      if (O.params && O.params.length !== 1) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params error,  method: '${O.method}' `);
                      let y = O.params[0];
                      if (y && typeof y == "string") O.params = {
                        message: y
                      };else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                    }
                  } else if (O.method === "sui_signMessage" || O.method === "sui_signPersonalMessage") {
                    if (s(O.params) && "message" in O.params) {
                      if (O.params.message) {
                        (0, r.logDebug)("sui_signMessage item.params.message :", O.params.message);
                        let y = JSON.parse(JSON.stringify(O.params.message)),
                          w = Object.values(y),
                          A = new Uint8Array(w),
                          R = new TextDecoder("utf8"),
                          T = btoa(R.decode(A));
                        O.params.message = atob(T);
                      } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                    } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else if (O.method === "solana_signMessage") {
                    if (s(O.params) && "message" in O.params) {
                      if (O.params.message && typeof O.params.message == "string") {
                        let y = new TextEncoder().encode(O.params.message);
                        O.params.bs58Message = i.default.encode(y);
                      } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                    } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else if (O.method === "aptos_signMessage") {
                    if (s(O.params)) {
                      if (O.chainId) {
                        var m = O.params,
                          _ = window.location.protocol + "//" + window.location.hostname;
                        let y = 1;
                        O.chainId === "aptos:637" || O.chainId === "aptos:70000060" && (y = 2), O.params = {
                          data: m,
                          applicationUrl: _,
                          prefix: "APTOS",
                          aptosChainId: y
                        };
                      } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params chainId is error,  method: '${O.method}' `);
                    } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else if (O.method === "cosmos_signArbitrary") {
                    if (s(O.params)) {
                      if (O.params.message && typeof O.params.message == "string") {
                        const y = btoa(O.params.message);
                        let w = O.chainId.split(":")[1];
                        if (w) O.params = {
                          chain_id: w,
                          data: {
                            chain_id: "",
                            account_number: "0",
                            sequence: "0",
                            fee: {
                              gas: "0",
                              amount: []
                            },
                            msgs: [{
                              type: "sign/MsgSignData",
                              value: {
                                signer: "",
                                data: y
                              }
                            }],
                            memo: ""
                          }
                        };else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params chainId is error,  method: '${O.method}' `);
                      } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params message is error,  method: '${O.method}' `);
                    } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else if (O.method == "tron_signMessage") {
                    if (s(O.params)) {
                      if ("message" in O.params && O.params.message && typeof O.params.message == "string") O.params.message = p(O.params.message);else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                    } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else if (O.method == "btc_signMessage") if (s(O.params)) {
                    if ("message" in O.params && O.params.message && typeof O.params.message == "string") O.params = {
                      signStr: O.params.message
                    };else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `connect request params is error,  method: '${O.method}' `);
                  (0, r.logDebug)("connectMethodsToConnectWalletMethods item:", JSON.stringify(O)), N.push(O);
                }
                return N;
              } catch (N) {
                throw N;
              }
            });
          }
          function p(h) {
            let g = "";
            for (let b = 0; b < h.length; b++) g += h.charCodeAt(b).toString(16).padStart(2, "0");
            return g;
          }
          function v(h) {
            const g = JSON.parse(h);
            return {
              type: g.type,
              isEvm: g.isEvm,
              walletName: g.walletName,
              deriveName: g.deriveName,
              addresses: g.addresses.map(m => ({
                coinId: m.ci,
                address: m.a && m.a !== "null" ? m.a : g.evmAddress
              }))
            };
          }
        }(jo)), jo;
      }
      var mb;
      function v2() {
        return mb || (mb = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.isMobileDiscover = n.creatNotSupportMethodItemReplay = n.connectMethodsAdaptOldVersion = void 0;
          var e = yb();
          Object.defineProperty(n, "connectMethodsAdaptOldVersion", {
            enumerable: !0,
            get: function () {
              return e.connectMethodsAdaptOldVersion;
            }
          }), Object.defineProperty(n, "creatNotSupportMethodItemReplay", {
            enumerable: !0,
            get: function () {
              return e.creatNotSupportMethodItemReplay;
            }
          }), Object.defineProperty(n, "isMobileDiscover", {
            enumerable: !0,
            get: function () {
              return e.isMobileDiscover;
            }
          });
        }(Z0)), Z0;
      }
      var bb;
      function Ud() {
        return bb || (bb = 1, function (n) {
          var e = Ho && Ho.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = Ho && Ho.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(v2(), n);
        }(Ho)), Ho;
      }
      var Xr = {},
        Gi = {},
        Ss = {},
        Fd = {},
        wb;
      function y2() {
        return wb || (wb = 1, function (n) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.GENERIC_SUBPROVIDER_NAME = n.RPC_URL = n.STORAGE = n.CONTEXT = n.WC_VERSION = n.PROTOCOL = n.RELAY_URL = n.LOGGER = void 0, n.LOGGER = "error", n.RELAY_URL = "wss://relay.walletconnect.com", n.PROTOCOL = "wc", n.WC_VERSION = 2, n.CONTEXT = "universal_provider", n.STORAGE = `${n.PROTOCOL}@${n.WC_VERSION}:${n.CONTEXT}:`, n.RPC_URL = "https://rpc.walletconnect.com/v1/", n.GENERIC_SUBPROVIDER_NAME = "generic";
        }(Fd)), Fd;
      }
      var yl = {},
        xb;
      function m2() {
        return xb || (xb = 1, Object.defineProperty(yl, "__esModule", {
          value: !0
        }), yl.PROVIDER_EVENTS = void 0, yl.PROVIDER_EVENTS = {
          DEFAULT_CHAIN_CHANGED: "default_chain_changed",
          UPDATE_NAMESPACES: "update_name_spaces",
          SESSION_CONNECTING: "session_connecting"
        }), yl;
      }
      var _b;
      function Dr() {
        return _b || (_b = 1, function (n) {
          var e = Ss && Ss.__createBinding || (Object.create ? function (r, i, a, l) {
              l === void 0 && (l = a);
              var s = Object.getOwnPropertyDescriptor(i, a);
              (!s || ("get" in s ? !i.__esModule : s.writable || s.configurable)) && (s = {
                enumerable: !0,
                get: function () {
                  return i[a];
                }
              }), Object.defineProperty(r, l, s);
            } : function (r, i, a, l) {
              l === void 0 && (l = a), r[l] = i[a];
            }),
            t = Ss && Ss.__exportStar || function (r, i) {
              for (var a in r) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && e(i, r, a);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), t(y2(), n), t(m2(), n);
        }(Ss)), Ss;
      }
      var Ts = {},
        Eb;
      function vi() {
        if (Eb) return Ts;
        Eb = 1;
        var n = Ts && Ts.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(Ts, "__esModule", {
          value: !0
        }), Ts.JsonRpcProvider = void 0;
        const e = Wi(),
          t = Y0(),
          r = zt(),
          i = zt();
        let a = class extends t.IJSONRpcProvider {
          constructor(s) {
            super(s), this.events = new e.EventEmitter(), this.connected = !1, this.connecting = !1, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(s), this.connection.connected && this.registerEventListeners();
          }
          connect() {
            return n(this, arguments, void 0, function* (s = this.connection) {
              yield this.open(s);
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              yield this.close();
            });
          }
          on(s, o) {
            this.events.on(s, o);
          }
          once(s, o) {
            this.events.once(s, o);
          }
          off(s, o) {
            this.events.off(s, o);
          }
          removeListener(s, o) {
            this.events.removeListener(s, o);
          }
          request(s, o) {
            return n(this, void 0, void 0, function* () {
              return this.requestStrict((0, r.formatJsonRpcRequest)(s.method, s.params || [], (0, r.getBigIntRpcId)().toString()), o);
            });
          }
          requestStrict(s, o) {
            return n(this, void 0, void 0, function* () {
              return new Promise((c, u) => n(this, void 0, void 0, function* () {
                if (!this.connection.connected) try {
                  yield this.open();
                } catch (f) {
                  u(f);
                }
                this.events.on(`${s.id}`, f => {
                  (0, r.isJsonRpcError)(f) ? u(f.error) : c(f.result);
                });
                try {
                  (0, i.logDebug)("[RPC] >>> send request", s, o), yield this.connection.send(s, o);
                } catch (f) {
                  u(f);
                }
              }));
            });
          }
          setConnection(s = this.connection) {
            return s;
          }
          onPayload(s) {
            this.events.emit("payload", s), (0, r.isJsonRpcResponse)(s) ? this.events.emit(`${s.id}`, s) : this.events.emit("message", {
              type: s.method,
              data: s.params
            });
          }
          onClose(s) {
            s && s.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${s.code} ${s.reason ? `(${s.reason})` : ""}`)), this.events.emit("disconnect");
          }
          open() {
            return n(this, arguments, void 0, function* (s = this.connection) {
              this.connection === s && this.connection.connected || (this.connection.connected && this.close(), typeof s == "string" && (yield this.connection.open(s), s = this.connection), this.connection = this.setConnection(s), yield this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
            });
          }
          close() {
            return n(this, void 0, void 0, function* () {
              yield this.connection.close();
            });
          }
          registerEventListeners() {
            this.hasRegisteredEventListeners || (this.connection.on("payload", s => this.onPayload(s)), this.connection.on("close", s => this.onClose(s)), this.connection.on("error", s => this.events.emit("error", s)), this.connection.on("register_error", s => this.onClose()), this.hasRegisteredEventListeners = !0);
          }
        };
        return Ts.JsonRpcProvider = a, Ts;
      }
      var yi = {},
        xf = {
          exports: {}
        },
        Cb;
      function b2() {
        return Cb || (Cb = 1, function (n, e) {
          var t = typeof globalThis != "undefined" && globalThis || typeof self != "undefined" && self || typeof qt != "undefined" && qt,
            r = function () {
              function a() {
                this.fetch = !1, this.DOMException = t.DOMException;
              }
              return a.prototype = t, new a();
            }();
          (function (a) {
            (function (l) {
              var s = typeof a != "undefined" && a || typeof self != "undefined" && self || typeof qt != "undefined" && qt || {},
                o = {
                  searchParams: "URLSearchParams" in s,
                  iterable: "Symbol" in s && "iterator" in Symbol,
                  blob: "FileReader" in s && "Blob" in s && function () {
                    try {
                      return new Blob(), !0;
                    } catch {
                      return !1;
                    }
                  }(),
                  formData: "FormData" in s,
                  arrayBuffer: "ArrayBuffer" in s
                };
              function c(x) {
                return x && DataView.prototype.isPrototypeOf(x);
              }
              if (o.arrayBuffer) var u = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                f = ArrayBuffer.isView || function (x) {
                  return x && u.indexOf(Object.prototype.toString.call(x)) > -1;
                };
              function d(x) {
                if (typeof x != "string" && (x = String(x)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(x) || x === "") throw new TypeError('Invalid character in header field name: "' + x + '"');
                return x.toLowerCase();
              }
              function p(x) {
                return typeof x != "string" && (x = String(x)), x;
              }
              function v(x) {
                var C = {
                  next: function () {
                    var B = x.shift();
                    return {
                      done: B === void 0,
                      value: B
                    };
                  }
                };
                return o.iterable && (C[Symbol.iterator] = function () {
                  return C;
                }), C;
              }
              function h(x) {
                this.map = {}, x instanceof h ? x.forEach(function (C, B) {
                  this.append(B, C);
                }, this) : Array.isArray(x) ? x.forEach(function (C) {
                  if (C.length != 2) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + C.length);
                  this.append(C[0], C[1]);
                }, this) : x && Object.getOwnPropertyNames(x).forEach(function (C) {
                  this.append(C, x[C]);
                }, this);
              }
              h.prototype.append = function (x, C) {
                x = d(x), C = p(C);
                var B = this.map[x];
                this.map[x] = B ? B + ", " + C : C;
              }, h.prototype.delete = function (x) {
                delete this.map[d(x)];
              }, h.prototype.get = function (x) {
                return x = d(x), this.has(x) ? this.map[x] : null;
              }, h.prototype.has = function (x) {
                return this.map.hasOwnProperty(d(x));
              }, h.prototype.set = function (x, C) {
                this.map[d(x)] = p(C);
              }, h.prototype.forEach = function (x, C) {
                for (var B in this.map) this.map.hasOwnProperty(B) && x.call(C, this.map[B], B, this);
              }, h.prototype.keys = function () {
                var x = [];
                return this.forEach(function (C, B) {
                  x.push(B);
                }), v(x);
              }, h.prototype.values = function () {
                var x = [];
                return this.forEach(function (C) {
                  x.push(C);
                }), v(x);
              }, h.prototype.entries = function () {
                var x = [];
                return this.forEach(function (C, B) {
                  x.push([B, C]);
                }), v(x);
              }, o.iterable && (h.prototype[Symbol.iterator] = h.prototype.entries);
              function g(x) {
                if (!x._noBody) {
                  if (x.bodyUsed) return Promise.reject(new TypeError("Already read"));
                  x.bodyUsed = !0;
                }
              }
              function b(x) {
                return new Promise(function (C, B) {
                  x.onload = function () {
                    C(x.result);
                  }, x.onerror = function () {
                    B(x.error);
                  };
                });
              }
              function m(x) {
                var C = new FileReader(),
                  B = b(C);
                return C.readAsArrayBuffer(x), B;
              }
              function _(x) {
                var C = new FileReader(),
                  B = b(C),
                  X = /charset=([A-Za-z0-9_-]+)/.exec(x.type),
                  J = X ? X[1] : "utf-8";
                return C.readAsText(x, J), B;
              }
              function N(x) {
                for (var C = new Uint8Array(x), B = new Array(C.length), X = 0; X < C.length; X++) B[X] = String.fromCharCode(C[X]);
                return B.join("");
              }
              function O(x) {
                if (x.slice) return x.slice(0);
                var C = new Uint8Array(x.byteLength);
                return C.set(new Uint8Array(x)), C.buffer;
              }
              function y() {
                return this.bodyUsed = !1, this._initBody = function (x) {
                  this.bodyUsed = this.bodyUsed, this._bodyInit = x, x ? typeof x == "string" ? this._bodyText = x : o.blob && Blob.prototype.isPrototypeOf(x) ? this._bodyBlob = x : o.formData && FormData.prototype.isPrototypeOf(x) ? this._bodyFormData = x : o.searchParams && URLSearchParams.prototype.isPrototypeOf(x) ? this._bodyText = x.toString() : o.arrayBuffer && o.blob && c(x) ? (this._bodyArrayBuffer = O(x.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(x) || f(x)) ? this._bodyArrayBuffer = O(x) : this._bodyText = x = Object.prototype.toString.call(x) : (this._noBody = !0, this._bodyText = ""), this.headers.get("content-type") || (typeof x == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o.searchParams && URLSearchParams.prototype.isPrototypeOf(x) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
                }, o.blob && (this.blob = function () {
                  var x = g(this);
                  if (x) return x;
                  if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                  if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                  if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                  return Promise.resolve(new Blob([this._bodyText]));
                }), this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var x = g(this);
                    return x || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer));
                  } else {
                    if (o.blob) return this.blob().then(m);
                    throw new Error("could not read as ArrayBuffer");
                  }
                }, this.text = function () {
                  var x = g(this);
                  if (x) return x;
                  if (this._bodyBlob) return _(this._bodyBlob);
                  if (this._bodyArrayBuffer) return Promise.resolve(N(this._bodyArrayBuffer));
                  if (this._bodyFormData) throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }, o.formData && (this.formData = function () {
                  return this.text().then(T);
                }), this.json = function () {
                  return this.text().then(JSON.parse);
                }, this;
              }
              var w = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
              function A(x) {
                var C = x.toUpperCase();
                return w.indexOf(C) > -1 ? C : x;
              }
              function R(x, C) {
                if (!(this instanceof R)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                C = C || {};
                var B = C.body;
                if (x instanceof R) {
                  if (x.bodyUsed) throw new TypeError("Already read");
                  this.url = x.url, this.credentials = x.credentials, C.headers || (this.headers = new h(x.headers)), this.method = x.method, this.mode = x.mode, this.signal = x.signal, !B && x._bodyInit != null && (B = x._bodyInit, x.bodyUsed = !0);
                } else this.url = String(x);
                if (this.credentials = C.credentials || this.credentials || "same-origin", (C.headers || !this.headers) && (this.headers = new h(C.headers)), this.method = A(C.method || this.method || "GET"), this.mode = C.mode || this.mode || null, this.signal = C.signal || this.signal || function () {
                  if ("AbortController" in s) {
                    var V = new AbortController();
                    return V.signal;
                  }
                }(), this.referrer = null, (this.method === "GET" || this.method === "HEAD") && B) throw new TypeError("Body not allowed for GET or HEAD requests");
                if (this._initBody(B), (this.method === "GET" || this.method === "HEAD") && (C.cache === "no-store" || C.cache === "no-cache")) {
                  var X = /([?&])_=[^&]*/;
                  if (X.test(this.url)) this.url = this.url.replace(X, "$1_=" + new Date().getTime());else {
                    var J = /\?/;
                    this.url += (J.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
                  }
                }
              }
              R.prototype.clone = function () {
                return new R(this, {
                  body: this._bodyInit
                });
              };
              function T(x) {
                var C = new FormData();
                return x.trim().split("&").forEach(function (B) {
                  if (B) {
                    var X = B.split("="),
                      J = X.shift().replace(/\+/g, " "),
                      V = X.join("=").replace(/\+/g, " ");
                    C.append(decodeURIComponent(J), decodeURIComponent(V));
                  }
                }), C;
              }
              function D(x) {
                var C = new h(),
                  B = x.replace(/\r?\n[\t ]+/g, " ");
                return B.split("\r").map(function (X) {
                  return X.indexOf(`
`) === 0 ? X.substr(1, X.length) : X;
                }).forEach(function (X) {
                  var J = X.split(":"),
                    V = J.shift().trim();
                  if (V) {
                    var $ = J.join(":").trim();
                    try {
                      C.append(V, $);
                    } catch (se) {
                      console.warn("Response " + se.message);
                    }
                  }
                }), C;
              }
              y.call(R.prototype);
              function M(x, C) {
                if (!(this instanceof M)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                if (C || (C = {}), this.type = "default", this.status = C.status === void 0 ? 200 : C.status, this.status < 200 || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                this.ok = this.status >= 200 && this.status < 300, this.statusText = C.statusText === void 0 ? "" : "" + C.statusText, this.headers = new h(C.headers), this.url = C.url || "", this._initBody(x);
              }
              y.call(M.prototype), M.prototype.clone = function () {
                return new M(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new h(this.headers),
                  url: this.url
                });
              }, M.error = function () {
                var x = new M(null, {
                  status: 200,
                  statusText: ""
                });
                return x.ok = !1, x.status = 0, x.type = "error", x;
              };
              var q = [301, 302, 303, 307, 308];
              M.redirect = function (x, C) {
                if (q.indexOf(C) === -1) throw new RangeError("Invalid status code");
                return new M(null, {
                  status: C,
                  headers: {
                    location: x
                  }
                });
              }, l.DOMException = s.DOMException;
              try {
                new l.DOMException();
              } catch {
                l.DOMException = function (C, B) {
                  this.message = C, this.name = B;
                  var X = Error(C);
                  this.stack = X.stack;
                }, l.DOMException.prototype = Object.create(Error.prototype), l.DOMException.prototype.constructor = l.DOMException;
              }
              function W(x, C) {
                return new Promise(function (B, X) {
                  var J = new R(x, C);
                  if (J.signal && J.signal.aborted) return X(new l.DOMException("Aborted", "AbortError"));
                  var V = new XMLHttpRequest();
                  function $() {
                    V.abort();
                  }
                  V.onload = function () {
                    var oe = {
                      statusText: V.statusText,
                      headers: D(V.getAllResponseHeaders() || "")
                    };
                    J.url.indexOf("file://") === 0 && (V.status < 200 || V.status > 599) ? oe.status = 200 : oe.status = V.status, oe.url = "responseURL" in V ? V.responseURL : oe.headers.get("X-Request-URL");
                    var ye = "response" in V ? V.response : V.responseText;
                    setTimeout(function () {
                      B(new M(ye, oe));
                    }, 0);
                  }, V.onerror = function () {
                    setTimeout(function () {
                      X(new TypeError("Network request failed"));
                    }, 0);
                  }, V.ontimeout = function () {
                    setTimeout(function () {
                      X(new TypeError("Network request timed out"));
                    }, 0);
                  }, V.onabort = function () {
                    setTimeout(function () {
                      X(new l.DOMException("Aborted", "AbortError"));
                    }, 0);
                  };
                  function se(oe) {
                    try {
                      return oe === "" && s.location.href ? s.location.href : oe;
                    } catch {
                      return oe;
                    }
                  }
                  if (V.open(J.method, se(J.url), !0), J.credentials === "include" ? V.withCredentials = !0 : J.credentials === "omit" && (V.withCredentials = !1), "responseType" in V && (o.blob ? V.responseType = "blob" : o.arrayBuffer && (V.responseType = "arraybuffer")), C && typeof C.headers == "object" && !(C.headers instanceof h || s.Headers && C.headers instanceof s.Headers)) {
                    var ne = [];
                    Object.getOwnPropertyNames(C.headers).forEach(function (oe) {
                      ne.push(d(oe)), V.setRequestHeader(oe, p(C.headers[oe]));
                    }), J.headers.forEach(function (oe, ye) {
                      ne.indexOf(ye) === -1 && V.setRequestHeader(ye, oe);
                    });
                  } else J.headers.forEach(function (oe, ye) {
                    V.setRequestHeader(ye, oe);
                  });
                  J.signal && (J.signal.addEventListener("abort", $), V.onreadystatechange = function () {
                    V.readyState === 4 && J.signal.removeEventListener("abort", $);
                  }), V.send(typeof J._bodyInit == "undefined" ? null : J._bodyInit);
                });
              }
              return W.polyfill = !0, s.fetch || (s.fetch = W, s.Headers = h, s.Request = R, s.Response = M), l.Headers = h, l.Request = R, l.Response = M, l.fetch = W, Object.defineProperty(l, "__esModule", {
                value: !0
              }), l;
            })({});
          })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
          var i = t.fetch ? t : r;
          e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, n.exports = e;
        }(xf, xf.exports)), xf.exports;
      }
      var Ob;
      function mi() {
        if (Ob) return yi;
        Ob = 1;
        var n = yi && yi.__awaiter || function (u, f, d, p) {
            function v(h) {
              return h instanceof d ? h : new d(function (g) {
                g(h);
              });
            }
            return new (d || (d = Promise))(function (h, g) {
              function b(N) {
                try {
                  _(p.next(N));
                } catch (O) {
                  g(O);
                }
              }
              function m(N) {
                try {
                  _(p.throw(N));
                } catch (O) {
                  g(O);
                }
              }
              function _(N) {
                N.done ? h(N.value) : v(N.value).then(b, m);
              }
              _((p = p.apply(u, f || [])).next());
            });
          },
          e = yi && yi.__importDefault || function (u) {
            return u && u.__esModule ? u : {
              default: u
            };
          };
        Object.defineProperty(yi, "__esModule", {
          value: !0
        }), yi.JsonRpcConnection = void 0;
        const t = Wi(),
          r = e(b2()),
          i = zt(),
          a = zt(),
          o = {
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json"
            },
            method: "POST"
          };
        let c = class {
          constructor(f, d = !1) {
            if (this.url = f, this.disableProviderPing = d, this.events = new t.EventEmitter(), this.isAvailable = !1, this.registering = !1, !(0, a.isHttpUrl)(f)) throw new Error(`Provided URL is not compatible with HTTP connection: ${f}`);
            this.url = f, this.disableProviderPing = d;
          }
          get connected() {
            return this.isAvailable;
          }
          get connecting() {
            return this.registering;
          }
          on(f, d) {
            this.events.on(f, d);
          }
          once(f, d) {
            this.events.once(f, d);
          }
          off(f, d) {
            this.events.off(f, d);
          }
          removeListener(f, d) {
            this.events.removeListener(f, d);
          }
          open() {
            return n(this, arguments, void 0, function* (f = this.url) {
              yield this.register(f);
            });
          }
          close() {
            return n(this, void 0, void 0, function* () {
              if (!this.isAvailable) throw new Error("Connection already closed");
              this.onClose();
            });
          }
          send(f) {
            return n(this, void 0, void 0, function* () {
              this.isAvailable || (yield this.register());
              try {
                const d = (0, i.safeJsonStringify)(f),
                  v = yield (yield (0, r.default)(this.url, Object.assign(Object.assign({}, o), {
                    body: d
                  }))).json();
                this.onPayload({
                  data: v
                });
              } catch (d) {
                this.onError(f.id, d);
              }
            });
          }
          register() {
            return n(this, arguments, void 0, function* (f = this.url) {
              if (!(0, a.isHttpUrl)(f)) throw new Error(`Provided URL is not compatible with HTTP connection: ${f}`);
              if (this.registering) return new Promise((d, p) => {
                this.events.once("register_error", v => {
                  p(v);
                }), this.events.once("open", () => {
                  if (typeof this.isAvailable == "undefined") return p(new Error("HTTP connection is missing or invalid"));
                  d();
                });
              });
              this.url = f, this.registering = !0;
              try {
                if (!this.disableProviderPing) {
                  const d = (0, i.safeJsonStringify)({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                  });
                  yield (0, r.default)(f, Object.assign(Object.assign({}, o), {
                    body: d
                  }));
                }
                this.onOpen();
              } catch (d) {
                const p = this.parseError(d);
                throw this.events.emit("register_error", p), this.onClose(), p;
              }
            });
          }
          onOpen() {
            this.isAvailable = !0, this.registering = !1, this.events.emit("open");
          }
          onClose() {
            this.isAvailable = !1, this.registering = !1, this.events.emit("close");
          }
          onPayload(f) {
            if (typeof f.data == "undefined") return;
            const d = typeof f.data == "string" ? (0, i.safeJsonParse)(f.data) : f.data;
            this.events.emit("payload", d);
          }
          onError(f, d) {
            const p = this.parseError(d),
              v = p.message || p.toString(),
              h = (0, a.formatJsonRpcError)(f, v);
            this.events.emit("payload", h);
          }
          parseError(f, d = this.url) {
            return (0, a.parseConnectionError)(f, d, "HTTP");
          }
        };
        return yi.JsonRpcConnection = c, yi;
      }
      var Ab;
      function w2() {
        if (Ab) return Gi;
        Ab = 1;
        var n = Gi && Gi.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Gi, "__esModule", {
          value: !0
        }), Gi.Eip155Provider = void 0;
        const e = Tr(),
          t = Dr(),
          r = zt(),
          i = vi(),
          a = mi();
        class l {
          constructor(o, c, u) {
            this.name = "eip155", this.namespace = o.namespace, this.events = u, this.client = c, this.chainId = parseInt(this.getDefaultChain()), this.httpProviders = this.createHttpProviders(), (0, r.logDebug)("eip155 constructor --opts.namespace-->", o.namespace);
          }
          isRecord(o) {
            return typeof o == "object" && o !== null && !Array.isArray(o);
          }
          isArray(o) {
            return typeof o == "object" && o !== null && Array.isArray(o);
          }
          updateRequestParams(o) {
            let c = o.params && typeof o.params == "object" && !Array.isArray(o.params);
            if (o.method === "wallet_switchEthereumChain") {
              const u = o.chainId.split(":")[1],
                f = parseInt(u, 10);
              if (isNaN(f)) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid decimal number,  chainId: '${u}' `);
              if (!o.params) o.params = {
                chainId: "0x" + f.toString(16)
              };else if (c) {
                let d = o.params;
                "chainId" in d || (d.chainId = "0x" + f.toString(16), o.params = d);
              } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params error ,  method: '${o.method}' `);
            } else if (o.method === "personal_sign" || o.method === "eth_signTypedData_v4" || o.method === "eth_sendTransaction" || o.method === "wallet_watchAsset") {
              if (!o.params) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params is nil, method: '${o.method}'`);
              if (this.isRecord(o.params)) {
                let u = o.params;
                if ((0, r.logDebug)("eip155 updateRequestParams params>", JSON.stringify(u)), "chainId" in u) {
                  const f = o.chainId.split(":")[1],
                    d = parseInt(f, 10);
                  let p = String(u.chainId),
                    v;
                  if (p.startsWith(this.name) && o.chainId === p) v = d;else if (p.startsWith("0x")) v = parseInt(p, 16);else if (!isNaN(Number(p))) v = parseInt(p, 10);else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid params.chainId format, method: '${o.method}'`);
                  if (d !== v) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Request params.chainId not equal chain,  method: '${o.method}' `);
                }
              } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Invalid request params type, method: '${o.method}'`);
            }
          }
          adaptArray(o) {
            if (o.method === "wallet_switchEthereumChain" || o.method === "wallet_addEthereumChain" || o.method === "wallet_watchAsset" || o.method === "eth_sendTransaction" || o.method === "kaia_signTransaction" || o.method === "klay_signTransaction") {
              if (this.isArray(o.params)) {
                let c = o.params;
                if (c) if (c.length === 1) {
                  let u = o.params[0];
                  this.isRecord(u) && (o.params = u);
                } else throw c.length > 1 ? new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params only Support one data,  method: '${o.method}' `) : new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${o.method}' `);
              }
            } else if (o.method === "eth_signTypedData_v4") {
              if (this.isArray(o.params)) {
                let c = o.params;
                if (c && c.length > 2) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params only Support one data,  method: '${o.method}' `);
                if (c && c.length === 0) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${o.method}' `);
                let u = {};
                if (c && c.length === 2) {
                  let f = o.params[0];
                  if (f && typeof f == "string") {
                    let d = !1;
                    if (this.namespace.accounts.forEach(p => {
                      (0, e.fromAccountToAddress)(p).toLowerCase() === f.toLowerCase() && (d = !0);
                    }), (0, r.logDebug)("eip155 adaptArray eth_signTypedData_v4 >>>isEqual: ", d), !d) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error, not equal,  method: '${o.method}' `);
                    if (this.isRecord(o.params[1])) u = o.params[1];else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params message data error,  method: '${o.method}' `);
                  } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error , not string,  method: '${o.method}' `);
                } else if (c && c.length === 1) if (this.isRecord(o.params[0])) u = o.params[0];else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params message data error,  method: '${o.method}' `);
                try {
                  let f = JSON.stringify(u);
                  o.params = {
                    typedDataJson: f
                  };
                } catch {
                  throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params call JSON.stringify() failed,  method: '${o.method}' `);
                }
              }
            } else if (o.method === "personal_sign" && this.isArray(o.params)) {
              if (o.params && o.params.length > 2) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params error,  method: '${o.method}' `);
              if (o.params && o.params.length === 0) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is nil,  method: '${o.method}' `);
              let c = o.params[0],
                u = o.params[1];
              if (u && typeof u == "string") {
                let f = !1;
                if (this.namespace.accounts.forEach(d => {
                  (0, e.fromAccountToAddress)(d).toLowerCase() === u.toLowerCase() && (f = !0);
                }), (0, r.logDebug)("eip155 adaptArray personal_sign >>>isEqual: ", f), !f) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params address error,  method: '${o.method}' `);
              }
              if (c && typeof c == "string") o.params = {
                message: c
              };else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `Request params is error,  method: '${o.method}' `);
            }
          }
          showRequestModal(o) {
            switch (o.method) {
              case "eth_requestAccounts":
              case "eth_accounts":
              case "eth_chainId":
                return !1;
              case "eth_sendTransaction":
              case "eth_signTransaction":
              case "eth_sign":
              case "personal_sign":
              case "eth_signTypedData":
              case "wallet_addEthereumChain":
              case "wallet_watchAsset":
              case "eth_signTypedData_v4":
                return !0;
              case "wallet_switchEthereumChain":
                {
                  this.adaptArray(o), this.updateRequestParams(o);
                  const {
                    parsedChainId: c,
                    hexChainId: u
                  } = this.getHexChainIdFromRequest(o);
                  return !this.isChainApproved(c);
                }
              default:
                return !1;
            }
            return !1;
          }
          configAddressAdaptInjectWallet(o) {
            this.namespace.accounts.forEach(c => {
              c.includes(o.chainId) && (o.address = (0, e.fromAccountToAddress)(c));
            });
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if (o.method === "eth_signLegacy" || o.method === "eth_sign") throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, `${o.method} method not supported`);
              switch (o.injectParams = o.params, this.adaptArray(o), this.client.needCheckRequestMethod() && o.method === "klay_signTransaction" && (o.method = "kaia_signTransaction"), (0, r.logDebug)("eip155 request --args--string>", JSON.stringify(o)), this.updateRequestParams(o), (0, r.logDebug)("eip155 request --params--string>", JSON.stringify(o)), this.configAddressAdaptInjectWallet(o), o.method) {
                case "eth_requestAccounts":
                  return this.getAccounts();
                case "eth_accounts":
                  return this.getAccounts();
                case "eth_chainId":
                  return parseInt(this.getDefaultChain());
                case "wallet_switchEthereumChain":
                  return yield this.handleSwitchChain(o);
                case "wallet_addEthereumChain":
                  return this.addEthereumChain(o);
              }
              if (!this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) {
                if (this.client.needCheckRequestMethod() && (o.method === "eth_sendTransaction" || o.method === "kaia_signTransaction")) try {
                  if (o.params && typeof o.params == "object" && !Array.isArray(o.params)) {
                    const c = o.params;
                    typeof c.input == "string" && c.input.trim() !== "" ? !c.data || typeof c.data == "string" && c.data.trim() === "" ? (c.data = c.input, (0, r.logDebug)("eip155 sendTransaction:  replace data with input")) : (0, r.logDebug)("eip155 sendTransaction:  data not empty") : (0, r.logDebug)("eip155 sendTransaction:  input empty");
                  }
                } catch {
                  (0, r.logDebug)("eip155 sendTransaction:  replace error");
                }
                try {
                  const c = yield this.client.request(o);
                  if ((0, r.logDebug)("eip155 request --response----string>", JSON.stringify(c)), this.isRecord(c) && "result" in c) {
                    let u = c.result;
                    return u && typeof u == "string" && (u === "true" || u === "false") ? ((0, r.logDebug)("eip155 request --wallet_watchAsset>>>>", u === "true"), u === "true") : c.result;
                  }
                  return c;
                } catch (c) {
                  throw (0, r.logDebug)(`eip155 request --response --error--string> e instanceof OKXConnectError ${c instanceof r.OKXConnectError}`, JSON.stringify(c)), c;
                }
              } else return (0, r.logDebug)("[RPC] request begin"), yield this.getHttpProvider().request(o);
            });
          }
          addEthereumChain(o) {
            return n(this, void 0, void 0, function* () {
              let c = yield this.client.request(o);
              try {
                if ("result" in c) {
                  let u = c,
                    f = c.result;
                  if (f) {
                    const d = f.split(":")[0],
                      p = f.split(":")[1],
                      v = d + ":" + p;
                    let h = this.namespace;
                    if (this.namespace.accounts.push(f), this.namespace.chains.push(v), this.isRecord(o.params) && "rpcUrls" in o.params) {
                      let g = o.params.rpcUrls,
                        b = g ? g[0] : void 0;
                      b && (this.namespace.rpcMap ? this.namespace.rpcMap[p] = b : this.namespace.rpcMap = {
                        [p]: b
                      }, this.setHttpProvider(p, b));
                    }
                    this.events.emit(t.PROVIDER_EVENTS.UPDATE_NAMESPACES, {
                      eip155: this.namespace
                    });
                  }
                } else new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${o.method} request error`);
              } catch {
                throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method ${o.method} request  error`);
              }
              return null;
            });
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          setDefaultChain(o, c) {
            if (this.chainId = parseInt(o), !this.httpProviders[o]) {
              const u = c || (0, e.getRpcUrl)(`${this.name}:${o}`, this.namespace);
              u ? this.setHttpProvider(o, u) : (0, r.logDebug)(`No RPC url provided for chainId: ${o}`);
            }
            this.events.emit(t.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId.toString();
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return (0, r.logDebug)("eip155 getAccounts ", o, this.chainId), o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => (0, e.fromAccountToAddress)(c)))] : [];
          }
          getHexChainIdFromRequest(o) {
            let c = o.params,
              u = "0x0";
            c && "chainId" in c && (u = c.chainId), u = u.startsWith("0x") ? u : `0x${u}`, (0, r.logDebug)("handleSwitchChain -->args ", o), (0, r.logDebug)("handleSwitchChain -->hexChainId ", u);
            const f = parseInt(u, 16);
            return (0, r.logDebug)("handleSwitchChain -->parsedChainId ", f), {
              parsedChainId: f,
              hexChainId: u
            };
          }
          handleSwitchChain(o) {
            return n(this, void 0, void 0, function* () {
              const {
                parsedChainId: c,
                hexChainId: u
              } = this.getHexChainIdFromRequest(o);
              if (this.isChainApproved(c)) this.setDefaultChain(`${c}`);else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED, `the method ${o.method} request  error`);
            });
          }
          isChainApproved(o) {
            return this.namespace.chains.includes(`${this.name}:${o}`);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (!u) (0, r.logDebug)(`No RPC url provided for chainId: ${o}`);else return new i.JsonRpcProvider(new a.JsonRpcConnection(u, (0, e.getGlobal)("disableProviderPing")));
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, e.getChainId)(c),
                f = (0, e.getRpcUrl)(c, this.namespace);
              (0, r.logDebug)("get parsed chain and rpc:", u, f);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), (0, r.logDebug)("get http providermap:", o), o;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if ((0, r.logDebug)("[RPC] get http provider:", o, c), typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
        }
        return Gi.Eip155Provider = l, Gi.default = l, Gi;
      }
      var Vi = {},
        Rb;
      function x2() {
        if (Rb) return Vi;
        Rb = 1;
        var n = Vi && Vi.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Vi, "__esModule", {
          value: !0
        }), Vi.SuiProvider = void 0;
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u) {
            this.name = t.NameSpaceKeySui, this.namespace = o.namespace, this.events = u, this.client = c, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("sui request --args--string>", JSON.stringify(o)), (0, t.logDebug)("sui provider namespace: ", this.namespace), o.injectParams) {
                if ("chain" in o && t.SUI_CHAINS.MAINNET != o.chain) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED);
                if (o.injectParams.chain = t.SUI_CHAINS.MAINNET, "account" in o && o.account.address != this.getAccounts[0]) throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.BAD_REQUEST_ERROR);
                o.injectParams.account = {
                  address: this.getAccounts()[0]
                };
              }
              return !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method) ? this.client.request(o) : this.getHttpProvider().request(o);
            });
          }
          requestAccounts() {
            return this.getAccounts();
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if ((0, t.logDebug)("[RPC] get http provider:", o, c), typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && ((0, t.logDebug)("setHttpProvider", o, c), this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (!u) (0, t.logDebug)(`No RPC url provided for chainId: ${o}`);else return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          getPubkey(o) {
            return this.getWalletAddress(o);
          }
          getWalletAddress(o) {
            return o || (o = this.namespace.defaultChain, o != null && o.startsWith("sui") || (o = `sui:${o}`)), this.namespace.accounts.filter(function (c) {
              return c.split(":").length > 2 && c.startsWith(o);
            }).map(function (c) {
              return c.split(":")[2];
            })[0];
          }
          showRequestModal(o) {
            switch (o.method) {
              case "sui_signMessage":
              case "sui_signPersonalMessage":
              case "sui_signTransactionBlock":
              case "sui_signAndExecuteTransactionBlock":
                return !0;
              default:
                return !1;
            }
            return !1;
          }
        }
        return Vi.SuiProvider = l, Vi.default = l, Vi;
      }
      var Ds = {},
        zi = {},
        Nb;
      function Sb() {
        if (Nb) return zi;
        Nb = 1, Object.defineProperty(zi, "__esModule", {
          value: !0
        }), zi.getAccountsChains = e, zi.nameSpaceToConnectWalletNameSpace = t, zi.fillParamsToSession = r, zi.isCaipNamespace = a, zi.parseNamespaceKey = l;
        const n = zt();
        function e(s) {
          const o = [];
          return s.forEach(c => {
            const [u, f] = c.split(":");
            o.push(`${u}:${f}`);
          }), o;
        }
        function t(s) {
          var o = [];
          return s && Object.keys(s).forEach(c => {
            (c === n.NameSpaceKeyEip155 || c === n.NameSpaceKeySOL || c === n.NameSpaceKeySui || c === n.NameSpaceKeyAptos || c == n.NameSpaceKeyBtc || c === n.NameSpaceKeyTON || c === n.NameSpaceKeyCosmos || c === n.NameSpaceKeyTron || c === n.NameSpaceKeyStarknet) && s[c].chains && o.push({
              namespace: c,
              chains: s[c].chains,
              params: s[c].params
            });
          }), o;
        }
        function r(s, o, c, u) {
          const f = (p, v) => {
              Object.assign(p, v);
            },
            d = (p, v) => {
              for (const h in v) v.hasOwnProperty(h) && v[h].rpcMap && (v[h].rpcMap && (p[h].rpcMap || (p[h].rpcMap = {}), f(p[h].rpcMap, v[h].rpcMap)), v[h].defaultChain && p[h].defaultChain === void 0 && p[h].chains.some(g => g.split(":")[1] === v[h].defaultChain) && (p[h].defaultChain = v[h].defaultChain));
            };
          o && d(s.namespaces, o), c && d(s.namespaces, c);
          for (const p in s.namespaces) {
            const v = s.namespaces[p];
            (!(v != null && v.accounts) || v.accounts.length === 0) && delete s.namespaces[p];
          }
          s.namespaces[n.NameSpaceKeyBtc] && s.wallet.appName === n.OKXWalletName && i(s.namespaces[n.NameSpaceKeyBtc]), s.sessionConfig = u;
        }
        function i(s) {
          try {
            if (s && s.extra) {
              var o = s.extra;
              Object.keys(o).forEach(c => {
                const u = o[c];
                Number(u.addressType) === 6 ? u.publicKey = u.compressedPublicKey.slice(2) : u.publicKey = u.compressedPublicKey;
              });
            }
          } catch {
            (0, n.logDebug)("namespaces fixMobileBtcSession error");
          }
        }
        function a(s) {
          return s.includes(":");
        }
        function l(s) {
          return a(s) ? s.split(":")[0] : s;
        }
        return zi;
      }
      var Tb;
      function _2() {
        if (Tb) return Ds;
        Tb = 1;
        var n = Ds && Ds.__awaiter || function (l, s, o, c) {
          function u(f) {
            return f instanceof o ? f : new o(function (d) {
              d(f);
            });
          }
          return new (o || (o = Promise))(function (f, d) {
            function p(g) {
              try {
                h(c.next(g));
              } catch (b) {
                d(b);
              }
            }
            function v(g) {
              try {
                h(c.throw(g));
              } catch (b) {
                d(b);
              }
            }
            function h(g) {
              g.done ? f(g.value) : u(g.value).then(p, v);
            }
            h((c = c.apply(l, s || [])).next());
          });
        };
        Object.defineProperty(Ds, "__esModule", {
          value: !0
        }), Ds.SignClient = void 0;
        const e = zt(),
          t = Sb(),
          r = yb(),
          i = Dr();
        class a extends e.ISignClient {
          constructor(s, o, c) {
            super(s), this.connect = u => n(this, void 0, void 0, function* () {
              return new Promise((f, d) => n(this, void 0, void 0, function* () {
                try {
                  var p = [];
                  (0, e.logDebug)("client connect params >>>", JSON.stringify(u));
                  var v = {
                    name: "requestAccounts",
                    requiredNamespaces: (0, t.nameSpaceToConnectWalletNameSpace)(u.namespaces),
                    optionalNamespaces: (0, t.nameSpaceToConnectWalletNameSpace)(u.optionalNamespaces)
                  };
                  this.engine.setSessionConnectingListener(() => {
                    (0, e.logDebug)("sessionConnectingListener >>>"), this.events.emit(i.PROVIDER_EVENTS.SESSION_CONNECTING);
                  }), u.signRequest && (v.connectRequestMethods = yield (0, r.connectMethodsToConnectWalletMethods)(u.signRequest, v.requiredNamespaces)), p.push(v), (0, e.logDebug)("client connect connectRequest >>>", JSON.stringify(p)), this.engine.universalConnect(p, Object.assign({
                    dappInfo: this.metadata
                  }, u.sessionConfig), h => {
                    h && h.connectRequest && ((0, e.logDebug)("universalConect info.connectRequest :", h.connectRequest), (0, e.logDebug)("universalConect url:", (0, e.getOKXLink)(h.connectRequest, this.sessionConfig.useMini)), this.events.emit("display_uri", (0, e.getOKXLink)(h.connectRequest, this.sessionConfig.useMini).universalLink), this.events.emit("short_display_uri", (0, e.getAppWalletShortDeepLink)(h.connectRequest.topic, h.connectRequest.clientId)), (0, e.logDebug)(`universalConect EngineConnectInfo  ${JSON.stringify(h)}`), this.events.emit("okx_engine_connect_params", h));
                  }).then(h => n(this, void 0, void 0, function* () {
                    (0, t.fillParamsToSession)(h, u.namespaces, u.optionalNamespaces, this.sessionConfig), (0, e.logDebug)(`signClient: connect: session ${JSON.stringify(h)}`), u.signRequest && (yield (0, r.connectMethodsResponseUpdate)(h, u.signRequest)), f(h);
                  })).catch(h => {
                    (0, e.logDebug)(`signClient: connect: catch ${JSON.stringify(h)}`), this.events.emit("connect_error", h), d(h);
                  });
                } catch (h) {
                  (0, e.logDebug)(`signClient: connect:  ${JSON.stringify(h)}`), d(h);
                }
              }));
            }), this.restoreconnect = u => n(this, void 0, void 0, function* () {
              return new Promise((f, d) => {
                this.engine.restoreconnect(u, p => {
                  p ? f(p) : d();
                });
              });
            }), this.reject = u => n(this, void 0, void 0, function* () {}), this.request = u => n(this, void 0, void 0, function* () {
              return new Promise((f, d) => n(this, void 0, void 0, function* () {
                var p, v;
                (0, e.logDebug)("clint request --params>>>> >", (p = this.sessionConfig) === null || p === void 0 ? void 0 : p.openUniversalUrl, (0, e.safeJsonStringify)(u));
                try {
                  !((v = this.sessionConfig) === null || v === void 0) && v.openUniversalUrl && (0, e.isIos)() && this.openOKXWallet(), yield this.engine.send(u, {
                    resolve: h => {
                      if (delete h.requestId, (0, e.logDebug)("clint request --response >", (0, e.safeJsonStringify)(h)), "error" in h && h.error) {
                        let g = h.error;
                        d(new e.OKXConnectError(h.error.code, h.method + ":" + g.message));
                      } else f(h);
                    },
                    onAck: () => {
                      var h;
                      !(0, e.isIos)() && !((h = this.sessionConfig) === null || h === void 0) && h.openUniversalUrl && this.openOKXWallet();
                    }
                  });
                } catch (h) {
                  (0, e.logDebug)("clint request --error:", h), d(h);
                }
              }));
            }), this.disconnect = () => n(this, void 0, void 0, function* () {
              return new Promise((u, f) => {
                this.engine.send({
                  method: "disconnect"
                }, {
                  onAck: () => {
                    u();
                  }
                }, 864e5).catch(d => {
                  console.log(`disconnect : ${JSON.stringify(d)}`), f(d);
                });
              });
            }), this.engine = new e.Engine(s.name), this.events = o, this.metadata = s, this.openAppLineType = c != null ? c : e.OpenAppLinkType.UniversalLink;
          }
          setAccountChangeListener(s) {
            this.engine.setAccountChangeListener(s);
          }
          openOKXWallet() {
            (0, e.logDebug)("bridge-provider ==>> connect_5"), this.engine.openWallet({
              tmaReturnUrl: this.sessionConfig.tmaReturnUrl
            }, null, this.openAppLineType);
          }
          syncAllAddress() {
            return n(this, void 0, void 0, function* () {
              return new Promise((s, o) => {
                this.engine.send({
                  method: "sync_all_addresses"
                }, {
                  resolve: c => {
                    if (delete c.requestId, (0, e.logDebug)("clint syncAllAddress --response >", JSON.stringify(c)), "error" in c && c.error) {
                      let u = c.error;
                      o(new e.OKXConnectError(c.error.code, c.method + ":" + u.message));
                    } else {
                      let u = c.result;
                      s((0, r.syncResoonseToRequire)(u));
                    }
                  }
                }).catch(c => {
                  console.log(`disconnect : ${JSON.stringify(c)}`), o(c);
                });
              });
            });
          }
          registerConnector(s) {
            this.engine.registerConnector(s);
          }
          openWallet(s, o) {
            this.engine.openWallet(s, o, this.openAppLineType);
          }
          setConnectConnector(s) {
            this.engine.setConnectConnector(s);
          }
          needCheckRequestMethod() {
            try {
              return !Object.values(e.CONNECTOR_TYPE.INJECT).includes(this.engine.getConnector().getType()) && !Object.values(e.CONNECTOR_TYPE.KEYLESS).includes(this.engine.getConnector().getType());
            } catch {
              return !0;
            }
          }
        }
        return Ds.SignClient = a, Ds;
      }
      var $i = {},
        Db;
      function E2() {
        if (Db) return $i;
        Db = 1;
        var n = $i && $i.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty($i, "__esModule", {
          value: !0
        }), $i.SolanaProvider = void 0;
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u, f) {
            this.name = "solana", this.namespace = o.namespace, this.events = f, this.client = u, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders(), this.name = c;
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("solana request --args--string>", JSON.stringify(o)), (0, t.logDebug)("solana provider namespace: ", this.namespace), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) return this.client.request(o);
              throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (u) return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          getPubkey(o) {
            return this.getWalletAddress(o);
          }
          getWalletAddress(o) {
            return o || (o = this.namespace.defaultChain, o != null && o.startsWith("solana") || (o = `solana:${o}`)), this.namespace.accounts.filter(function (c) {
              return c.split(":").length > 2 && c.startsWith(o);
            }).map(function (c) {
              return c.split(":")[2];
            })[0];
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return $i.SolanaProvider = l, $i.default = l, $i;
      }
      var Sa = {},
        Pb;
      function C2() {
        if (Pb) return Sa;
        Pb = 1;
        var n = Sa && Sa.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Sa, "__esModule", {
          value: !0
        });
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u, f) {
            this.name = t.NameSpaceKeyBtc, this.namespace = o.namespace, this.events = f, this.client = u, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders(), this.name = c;
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              return (0, t.logDebug)("btc request --args--string>", JSON.stringify(o)), (0, t.logDebug)("btc provider namespace: ", JSON.stringify(this.namespace)), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method) ? this.client.request(o) : this.getHttpProvider().request(o);
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (!u) (0, t.logDebug)(`No RPC url provided for chainId: ${o}`);else return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return Sa.default = l, Sa;
      }
      var Ta = {},
        Ib;
      function O2() {
        if (Ib) return Ta;
        Ib = 1;
        var n = Ta && Ta.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Ta, "__esModule", {
          value: !0
        });
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u, f) {
            this.name = "aptos", this.namespace = o.namespace, this.events = f, this.client = u, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders(), this.name = c;
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("aptos request --args--string>", (0, t.safeJsonStringify)(o)), (0, t.logDebug)("aptos provider namespace: ", this.namespace), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) return this.client.request(o);
              throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (u) return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return Ta.default = l, Ta;
      }
      var Qi = {},
        Bb;
      function A2() {
        if (Bb) return Qi;
        Bb = 1;
        var n = Qi && Qi.__awaiter || function (o, c, u, f) {
            function d(p) {
              return p instanceof u ? p : new u(function (v) {
                v(p);
              });
            }
            return new (u || (u = Promise))(function (p, v) {
              function h(m) {
                try {
                  b(f.next(m));
                } catch (_) {
                  v(_);
                }
              }
              function g(m) {
                try {
                  b(f.throw(m));
                } catch (_) {
                  v(_);
                }
              }
              function b(m) {
                m.done ? p(m.value) : d(m.value).then(h, g);
              }
              b((f = f.apply(o, c || [])).next());
            });
          },
          e = Qi && Qi.__rest || function (o, c) {
            var u = {};
            for (var f in o) Object.prototype.hasOwnProperty.call(o, f) && c.indexOf(f) < 0 && (u[f] = o[f]);
            if (o != null && typeof Object.getOwnPropertySymbols == "function") for (var d = 0, f = Object.getOwnPropertySymbols(o); d < f.length; d++) c.indexOf(f[d]) < 0 && Object.prototype.propertyIsEnumerable.call(o, f[d]) && (u[f[d]] = o[f[d]]);
            return u;
          };
        Object.defineProperty(Qi, "__esModule", {
          value: !0
        });
        const t = Dr(),
          r = zt(),
          i = Tr(),
          a = mi(),
          l = vi();
        class s {
          constructor(c, u, f) {
            this.name = r.NameSpaceKeyTON, this.namespace = c.namespace, this.events = f, this.client = u, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
          }
          updateNamespace(c) {
            this.namespace = Object.assign(this.namespace, c);
          }
          isRecord(c) {
            return typeof c == "object" && c !== null && !Array.isArray(c);
          }
          request(c) {
            return n(this, void 0, void 0, function* () {
              var u, f, d, p;
              if ((0, r.logDebug)("TONProvider request --args--string>", JSON.stringify(c)), (0, r.logDebug)("TONProvider request provider namespace: ", this.namespace), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(c.method)) {
                if (!c.params) throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton request params is nil");
                if (this.isRecord(c.params)) {
                  const v = c.params,
                    {
                      validUntil: h
                    } = v,
                    g = e(v, ["validUntil"]);
                  let b = (f = (u = this.namespace.payload) === null || u === void 0 ? void 0 : u.ton_addr) === null || f === void 0 ? void 0 : f.address;
                  "from" in g && (b = g.from || ((p = (d = this.namespace.payload) === null || d === void 0 ? void 0 : d.ton_addr) === null || p === void 0 ? void 0 : p.address)), c.params.from = b, c.params.network = this.getDefaultChain(), c.params.valid_until = h;
                  let m = yield this.client.request(c);
                  if (this.isRecord(m) && "result" in m) {
                    const _ = {
                      boc: m.result.toString()
                    };
                    return (0, r.logDebug)("TONProvider request provider response: ", JSON.stringify(m)), (0, r.logDebug)("TONProvider request provider result: ", JSON.stringify(_)), _;
                  }
                  throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton_send request response is nil");
                } else throw new r.OKXConnectError(r.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "ton request params type add nil");
              }
              return this.getHttpProvider().request(c);
            });
          }
          requestAccounts() {
            return this.getAccounts();
          }
          setDefaultChain(c, u) {
            this.httpProviders[c] || this.setHttpProvider(c, u), this.chainId = c, this.events.emit(t.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${c}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const c = this.namespace.chains[0];
            if (!c) throw new Error("ChainId not found");
            return c.split(":")[1];
          }
          getAccounts() {
            var c, u;
            const f = this.namespace.accounts;
            if ((0, r.logDebug)("ton getAccounts accounts :", f), (0, r.logDebug)("ton getAccounts .namespace :", JSON.stringify(this.namespace)), !f) return [];
            let d = (u = (c = this.namespace.payload) === null || c === void 0 ? void 0 : c.ton_addr) === null || u === void 0 ? void 0 : u.address;
            return (0, r.logDebug)("ton getAccounts address :", d), d ? [d] : [];
          }
          createHttpProviders() {
            const c = {};
            return this.namespace.chains.forEach(u => {
              const f = (0, i.getChainId)(u),
                d = (0, i.getRpcUrl)(u, this.namespace);
              let p = this.createHttpProvider(f, d);
              p && (c[f] = p);
            }), c;
          }
          getHttpProvider() {
            const c = `${this.chainId}`,
              u = this.httpProviders[c];
            if ((0, r.logDebug)("[RPC] get http provider:", c, u), typeof u == "undefined") throw new Error(`JSON-RPC provider for ${c} not found`);
            return u;
          }
          setHttpProvider(c, u) {
            const f = this.createHttpProvider(c, u);
            f && ((0, r.logDebug)("setHttpProvider", c, u), this.httpProviders[c] = f);
          }
          createHttpProvider(c, u) {
            const f = u;
            if (!f) (0, r.logDebug)(`No RPC url provided for chainId: ${c}`);else return new l.JsonRpcProvider(new a.JsonRpcConnection(f, (0, i.getGlobal)("disableProviderPing")));
          }
          showRequestModal(c) {
            switch (c.method) {
              case "ton_sendTransaction":
                return !0;
              default:
                return !1;
            }
          }
        }
        return Qi.default = s, Qi;
      }
      var Da = {},
        kb;
      function R2() {
        if (kb) return Da;
        kb = 1;
        var n = Da && Da.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Da, "__esModule", {
          value: !0
        });
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u) {
            this.name = t.NameSpaceKeyCosmos, this.namespace = o.namespace, this.events = u, this.client = c, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("cosmos request --args--string>", JSON.stringify(o)), (0, t.logDebug)("cosmos provider namespace: ", JSON.stringify(this.namespace)), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) return this.client.request(o);
              throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (u) return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return Da.default = l, Da;
      }
      var Pa = {},
        Mb;
      function N2() {
        if (Mb) return Pa;
        Mb = 1;
        var n = Pa && Pa.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Pa, "__esModule", {
          value: !0
        });
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u) {
            this.name = t.NameSpaceKeyTron, this.namespace = o.namespace, this.events = u, this.client = c, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("tron request --args--string>", JSON.stringify(o)), (0, t.logDebug)("tron provider namespace: ", JSON.stringify(this.namespace)), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) return this.client.request(o);
              throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Please upgrade OKX APP");
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (u) return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return Pa.default = l, Pa;
      }
      var Ia = {},
        Kb;
      function S2() {
        if (Kb) return Ia;
        Kb = 1;
        var n = Ia && Ia.__awaiter || function (s, o, c, u) {
          function f(d) {
            return d instanceof c ? d : new c(function (p) {
              p(d);
            });
          }
          return new (c || (c = Promise))(function (d, p) {
            function v(b) {
              try {
                g(u.next(b));
              } catch (m) {
                p(m);
              }
            }
            function h(b) {
              try {
                g(u.throw(b));
              } catch (m) {
                p(m);
              }
            }
            function g(b) {
              b.done ? d(b.value) : f(b.value).then(v, h);
            }
            g((u = u.apply(s, o || [])).next());
          });
        };
        Object.defineProperty(Ia, "__esModule", {
          value: !0
        });
        const e = Dr(),
          t = zt(),
          r = Tr(),
          i = mi(),
          a = vi();
        class l {
          constructor(o, c, u, f) {
            this.name = "starknet", this.namespace = o.namespace, this.events = f, this.client = u, this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders(), this.name = c;
          }
          updateNamespace(o) {
            this.namespace = Object.assign(this.namespace, o);
          }
          requestAccounts() {
            return this.getAccounts();
          }
          request(o) {
            return n(this, void 0, void 0, function* () {
              if ((0, t.logDebug)("starknet request --args--string>", JSON.stringify(o)), (0, t.logDebug)("starknet provider namespace: ", this.namespace), !this.client.needCheckRequestMethod() || this.namespace.methods.includes(o.method)) return this.client.request(o);
              throw new t.OKXConnectError(t.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED, "Wallet doesn't support" + o.method);
            });
          }
          setDefaultChain(o, c) {
            this.httpProviders[o] || this.setHttpProvider(o, c), this.chainId = o, this.events.emit(e.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${o}`);
          }
          getDefaultChain() {
            if (this.chainId) return this.chainId;
            if (this.namespace.defaultChain) return this.namespace.defaultChain;
            const o = this.namespace.chains[0];
            if (!o) throw new Error("ChainId not found");
            return o.split(":")[1];
          }
          getAccounts() {
            const o = this.namespace.accounts;
            return o ? [...new Set(o.filter(c => c.split(":")[1] === this.chainId.toString()).map(c => c.split(":")[2]))] : [];
          }
          createHttpProviders() {
            const o = {};
            return this.namespace.chains.forEach(c => {
              const u = (0, r.getChainId)(c),
                f = (0, r.getRpcUrl)(c, this.namespace);
              let d = this.createHttpProvider(u, f);
              d && (o[u] = d);
            }), o;
          }
          getHttpProvider() {
            const o = `${this.chainId}`,
              c = this.httpProviders[o];
            if (typeof c == "undefined") throw new Error(`JSON-RPC provider for ${o} not found`);
            return c;
          }
          setHttpProvider(o, c) {
            const u = this.createHttpProvider(o, c);
            u && (this.httpProviders[o] = u);
          }
          createHttpProvider(o, c) {
            const u = c;
            if (u) return new a.JsonRpcProvider(new i.JsonRpcConnection(u, (0, r.getGlobal)("disableProviderPing")));
          }
          showRequestModal(o) {
            return !0;
          }
        }
        return Ia.default = l, Ia;
      }
      var Lb;
      function T2() {
        if (Lb) return Xr;
        Lb = 1;
        var n = Xr && Xr.__awaiter || function (O, y, w, A) {
            function R(T) {
              return T instanceof w ? T : new w(function (D) {
                D(T);
              });
            }
            return new (w || (w = Promise))(function (T, D) {
              function M(x) {
                try {
                  W(A.next(x));
                } catch (C) {
                  D(C);
                }
              }
              function q(x) {
                try {
                  W(A.throw(x));
                } catch (C) {
                  D(C);
                }
              }
              function W(x) {
                x.done ? T(x.value) : R(x.value).then(M, q);
              }
              W((A = A.apply(O, y || [])).next());
            });
          },
          e = Xr && Xr.__importDefault || function (O) {
            return O && O.__esModule ? O : {
              default: O
            };
          };
        Object.defineProperty(Xr, "__esModule", {
          value: !0
        }), Xr.OKXUniversalProvider = void 0;
        const t = w2(),
          r = x2(),
          i = Dr(),
          a = e(Wi()),
          l = _2(),
          s = zt(),
          o = Sb(),
          c = e(E2()),
          u = e(C2()),
          f = e(O2()),
          d = e(A2()),
          p = e(R2()),
          v = e(N2()),
          h = Tr(),
          g = Ud(),
          b = Ud(),
          m = gb(),
          _ = e(S2());
        let N = class sh {
          static init(y) {
            return n(this, void 0, void 0, function* () {
              (0, s.logDebug)("OKXUniversalProvider init() called"), (0, s.checkMetaData)(y.dappMetaData), (0, h.setGlobal)("disableProviderPing", !0);
              let w;
              return (0, s.getDefaultReporter)().configVersionAndSide("universalprovider", "dapp", y.dappMetaData.name), window && window.okxConnectUniversalinwindow && window.okxConnectUniversalinwindow instanceof sh ? ((0, s.logDebug)("OKXUniversalConnect init() old called"), w = window.okxConnectUniversalinwindow) : ((0, s.logDebug)("OKXUniversalConnect init() new called"), w = new sh(y), window && (window.okxConnectUniversalinwindow = w), yield w.initialize()), w;
            });
          }
          constructor(y) {
            this.rpcProviders = {}, this.events = new a.default(), (!y.connector || y.connector.length == 0) && ((0, g.isMobileDiscover)() ? y.connector = [new s.OkxwalletInjectConnector()] : y.connector = [new s.AppwalletConnector(), new s.TgwalletConnector()]), this.providerOpts = y, this.specialDAppLineType(this.providerOpts), (0, s.logDebug)("constructor this.providerOpts>>", JSON.stringify(this.providerOpts));
            let w = s.OpenAppLinkType.UniversalLink;
            switch (y.openAppLinkType) {
              case "universallink":
                w = s.OpenAppLinkType.UniversalLink;
                break;
              case "deeplink":
                w = s.OpenAppLinkType.DeepLink;
                break;
              default:
                w = s.OpenAppLinkType.UniversalLink;
                break;
            }
            this.providerOpts.openAppLinkType = w, (0, s.logDebug)("OKXUniversalProvider constructor() linkType:", w);
          }
          specialDAppLineType(y) {
            let w = window.location.host;
            w && (w.includes("dappportal.io") || w.includes("connect.oker.vip")) && !y.openAppLinkType && ((0, s.logDebug)("specialDAppLineType --> host:", w), y.openAppLinkType = s.OpenAppLinkType.DeepLink);
          }
          getOpenAppLinkType() {
            var y;
            return (y = this.providerOpts.openAppLinkType) !== null && y !== void 0 ? y : s.OpenAppLinkType.UniversalLink;
          }
          request(y, w) {
            return n(this, void 0, void 0, function* () {
              if ((0, s.logDebug)("OKXUniversalProvider request() called"), (0, s.reportLog)("OKXUniversalProvider request() called"), !this.connected()) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
              (0, s.logDebug)("OKXUniversalProvider request()  connected ");
              const {
                namespace: A,
                requestParam: R
              } = this.buildRequestParamFromRequest(y, w);
              return yield this.getProvider(A).request(R);
            });
          }
          buildRequestParamFromRequest(y, w) {
            var A;
            (0, s.logDebug)("UniversalProvider request args >>>>>>>: ", w, (0, s.safeJsonStringify)(y));
            let [R, T] = this.validateChain(w);
            if (!this.session) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Please call connect() before request()");
            let D = Object.keys(this.session.namespaces);
            if (!w && D && D.length > 1) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, "Multiple chains have been linked, the request method requires chain");
            let M = (0, s.replaceChainNameToChainId)(`${R}:${T}`);
            M != null && (R = M.split(":")[0], T = M.split(":")[1]);
            const q = Object.assign(Object.assign({}, y), {
              chainId: `${R}:${T}`,
              redirect: (A = y.redirect) !== null && A !== void 0 ? A : this.sessionConfig.redirect
            });
            return {
              namespace: R,
              requestParam: q
            };
          }
          enable() {
            return n(this, void 0, void 0, function* () {
              if (!this.client) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
              if (!this.session) if (this.connectOpts) yield this.connect(this.connectOpts);else throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
              return yield this.requestAccounts();
            });
          }
          disconnect() {
            return n(this, void 0, void 0, function* () {
              return (0, s.logDebug)("OKXUniversalProvider disconnect() called"), (0, s.reportLog)("provider disconnect called"), new Promise(y => n(this, void 0, void 0, function* () {
                let w = !1;
                const A = () => n(this, void 0, void 0, function* () {
                  w || (w = !0, yield this.disconnectAndEmit(), yield this.cleanup(), y(), (0, s.logDebug)("UniversalProvider disconnect Disconnected"), (0, s.reportLog)("provider disconnect disconnected"));
                });
                try {
                  yield this.client.disconnect(), yield A();
                } catch {
                  yield A();
                }
              }));
            });
          }
          disconnectAndEmit() {
            var y, w;
            this.client.engine.connectManagerDisconnect(), this.events.emit("disconnect", {
              topic: (y = this.session) === null || y === void 0 ? void 0 : y.topic
            }), this.events.emit("session_delete", {
              topic: (w = this.session) === null || w === void 0 ? void 0 : w.topic
            });
          }
          replaceNamespace(y, w) {
            var A, R;
            let T = (A = y.namespaces) === null || A === void 0 ? void 0 : A[w];
            if (T != null) {
              let M = this.replaceNamespaceInner(T);
              y.namespaces != null && w in y.namespaces && M != null && (y.namespaces[w] = M);
            }
            let D = (R = y.optionalNamespaces) === null || R === void 0 ? void 0 : R[w];
            if (D != null) {
              let M = this.replaceNamespaceInner(D);
              y.optionalNamespaces != null && w in y.optionalNamespaces && M != null && (y.optionalNamespaces[w] = M);
            }
            return y;
          }
          replaceNamespaceInner(y) {
            var w;
            return y != null && (y.chains = (w = y.chains) === null || w === void 0 ? void 0 : w.map(A => (0, s.replaceChainNameToChainId)(A)), y.defaultChain != null && (y.defaultChain = (0, s.replaceChainNameToChainId)(y.defaultChain))), y;
          }
          replaceSessionAptos(y, w) {
            var A;
            let R = (A = y == null ? void 0 : y.namespaces) === null || A === void 0 ? void 0 : A[w];
            if (R != null && R.chains != null) {
              R.chains = R.chains.map(D => (0, s.replaceChainIdToChainName)(D)), R.accounts = R.accounts.map(D => (0, s.replaceChainIdToChainName)(D));
              let T = {};
              Object.keys(R.extra || {}).forEach((D, M) => {
                (0, s.replaceChainIdToChainName)(D), T[(0, s.replaceChainIdToChainName)(D)] = Object.values((y == null ? void 0 : y.namespaces[w].extra) || {})[M];
              }), R.extra = T;
            }
            (0, s.logDebug)("replaceSessionAptos", y);
          }
          connected() {
            (0, s.logDebug)("OKXUniversalProvider connected() called"), (0, s.reportLog)("provider connected called");
            let y = () => {
              try {
                this.cleanup(), this.client.engine.connectManagerDisconnect();
              } catch (w) {
                (0, s.logDebug)("Error during disconnect:", w);
              }
            };
            try {
              return this.session ? this.client.engine.getCurrentConnectionReady(Object.keys(this.session.namespaces)) ? !0 : (y(), !1) : !1;
            } catch {
              return y(), !1;
            }
          }
          connectAndSign(y, w) {
            return n(this, void 0, void 0, function* () {
              (0, s.logDebug)("OKXUniversalProvider connectAndSign() called");
              const A = Object.assign(Object.assign({}, y), w);
              return (0, s.logDebug)("OKXUniversalProvider connectAndSign() opts:", JSON.stringify(y)), (0, s.logDebug)("OKXUniversalProvider connectAndSign() signRequest:", JSON.stringify(w)), yield this.connect(A);
            });
          }
          connect(y) {
            return n(this, void 0, void 0, function* () {
              if ((0, s.logDebug)("OKXUniversalProvider connect() called"), (0, s.reportLog)("provider connect called"), !this.client) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
              if (this.connected()) return this.session;
              y = this.replaceNamespace(y, "aptos"), y = this.replaceNamespace(y, "solana"), (0, s.logDebug)("OKXUniversalProvider connect >>>>", JSON.stringify(y)), y.sessionConfig === void 0 && (y.sessionConfig = {}), y.sessionConfig.openUniversalUrl === void 0 && (y.sessionConfig.openUniversalUrl = (0, s.isMobileUserAgent)()), y.sessionConfig.openAppLinkType = this.providerOpts.openAppLinkType, this.setNamespaces(y);
              try {
                (0, s.logDebug)(`UniversalProvider connect opts.stringify ====> ${JSON.stringify(y)}`);
                let w = yield this.client.connect(y);
                if ((0, s.logDebug)(`UniversalProvider connect success ====> ${JSON.stringify(w)}`), w) {
                  if (this.replaceSessionAptos(w, "aptos"), this.replaceSessionAptos(w, "solana"), this.session = w, this.client.session = w, this.setConnectConnector(), (0, s.logDebug)("OKXUniversalProvider connect success opts>>>>", JSON.stringify(y)), this.onConnect(), y.signRequest && y.signRequest.length > 0) {
                    let A = y.signRequest[0],
                      R = [];
                    typeof window != "undefined" && window && window.okxConnectUniversalUIinwindow ? ((0, s.logDebug)("OKXUniversalProvider connect success, us UI SDK>>>>"), this.session.signResponse && this.session.signResponse.length > 0 && (R = this.session.signResponse)) : ((0, s.logDebug)("OKXUniversalProvider connect success, us Universal SDK>>>>"), this.session.signResponse && this.session.signResponse.length > 0 ? R = this.session.signResponse : R.push((0, b.creatNotSupportMethodItemReplay)(A))), (0, s.logDebug)(`UniversalProvider connect success connectRequestReply ====> ${JSON.stringify(R)}`), setTimeout(() => {
                      this.events.emit("connect_signResponse", R);
                    }, 100);
                  }
                  return w;
                }
                return;
              } catch (w) {
                throw (0, s.logDebug)("UniversalProvider connect error ====> ", JSON.stringify(w)), w;
              }
            });
          }
          syncAllAddresses() {
            return n(this, void 0, void 0, function* () {
              if ((0, m.syncAddressAvailable)(this.session.wallet)) return this.client.syncAllAddress();
              throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.METHOD_NOT_SUPPORTED);
            });
          }
          setConnectConnector() {
            var y;
            this.client.setConnectConnector((y = this.session) === null || y === void 0 ? void 0 : y.wallet);
          }
          on(y, w) {
            this.events.on(y, w);
          }
          once(y, w) {
            this.events.once(y, w);
          }
          removeListener(y, w) {
            this.events.removeListener(y, w);
          }
          off(y, w) {
            this.events.off(y, w);
          }
          setDefaultChain(y, w) {
            (0, s.logDebug)("OKXUniversalProvider setDefaultChain() called");
            try {
              if (!this.connected()) return;
              const [A, R] = this.validateChain(y);
              this.getProvider(A).setDefaultChain(R, w);
            } catch (A) {
              if (!/Please call connect/.test(A.message)) throw A;
            }
          }
          tryToReconnect() {
            return n(this, void 0, void 0, function* () {
              yield this.checkStorage();
            });
          }
          checkStorage() {
            return n(this, void 0, void 0, function* () {
              if (this.connected()) return;
              let y = yield this.getFromStore("connectSession");
              if ((0, s.logDebug)(y), y) {
                (0, s.logDebug)("checkStorage error start");
                try {
                  let w = y;
                  if (this.session = w, this.client.session = this.session, this.setConnectConnector(), yield this.client.restoreconnect(w), !this.connected()) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR);
                  this.sessionConfig = w.sessionConfig, this.client.sessionConfig = this.sessionConfig, (0, s.logDebug)("[evm u-provider] do reconnection", this.session), this.createProviders(), this.registerEventListeners(), setTimeout(() => {
                    this.events.emit("reconnect", {
                      session: this.session
                    });
                  }, 100);
                } catch (w) {
                  yield this.cleanup(!1), (0, s.logDebug)(`checkStorage error ${JSON.stringify(w)}`);
                }
              }
            });
          }
          initialize() {
            return n(this, void 0, void 0, function* () {
              (0, s.logDebug)("OKXUniversalProvider initialize() called"), (0, s.reportLog)("provider initialize called");
              const y = Object.assign({
                url: window.location.hostname,
                origin: window.location.origin
              }, this.providerOpts.dappMetaData);
              this.client = new l.SignClient(y, this.events, this.providerOpts.openAppLinkType), this.registerConnector(this.providerOpts.connector), yield this.tryToReconnect();
            });
          }
          createProviders() {
            if (!this.client) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client not initialized");
            if (!this.connected()) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Session not initialized. Please call connect() before enable()");
            const y = [...new Set(Object.keys(this.session.namespaces).filter(w => {
              var A, R;
              return ((R = (A = this.session.namespaces[w]) === null || A === void 0 ? void 0 : A.accounts) === null || R === void 0 ? void 0 : R.length) > 0;
            }).map(w => (0, o.parseNamespaceKey)(w)))];
            this.rpcProviders = {}, y.forEach(w => {
              if (!this.session) return;
              const R = this.session.namespaces[w];
              switch ((0, s.logDebug)("init eip155 >> ", R), w) {
                case "eip155":
                  const T = {
                    namespace: R
                  };
                  this.rpcProviders[w] = new t.Eip155Provider(T, this.client, this.events);
                  break;
                case "solana":
                  const D = {
                    namespace: R
                  };
                  let M = new c.default(D, "solana", this.client, this.events);
                  this.rpcProviders[w] = M;
                  let q = new c.default(D, "sonic", this.client, this.events);
                  this.rpcProviders.sonic = q;
                  let W = new c.default(D, "svm", this.client, this.events);
                  this.rpcProviders.svm = W;
                  let x = new c.default(D, "soon", this.client, this.events);
                  this.rpcProviders.soon = x;
                  let C = new c.default(D, "eclipse", this.client, this.events);
                  this.rpcProviders.eclipse = C;
                  break;
                case "ton":
                  const B = {
                    namespace: R
                  };
                  let X = new d.default(B, this.client, this.events);
                  this.rpcProviders[w] = X;
                  break;
                case "sui":
                  const J = {
                    namespace: R
                  };
                  let V = new r.SuiProvider(J, this.client, this.events);
                  V.name = "sui", this.rpcProviders[w] = V;
                  break;
                case "btc":
                  const $ = {
                    namespace: R
                  };
                  let se = new u.default($, "btc", this.client, this.events);
                  this.rpcProviders.btc = se;
                  let ne = new u.default($, "fractal", this.client, this.events);
                  this.rpcProviders.fractal = ne;
                  break;
                case "aptos":
                  let oe = new f.default({
                    namespace: R
                  }, "aptos", this.client, this.events);
                  this.rpcProviders[w] = oe;
                  let ye = new f.default({
                    namespace: R
                  }, "movement", this.client, this.events);
                  this.rpcProviders.movement = ye;
                  break;
                case "cosmos":
                  let Te = new p.default({
                    namespace: R
                  }, this.client, this.events);
                  this.rpcProviders[w] = Te;
                  break;
                case "tron":
                  let ae = new v.default({
                    namespace: R
                  }, this.client, this.events);
                  this.rpcProviders[w] = ae;
                  break;
                case "starknet":
                  let G = new _.default({
                    namespace: R
                  }, "starknet", this.client, this.events);
                  this.rpcProviders[w] = G;
                  break;
              }
            });
          }
          registerEventListeners() {
            if (typeof this.client == "undefined") throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "Sign Client is not initialized");
            this.client.engine.addDisconnectListener(() => {
              this.disconnectAndEmit(), this.cleanup();
            }), this.on(i.PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, y => {
              this.onChainChanged(y);
            }), this.on(i.PROVIDER_EVENTS.UPDATE_NAMESPACES, y => {
              if (y) {
                const w = Object.keys(y)[0];
                this.session && (this.session.namespaces[w] = y[w], this.session && (this.persist("connectSession", this.session), this.events.emit("session_update", this.session)), (0, s.logDebug)("PROVIDER_EVENTS.UPDATE_NAMESPACES this.session... ->>>", JSON.stringify(this.session)));
              }
            });
          }
          getProvider(y) {
            return (0, s.logDebug)("current get providers", this.rpcProviders), (0, s.logDebug)("query namespace: ", y), this.rpcProviders[y];
          }
          setNamespaces(y) {
            this.connectOpts = y;
            const {
                namespaces: w,
                sessionConfig: A
              } = y,
              R = {
                origin: window.location.origin,
                url: window.location.hostname,
                name: this.providerOpts.dappMetaData.name,
                icon: this.providerOpts.dappMetaData.icon,
                manifestUrl: this.providerOpts.dappMetaData.manifestUrl
              };
            this.sessionConfig = Object.assign({
              dappInfo: R
            }, A), (0, s.logDebug)("setNamespaces sessionConfig>>>", this.sessionConfig), this.client.sessionConfig = this.sessionConfig, this.persist("sessionConfig", A);
          }
          validateChain(y) {
            var w;
            let [A, R] = (y == null ? void 0 : y.split(":")) || ["", ""];
            if (!this.session || !this.session.namespaces || !Object.keys(this.session.namespaces).length) return (0, s.logDebug)("get name & chain", A, R), [A, R];
            if (A) {
              if (!this.isChainNamespaceInSession(A)) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Namespace '${A}' is not configured. Please call connect() first with namespace config.`);
              if (R && y) {
                (0, s.logDebug)("this.session.namespaces -->> ", A, JSON.stringify(this.session.namespaces));
                const M = (w = this.session.namespaces[A]) === null || w === void 0 ? void 0 : w.chains;
                if ((0, s.logDebug)("get chainsArr & chain", JSON.stringify(M), y), M && !M.includes(y)) throw new s.OKXConnectError(s.OKX_CONNECT_ERROR_CODES.NOT_CONNECTED_ERROR, `Namespace not include the chain '${y}'`);
              }
            }
            if (A && R) return (0, s.logDebug)("get name & chain", A, R), [A, R];
            let T = (0, o.parseNamespaceKey)(Object.keys(this.session.namespaces)[0]);
            const D = this.rpcProviders[T].getDefaultChain();
            return (0, s.logDebug)("get default chain:", D), [T, D];
          }
          isChainNamespaceInSession(y) {
            var w, A;
            if (Object.keys(((w = this.session) === null || w === void 0 ? void 0 : w.namespaces) || {}).map(T => (0, o.parseNamespaceKey)(T)).includes(y)) return !0;
            let R = !1;
            return Object.values(((A = this.session) === null || A === void 0 ? void 0 : A.namespaces) || {}).forEach(T => {
              T.chains.forEach(D => {
                D.split(":")[0] == y && (R = !0);
              });
            }), R;
          }
          requestAccountsWithNamespace(y) {
            return this.getProvider(y).requestAccounts();
          }
          requestDefaultChainWithNamespace(y) {
            return this.getProvider(y).getDefaultChain();
          }
          requestAccounts() {
            return n(this, void 0, void 0, function* () {
              const [y] = this.validateChain();
              return yield this.getProvider(y).requestAccounts();
            });
          }
          onChainChanged(y) {
            var w;
            if (!(!((w = this.session) === null || w === void 0) && w.namespaces)) return;
            const [A, R] = this.validateChain(y);
            R && (this.session.namespaces[A] && (this.session.namespaces[A].defaultChain = R, this.persist("connectSession", this.session)), this.events.emit("chainChanged", R));
          }
          onConnect() {
            this.createProviders(), this.session && (this.persist("connectSession", this.session), console.log("window.okxwallet save session:", Date.now())), this.events.emit("connect", {
              session: this.session
            }), this.registerEventListeners();
          }
          cleanup() {
            return n(this, arguments, void 0, function* (y = !0) {
              this.session = void 0, this.client.session = void 0, this.setConnectConnector(), this.sessionProperties = void 0, this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), y && this.persist("connectSession", void 0);
            });
          }
          persist(y, w) {
            return (0, s.logDebug)("[evm u-provider] persisit data", y, w), this.client.engine.saveSessionContent(y, w);
          }
          getFromStore(y) {
            return n(this, void 0, void 0, function* () {
              return this.client.engine.getSessionContent(y);
            });
          }
          showRequestModal(y, w) {
            try {
              const {
                namespace: A,
                requestParam: R
              } = this.buildRequestParamFromRequest(y, w);
              return this.getProvider(A).showRequestModal(R);
            } catch {
              return !1;
            }
          }
          openWallet(y, w) {
            this.client.openWallet(y, w);
          }
          registerConnector(y) {
            this.client.registerConnector(y), this.client.setAccountChangeListener(w => {
              (0, s.logDebug)("accountChangeListener session：", this.events.listenerCount("accountChanged"), JSON.stringify(w));
              try {
                w && this.events.listenerCount("accountChanged") && (this.replaceSessionAptos(w, "aptos"), this.replaceSessionAptos(w, "solana"), this.session = w, this.client.session = w, this.session && (this.persist("connectSession", this.session), console.log("window.okxwallet save session:", Date.now())), this.setConnectConnector(), this.createProviders(), this.events.emit("accountChanged", this.session));
              } catch (A) {
                (0, s.logDebug)("setAccountChangeListener error:", JSON.stringify(A));
              }
            });
          }
          getEngine() {
            return this.client.engine;
          }
        };
        return Xr.OKXUniversalProvider = N, Xr.default = N, Xr;
      }
      var Yi = {},
        Ub;
      function D2() {
        if (Ub) return Yi;
        Ub = 1;
        var n = Yi && Yi.__awaiter || function (i, a, l, s) {
          function o(c) {
            return c instanceof l ? c : new l(function (u) {
              u(c);
            });
          }
          return new (l || (l = Promise))(function (c, u) {
            function f(v) {
              try {
                p(s.next(v));
              } catch (h) {
                u(h);
              }
            }
            function d(v) {
              try {
                p(s.throw(v));
              } catch (h) {
                u(h);
              }
            }
            function p(v) {
              v.done ? c(v.value) : o(v.value).then(f, d);
            }
            p((s = s.apply(i, a || [])).next());
          });
        };
        Object.defineProperty(Yi, "__esModule", {
          value: !0
        }), Yi.OKXBtcProvider = void 0;
        const e = Hd(),
          t = zt();
        let r = class {
          constructor(a) {
            this.caip = ["btc:mainnet", "fractal:mainnet"], this.provider = a;
          }
          getAddressForChainId(a) {
            var l, s;
            if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
            let c = (s = (l = this.provider.session) === null || l === void 0 ? void 0 : l.namespaces.btc) === null || s === void 0 ? void 0 : s.accounts.filter(function (d) {
              return d.startsWith(a);
            });
            if (c == null || c.length < 0) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "no connected account");
            return c[0].split(":")[2];
          }
          getAccount(a) {
            var l, s, o;
            if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
            let u = (o = (s = (l = this.provider.session) === null || l === void 0 ? void 0 : l.namespaces.btc) === null || s === void 0 ? void 0 : s.extra) === null || o === void 0 ? void 0 : o[a],
              f = "";
            return u != null && (f = u.compressedPublicKey), {
              address: this.getAddressForChainId(a),
              publicKey: f
            };
          }
          signMessage(a, l, s) {
            return n(this, void 0, void 0, function* () {
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              if (l === "undefined") throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method signMessage parmas error");
              let c = {
                signStr: l,
                from: this.getAddressForChainId(a)
              };
              s && (c.type = s);
              try {
                const u = yield this.provider.request({
                  method: "btc_signMessage",
                  params: c
                }, a);
                return "result" in u ? u.result : u.error;
              } catch (u) {
                throw u instanceof e.OKXConnectError ? u : new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method signTransaction request error");
              }
            });
          }
          sendBitcoin(a, l, s, o) {
            return n(this, void 0, void 0, function* () {
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              let u = {
                from: this.getAddressForChainId(a),
                to: l,
                value: (s / 1e8).toString()
              };
              o != null && o.feeRate && (u.satBytes = o.feeRate.toString());
              let f = yield this.send(a, u);
              return f !== void 0 && "txhash" in f ? f.txhash : f;
            });
          }
          send(a, l) {
            return n(this, void 0, void 0, function* () {
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              if (!this.checkParameters(l, "to", "value")) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method send parmas  error");
              l.from = this.getAddressForChainId(a);
              try {
                const o = yield this.provider.request({
                  method: "btc_send",
                  params: l
                }, a);
                return "result" in o ? {
                  txhash: o.result
                } : o.error;
              } catch (o) {
                throw o instanceof e.OKXConnectError ? o : new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${o}`);
              }
            });
          }
          signPsbt(a, l, s) {
            return n(this, void 0, void 0, function* () {
              return new Promise((o, c) => {
                this.signPsbts(a, [l], [s]).then(u => {
                  let f = JSON.parse(u);
                  o(f[0]);
                }).catch(u => {
                  c(u);
                });
              });
            });
          }
          signPsbts(a, l, s) {
            return n(this, void 0, void 0, function* () {
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              if (l === void 0) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method signPsbts params error");
              let c = {
                psbtHexs: l,
                options: s
              };
              c.from = this.getAddressForChainId(a);
              try {
                const u = yield this.provider.request({
                  method: "btc_signPsbts",
                  params: c
                }, a);
                if ("result" in u) return u.result;
              } catch (u) {
                throw u instanceof e.OKXConnectError ? u : new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${u}`);
              }
            });
          }
          signAndPushPsbt(a, l, s) {
            return n(this, void 0, void 0, function* () {
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              if (l === void 0) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method signPsbts params error");
              let c = {
                psbtHex: l,
                options: s
              };
              c.from = this.getAddressForChainId(a);
              try {
                const u = yield this.provider.request({
                  method: "btc_signAndPushPsbt",
                  params: c
                }, a);
                return "result" in u ? JSON.parse(u.result) : u.error;
              } catch (u) {
                throw u instanceof e.OKXConnectError ? u : new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, `the method send request error: ${u}`);
              }
            });
          }
          sendInscription(a, l, s, o) {
            return n(this, void 0, void 0, function* () {
              let c = {
                address: l,
                inscriptionId: s,
                options: o
              };
              if (this.checkChainId(a) == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
              if (l === "undefined") throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method sendInscription params error");
              var f = 0;
              o && "feeRate" in o && (f = o.feeRate);
              let d = "",
                p = this.getAddressForChainId(a);
              var v = 7;
              if (s !== "undefined") {
                let g = "-Atomicals",
                  b = "-Ordinals";
                s != null && s.toLowerCase().endsWith(g.toLowerCase()) ? (v = 8, s = this.removeSuffix(s, g)) : s != null && s.toLowerCase().endsWith(b.toLowerCase()) && (s = this.removeSuffix(s, b));
              }
              let h = {
                scenario: 5,
                feeRate: f,
                txType: "20",
                to: l,
                batchBean: [{
                  coinAmount: "1",
                  nftId: s,
                  protocolId: v,
                  coinId: d,
                  inscriptionId: "",
                  from: p
                }],
                extension: c
              };
              try {
                const g = yield this.provider.request({
                  method: "btc_sendInscription",
                  params: h,
                  injectParams: {
                    address: l,
                    inscriptionId: s,
                    options: o
                  }
                }, a);
                return "result" in g ? g.result : g.error;
              } catch (g) {
                throw g instanceof e.OKXConnectError ? g : new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "the method signTransaction request error");
              }
            });
          }
          sendRunes(a, l, s, o, c) {
            return n(this, void 0, void 0, function* () {
              try {
                if (!a || !l || !s || !o) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "The parameter is empty. Please check");
                let u = this.checkChainId(a),
                  f;
                if (u != null && (u.startsWith("btc") ? f = 13 : u.startsWith("fractal") && (f = 16)), u == null || f == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
                let p = {
                  fromAddress: this.getAddressForChainId(a),
                  protocolId: f,
                  address: l,
                  runeid: s,
                  amount: o,
                  options: c
                };
                return (0, t.logDebug)("OKXBtcProvider sendRunes -->", JSON.stringify(p)), (yield this.provider.request({
                  method: "btc_sendRunes",
                  params: p,
                  injectParams: {
                    address: l,
                    runeid: s,
                    amount: o,
                    options: c
                  }
                }, a)).result;
              } catch (u) {
                throw u;
              }
            });
          }
          inscribeTransfer(a, l, s) {
            return n(this, void 0, void 0, function* () {
              try {
                if (!a || !l || !s) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "The parameter is empty. Please check");
                let o = this.checkChainId(a),
                  c;
                if (o != null && (o.startsWith("btc") ? c = 1 : o.startsWith("fractal") && (c = 14)), o == null || c == null) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "invalid chainId");
                let f = {
                  fromAddress: this.getAddressForChainId(a),
                  protocolId: c,
                  ticker: l,
                  amount: s
                };
                (0, t.logDebug)("OKXBtcProvider inscribeTransfer -->", JSON.stringify(f));
                const d = yield this.provider.request({
                  method: "btc_inscribeTransfer",
                  params: f
                }, a);
              } catch (o) {
                throw o;
              }
            });
          }
          removeSuffix(a, l) {
            return a.endsWith(l) ? a.slice(0, a.length - l.length) : a;
          }
          checkParameters(a, ...l) {
            var s = [];
            return l.forEach(o => {
              `${o}` in a || s.push(o);
            }), s.length > 0 ? (console.log("not find key: ", s.join(",")), !1) : !0;
          }
          checkChainId(a) {
            if (this.caip.includes(a)) {
              let [l, s] = a.split(":");
              return l;
            }
          }
        };
        return Yi.OKXBtcProvider = r, Yi.default = r, Yi;
      }
      var Ps = {},
        Fb;
      function P2() {
        if (Fb) return Ps;
        Fb = 1;
        var n = Ps && Ps.__awaiter || function (r, i, a, l) {
          function s(o) {
            return o instanceof a ? o : new a(function (c) {
              c(o);
            });
          }
          return new (a || (a = Promise))(function (o, c) {
            function u(p) {
              try {
                d(l.next(p));
              } catch (v) {
                c(v);
              }
            }
            function f(p) {
              try {
                d(l.throw(p));
              } catch (v) {
                c(v);
              }
            }
            function d(p) {
              p.done ? o(p.value) : s(p.value).then(u, f);
            }
            d((l = l.apply(r, i || [])).next());
          });
        };
        Object.defineProperty(Ps, "__esModule", {
          value: !0
        }), Ps.OKXCosmosProvider = void 0;
        const e = zt();
        let t = class {
          constructor(i) {
            this.provider = i;
          }
          getAccount(i) {
            var a, l, s, o, c, u;
            (0, e.logDebug)("OKXCosmosProvider getAccount chainId:", i), (0, e.logDebug)("OKXCosmosProvider getAccount namespaces:", JSON.stringify((a = this.provider.session) === null || a === void 0 ? void 0 : a.namespaces));
            let f = (s = (l = this.provider.session) === null || l === void 0 ? void 0 : l.namespaces[e.NameSpaceKeyCosmos]) === null || s === void 0 ? void 0 : s.accounts.filter(function (g) {
              return g.startsWith(i);
            })[0];
            if ((0, e.logDebug)("OKXCosmosProvider getAccount account:", JSON.stringify(f)), !f) return;
            const d = f.split(":"),
              p = f.split(":")[2];
            (0, e.logDebug)("OKXCosmosProvider getAccount address:", p);
            let v = (u = (c = (o = this.provider.session) === null || o === void 0 ? void 0 : o.namespaces[e.NameSpaceKeyCosmos]) === null || c === void 0 ? void 0 : c.extra) === null || u === void 0 ? void 0 : u[`${d[0]}:${d[1]}`],
              h = "";
            if (v != null && (h = v.publicKey, console.log("aptos_publicKey", h)), !!p) return {
              algo: "secp256k1",
              address: p,
              bech32Address: p,
              pubKey: this.hexToUint8Array(h)
            };
          }
          signArbitrary(i, a, l) {
            return n(this, void 0, void 0, function* () {
              const s = window.btoa(l),
                o = {
                  chain_id: "",
                  account_number: "0",
                  sequence: "0",
                  fee: {
                    gas: "0",
                    amount: []
                  },
                  msgs: [{
                    type: "sign/MsgSignData",
                    value: {
                      signer: a,
                      data: s
                    }
                  }],
                  memo: ""
                };
              let c = {
                chainId: i,
                method: "cosmos_signArbitrary",
                params: {
                  signer: a,
                  chain_id: i.split(":")[1],
                  data: o
                }
              };
              try {
                const u = yield this.provider.request(c, i);
                return "result" in u ? typeof u.result == "string" ? JSON.parse(u.result) : u.result : u.error;
              } catch (u) {
                return u;
              }
            });
          }
          signAmino(i, a, l, s) {
            return n(this, void 0, void 0, function* () {
              if (l.msgs[0].type == "sign/MsgSignData") {
                let o = {
                  chainId: i,
                  method: "cosmos_signArbitrary",
                  params: {
                    signer: a,
                    chain_id: i.split(":")[1],
                    data: l
                  }
                };
                try {
                  const c = yield this.provider.request(o, i);
                  return "result" in c ? c.result : c.error;
                } catch (c) {
                  return c;
                }
              } else {
                let o = {
                  chainId: i,
                  method: "cosmos_signAmino",
                  params: {
                    signer: a,
                    chainId: i.split(":")[1],
                    sign_doc: l,
                    signOptions: s
                  }
                };
                try {
                  const c = yield this.provider.request(o, i);
                  if ("result" in c) {
                    const u = JSON.parse(c.result);
                    return console.log("signdoc", l, u.signDoc), l.fee = u.signDoc.fee, {
                      signed: l,
                      signature: u.signature
                    };
                  } else return c.error;
                } catch (c) {
                  return c;
                }
              }
            });
          }
          signDirect(i, a, l, s) {
            return n(this, void 0, void 0, function* () {
              const o = {
                bodyBytes: this.bufferToHex(l.bodyBytes),
                authInfoBytes: this.bufferToHex(l.authInfoBytes),
                chainId: l.chainId,
                accountNumber: l.accountNumber ? l.accountNumber.toString() : null,
                signOptions: s || null
              };
              let c = {
                chainId: i,
                method: "cosmos_signDirect",
                params: {
                  signer: a,
                  chainId: i.split(":")[1],
                  sign_doc: o
                }
              };
              try {
                const u = yield this.provider.request(c, i);
                if ("result" in u) {
                  const f = JSON.parse(u.result);
                  return console.log("signdirect result", f), l.authInfoBytes = this.messageToBuffer(f.signDoc.authInfoBytes), {
                    signed: l,
                    signature: f.signature
                  };
                }
              } catch (u) {
                return u;
              }
            });
          }
          messageToBuffer(i) {
            var a = Uint8Array.from([]);
            try {
              typeof i == "string" ? a = this.hexToUint8Array(i.replace("0x", "")) : a = Uint8Array.from(i);
            } catch (l) {
              console.log(`messageToBuffer error: ${l}`);
            }
            return a;
          }
          bufferToHex(i) {
            return "0x" + [...new Uint8Array(i)].map(l => l.toString(16).padStart(2, "0")).join("");
          }
          hexToUint8Array(i) {
            if (i.length % 2 !== 0) throw "Invalid hexString";
            for (var a = new Uint8Array(i.length / 2), l = 0; l < i.length; l += 2) {
              var s = parseInt(i.substr(l, 2), 16);
              if (isNaN(s)) throw "Invalid hexString";
              a[l / 2] = s;
            }
            return a;
          }
        };
        return Ps.OKXCosmosProvider = t, Ps;
      }
      var Zi = {},
        Hb;
      function I2() {
        if (Hb) return Zi;
        Hb = 1;
        var n = Zi && Zi.__awaiter || function (i, a, l, s) {
          function o(c) {
            return c instanceof l ? c : new l(function (u) {
              u(c);
            });
          }
          return new (l || (l = Promise))(function (c, u) {
            function f(v) {
              try {
                p(s.next(v));
              } catch (h) {
                u(h);
              }
            }
            function d(v) {
              try {
                p(s.throw(v));
              } catch (h) {
                u(h);
              }
            }
            function p(v) {
              v.done ? c(v.value) : o(v.value).then(f, d);
            }
            p((s = s.apply(i, a || [])).next());
          });
        };
        Object.defineProperty(Zi, "__esModule", {
          value: !0
        }), Zi.OKXTonProvider = void 0;
        const e = Hd(),
          t = zt();
        let r = class {
          constructor(a) {
            this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.provider = a, this.provider.on("connect", () => {
              let l = this.wallet();
              (0, t.logDebug)("OKXTONProvider event connect:", JSON.stringify(l)), this.statusChangeSubscriptions.forEach(s => s(l));
            }), this.provider.on("reconnect", () => {
              let l = this.wallet();
              (0, t.logDebug)("OKXTONProvider event reconnect:", JSON.stringify(l)), this.statusChangeSubscriptions.forEach(s => s(l));
            }), this.provider.on("disconnect", () => {
              (0, t.logDebug)("OKXTONProvider event disconnect:"), this.statusChangeSubscriptions.forEach(l => l(null));
            }), this.provider.on("connect_error", l => {
              (0, t.logDebug)("OKXTONProvider event connect_error:", JSON.stringify(l)), this.statusChangeErrorSubscriptions.forEach(s => s(l));
            });
          }
          connected() {
            return this.provider.connected() ? !!this.provider.session.namespaces.ton : !1;
          }
          account() {
            try {
              if (!this.provider.session) return null;
              let a = this.provider.session.namespaces.ton;
              if (!a || !a.payload || !a.payload.ton_addr) return null;
              let l = a.payload.ton_addr;
              return {
                address: l.address,
                chain: l.network,
                walletStateInit: l.walletStateInit,
                publicKey: l.publicKey
              };
            } catch (a) {
              return (0, t.logDebug)("OKXTONProvider account  error:", JSON.stringify(a)), null;
            }
          }
          wallet() {
            if (this.connected()) try {
              let a = this.provider.session.wallet;
              const s = {
                device: {
                  platform: a.platform,
                  appName: a.appName,
                  appVersion: a.appVersion,
                  maxProtocolVersion: a.maxProtocolVersion,
                  features: ["ton_sendTransaction"]
                },
                provider: "http",
                account: this.account()
              };
              let o = this.provider.session.namespaces.ton;
              return o && o.payload && o.payload.ton_proof && (s.connectItems = {
                tonProof: o.payload.ton_proof
              }), (0, t.logDebug)("OKXTONProvider wallet :", JSON.stringify(s)), s;
            } catch (a) {
              return (0, t.logDebug)("OKXTONProvider wallet  error:", JSON.stringify(a)), null;
            }
            return null;
          }
          onStatusChange(a, l) {
            return this.statusChangeSubscriptions.push(a), l && this.statusChangeErrorSubscriptions.push(l), () => {
              this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(s => s !== a), l && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(s => s !== l));
            };
          }
          sendTransaction(a) {
            return n(this, void 0, void 0, function* () {
              if (a.network && a.network !== t.TONCHAIN.MAINNET) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.UNKNOWN_ERROR, "OKXTONProvider sendTransaction network error");
              if (a.network || (a.network = t.TONCHAIN.MAINNET), this.provider.session && !a.from) {
                const o = this.provider.requestAccountsWithNamespace("ton");
                a.from = o[0];
              }
              const l = {
                method: "ton_sendTransaction",
                params: a
              };
              let s = "ton:" + t.TONCHAIN.MAINNET;
              return (0, t.logDebug)("OKXTONProvider sendTransaction transaction----:", s, JSON.stringify(l)), this.provider.request(l, s);
            });
          }
        };
        return Zi.OKXTonProvider = r, Zi.default = r, Zi;
      }
      var Is = {},
        jb;
      function B2() {
        if (jb) return Is;
        jb = 1;
        var n = Is && Is.__awaiter || function (r, i, a, l) {
          function s(o) {
            return o instanceof a ? o : new a(function (c) {
              c(o);
            });
          }
          return new (a || (a = Promise))(function (o, c) {
            function u(p) {
              try {
                d(l.next(p));
              } catch (v) {
                c(v);
              }
            }
            function f(p) {
              try {
                d(l.throw(p));
              } catch (v) {
                c(v);
              }
            }
            function d(p) {
              p.done ? o(p.value) : s(p.value).then(u, f);
            }
            d((l = l.apply(r, i || [])).next());
          });
        };
        Object.defineProperty(Is, "__esModule", {
          value: !0
        }), Is.OKXTronProvider = void 0;
        const e = zt();
        let t = class {
          constructor(i) {
            this.TRON_CHAIN_ID = "tron:mainnet", this.provider = i;
          }
          getChain(i) {
            if (i == null && (i = this.TRON_CHAIN_ID), i != this.TRON_CHAIN_ID) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED, "The chainId:" + i + "is wrong for OKXTronProvider");
            return i;
          }
          getAccount(i) {
            var a, l, s, o, c;
            i = this.getChain(i);
            let u = (l = (a = this.provider.session) === null || a === void 0 ? void 0 : a.namespaces[e.NameSpaceKeyTron]) === null || l === void 0 ? void 0 : l.accounts.filter(function (v) {
              return v.startsWith(i);
            })[0];
            if (!u) return;
            const f = u.split(":"),
              d = u.split(":")[2];
            let p = (c = (o = (s = this.provider.session) === null || s === void 0 ? void 0 : s.namespaces[e.NameSpaceKeyTron]) === null || o === void 0 ? void 0 : o.extra) === null || c === void 0 ? void 0 : c[`${f[0]}:${f[1]}`];
            if (p != null && p.publicKey, !!d) return {
              address: d
            };
          }
          stringToHex(i) {
            let a = "";
            for (let l = 0; l < i.length; l++) a += i.charCodeAt(l).toString(16).padStart(2, "0");
            return a;
          }
          signMessage(i, a) {
            return n(this, void 0, void 0, function* () {
              a = this.getChain(a);
              let l = {
                chainId: a,
                method: "tron_signMessage",
                params: {
                  message: this.stringToHex(i)
                }
              };
              try {
                const s = yield this.provider.request(l, a);
                return "result" in s ? s.result : s.error;
              } catch (s) {
                return s;
              }
            });
          }
          signMessageV2(i, a) {
            return n(this, void 0, void 0, function* () {
              a = this.getChain(a);
              let l = {
                chainId: a,
                method: "tron_signMessageV2",
                params: {
                  message: i
                }
              };
              try {
                const s = yield this.provider.request(l, a);
                return "result" in s ? s.result : s.error;
              } catch (s) {
                return s;
              }
            });
          }
          signTransaction(i, a) {
            return n(this, void 0, void 0, function* () {
              a = this.getChain(a);
              let l = {
                method: "tron_signTransaction",
                params: i
              };
              try {
                const s = yield this.provider.request(l, a);
                if ("result" in s) {
                  let o;
                  typeof s.result == "string" ? o = JSON.parse(s.result) : o = s.result;
                  let c = {};
                  c.visible = o.visible, c.txID = o.txID;
                  let u = {};
                  return u.contract = o.raw_data.contract, u.expiration = o.raw_data.expiration, u.ref_block_bytes = o.raw_data.ref_block_bytes, u.fee_limit = o.raw_data.fee_limit, u.ref_block_hash = o.raw_data.ref_block_hash, u.timestamp = o.raw_data.timestamp, c.raw_data = u, c.raw_data_hex = o.raw_data_hex, c.signature = o.signature, c;
                }
              } catch (s) {
                return s;
              }
            });
          }
          signAndSendTransaction(i, a) {
            return n(this, void 0, void 0, function* () {
              a = this.getChain(a);
              let l = {
                method: "tron_signAndSendTransaction",
                params: i
              };
              try {
                const s = yield this.provider.request(l, a);
                if ("result" in s) return s.result;
              } catch (s) {
                return s;
              }
            });
          }
        };
        return Is.OKXTronProvider = t, Is;
      }
      var Bs = {},
        Wb;
      function k2() {
        if (Wb) return Bs;
        Wb = 1;
        var n = Bs && Bs.__awaiter || function (r, i, a, l) {
          function s(o) {
            return o instanceof a ? o : new a(function (c) {
              c(o);
            });
          }
          return new (a || (a = Promise))(function (o, c) {
            function u(p) {
              try {
                d(l.next(p));
              } catch (v) {
                c(v);
              }
            }
            function f(p) {
              try {
                d(l.throw(p));
              } catch (v) {
                c(v);
              }
            }
            function d(p) {
              p.done ? o(p.value) : s(p.value).then(u, f);
            }
            d((l = l.apply(r, i || [])).next());
          });
        };
        Object.defineProperty(Bs, "__esModule", {
          value: !0
        }), Bs.OKXStarknetProvider = void 0;
        const e = zt();
        let t = class {
          constructor(i) {
            this.STARKNET_CHAIN_ID = "starknet:mainnet", this.provider = i;
          }
          getChain(i) {
            if (i == null && (i = this.STARKNET_CHAIN_ID), i != this.STARKNET_CHAIN_ID) throw new e.OKXConnectError(e.OKX_CONNECT_ERROR_CODES.CHAIN_NOT_SUPPORTED, "The chainId:" + i + "is wrong for OKXStarknetProvider");
            return i;
          }
          getAccount(i) {
            var a, l, s, o, c;
            let u = (l = (a = this.provider.session) === null || a === void 0 ? void 0 : a.namespaces[e.NameSpaceKeyStarknet]) === null || l === void 0 ? void 0 : l.accounts.filter(function (h) {
              return h.startsWith(i);
            })[0];
            if (!u) return;
            const f = u.split(":"),
              d = u.split(":")[2];
            let p = (c = (o = (s = this.provider.session) === null || s === void 0 ? void 0 : s.namespaces[e.NameSpaceKeyStarknet]) === null || o === void 0 ? void 0 : o.extra) === null || c === void 0 ? void 0 : c[`${f[0]}:${f[1]}`],
              v = "";
            if (p != null && (v = p.publicKey), !!d) return {
              address: d,
              pubKey: v
            };
          }
          signMessage(i, a, l) {
            return n(this, void 0, void 0, function* () {
              l = this.getChain(l), i.length == 0 && (i = this.getAccount(l).address);
              let s = {
                chainId: l,
                method: "starknet_signMessage",
                params: {
                  accountAddress: i,
                  typedData: a
                }
              };
              try {
                const o = yield this.provider.request(s, l);
                if ("result" in o) {
                  let c = o.result;
                  return typeof c == "string" && (c = JSON.parse(c)), [c.signedDataR, c.signedDataS];
                } else return o.error;
              } catch (o) {
                return o;
              }
            });
          }
          sendTransaction(i, a, l) {
            return n(this, void 0, void 0, function* () {
              l = this.getChain(l);
              let o = {
                method: "starknet_sendTransaction",
                params: {
                  data: JSON.stringify({
                    accountAddress: i,
                    executionRequest: a
                  }),
                  from: i
                }
              };
              try {
                const c = yield this.provider.request(o, l);
                return "result" in c ? {
                  transaction_hash: c.result
                } : c.error;
              } catch (c) {
                return c;
              }
            });
          }
          signMessageDeclareContractPayload(i, a) {
            return n(this, void 0, void 0, function* () {
              a = this.getChain(a);
              try {
                let l = {
                  method: "starknet_signMessage",
                  params: i
                };
                const s = yield this.provider.request(l, a);
                return "result" in s ? {
                  transaction_hash: s.result.txHash,
                  class_hash: s.result.classHash
                } : s.error;
              } catch (l) {
                return l;
              }
            });
          }
          sendMessageExecuteTransactionDetail(i, a, l, s, o) {
            return n(this, void 0, void 0, function* () {
              o = this.getChain(o);
              const u = {
                calls: Array.isArray(a) ? a : [a],
                abis: l,
                transactionsDetail: {
                  nonce: s == null ? void 0 : s.nonce,
                  maxFee: s == null ? void 0 : s.nonce,
                  version: s == null ? void 0 : s.version
                }
              };
              return this.sendTransaction(i, u, o);
            });
          }
        };
        return Bs.OKXStarknetProvider = t, Bs;
      }
      var Xb;
      function Hd() {
        return Xb || (Xb = 1, function (n) {
          var e = Lo && Lo.__createBinding || (Object.create ? function (c, u, f, d) {
              d === void 0 && (d = f);
              var p = Object.getOwnPropertyDescriptor(u, f);
              (!p || ("get" in p ? !u.__esModule : p.writable || p.configurable)) && (p = {
                enumerable: !0,
                get: function () {
                  return u[f];
                }
              }), Object.defineProperty(c, d, p);
            } : function (c, u, f, d) {
              d === void 0 && (d = f), c[d] = u[f];
            }),
            t = Lo && Lo.__exportStar || function (c, u) {
              for (var f in c) f !== "default" && !Object.prototype.hasOwnProperty.call(u, f) && e(u, c, f);
            };
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.OKXStarknetProvider = n.OKXTronProvider = n.OKXTonProvider = n.OKXCosmosProvider = n.OKXBtcProvider = n.OKXUniversalProvider = void 0, t(Y0(), n), t(Ud(), n);
          var r = T2();
          Object.defineProperty(n, "OKXUniversalProvider", {
            enumerable: !0,
            get: function () {
              return r.OKXUniversalProvider;
            }
          });
          var i = D2();
          Object.defineProperty(n, "OKXBtcProvider", {
            enumerable: !0,
            get: function () {
              return i.OKXBtcProvider;
            }
          });
          var a = P2();
          Object.defineProperty(n, "OKXCosmosProvider", {
            enumerable: !0,
            get: function () {
              return a.OKXCosmosProvider;
            }
          });
          var l = I2();
          Object.defineProperty(n, "OKXTonProvider", {
            enumerable: !0,
            get: function () {
              return l.OKXTonProvider;
            }
          });
          var s = B2();
          Object.defineProperty(n, "OKXTronProvider", {
            enumerable: !0,
            get: function () {
              return s.OKXTronProvider;
            }
          });
          var o = k2();
          Object.defineProperty(n, "OKXStarknetProvider", {
            enumerable: !0,
            get: function () {
              return o.OKXStarknetProvider;
            }
          }), t(zt(), n);
        }(Lo)), Lo;
      }
      var M2 = Hd();
      const Pf = class Pf extends z0 {
        constructor() {
          super(...arguments);
          ce(this, "okxUniversalProvider");
        }
        static get instance() {
          return this._instance || (this._instance = new Pf()), this._instance;
        }
        async init() {
          this.okxUniversalProvider = await M2.OKXUniversalProvider.init({
            dappMetaData: {
              name: "Coinop",
              icon: "https://cdn.sei.io/web/logotype.svg"
            }
          }), this.okxUniversalProvider.on("display_uri", t => {
            console.log("display_uri", t);
            const r = new CustomEvent("walletLibOkxUriEvent", {
              detail: {
                uri: t
              }
            });
            window.dispatchEvent(r);
          }), await this.connect();
        }
        async isConnected() {
          if (!this.okxUniversalProvider) return !1;
          let t = !1;
          try {
            t = this.okxUniversalProvider.connected(), console.log("isConnected suceess", t);
          } catch (r) {
            console.log("isConnected error", r);
          }
          return t;
        }
        async connect() {
          await this.okxUniversalProvider.connect({
            namespaces: {
              eip155: {
                chains: ["eip155:1329"],
                defaultChain: "1329",
                rpcMap: {
                  1329: "https://evm-rpc.sei-apis.com"
                }
              }
            }
          }), this._provider = new Vc(this.okxUniversalProvider), this._signer = await this._provider.getSigner();
        }
        async getAddress() {
          return await this._signer.getAddress();
        }
        async sign(t, r) {
          let i = {
            method: "personal_sign",
            params: ["Welcome to Coinop Game!", t]
          };
          try {
            var a = await this.okxUniversalProvider.request(i, "eip155:56");
            console.log("personalSignResult", a), r(t);
          } catch (l) {
            this.errorHandler(l);
          }
        }
        async transferToken(t, r, i) {
          let a = this.amountToWei(i);
          try {
            let l = await t.transfer(r, a);
            return await l.wait(), l;
          } catch (l) {
            return console.log("transferToken error", l), null;
          }
        }
      };
      ce(Pf, "_instance");
      let jd = Pf;
      const If = class If extends z0 {
        static get instance() {
          return this._instance || (this._instance = new If()), this._instance;
        }
        async init() {
          try {
            window.okxwallet !== "undefined" && window.okxwallet !== void 0 && (window.okxwallet.on("disconnect", this.disconnectHandler.bind(this)), window.okxwallet.on("accountsChanged", this.accountChangedHandler.bind(this)), window.okxwallet.on("chainChanged", this.chainChangedHandler.bind(this)));
          } catch (e) {
            console.log("error: ", e);
          }
        }
        async connect(e, t) {
          try {
            if (window.okxwallet !== "undefined" && window.okxwallet !== void 0) {
              let r = await window.okxwallet.request({
                method: "eth_accounts"
              });
              if (r.length > 0) this._address = r[0];else {
                let i = await window.okxwallet.request({
                  method: "eth_requestAccounts"
                });
                this._address = i[0];
              }
              this._address != "" ? (this._provider = new Vc(window.okxwallet), this._signer = await this._provider.getSigner(), (await this.getChainId()) == this.curChainId ? this.sign(this._address, e) : this.changeChain(() => {
                this.sign(this._address, e);
              })) : t && t();
            } else {
              console.log("okxwallet  not installed");
              return;
            }
          } catch {
            t && t();
          }
        }
        async getAddress() {
          return this._address;
        }
        async isConnected() {
          return (await window.okxwallet.request({
            method: "eth_accounts"
          })).length > 0;
        }
        async sign(e, t) {
          try {
            await window.okxwallet.request({
              method: "personal_sign",
              params: [e, "Welcome to Coinop Game!"]
            }), t(e);
          } catch (r) {
            this.errorHandler(r);
          }
        }
        async getChainId() {
          try {
            return (await this._provider.getNetwork()).chainId;
          } catch (e) {
            return console.error("error:", e), 0;
          }
        }
        async changeChain(e) {
          try {
            (await this.getChainId()) != this.curChainId && window.okxwallet.request({
              method: "wallet_switchEthereumChain",
              params: [{
                chainId: "0x" + Number(this.curChainId).toString(16)
              }]
            }).then(() => {
              console.log("成功");
            }).catch(async r => {
              console.error(`ERROR:${r.message}`), r.code === 4902 ? window.okxwallet.request({
                method: "wallet_addEthereumChain",
                params: [this.providerConfig[this.curChainId]]
              }).then(() => {}).catch(i => {
                this.errorHandler(i);
              }) : (console.log("error: 切链失败", r), this.errorHandler(""));
            });
          } catch (t) {
            console.log("error: 切链失败", t), this.errorHandler("");
          }
        }
        async transferToken(e, t, r, i) {
          let a = this.amountToWei(r);
          try {
            let l = await e.transfer(t, a);
            console.log("tx", l);
            const s = await l.wait();
            return console.log("receipt", s), l;
          } catch (l) {
            return console.log("transferToken error", l), i && i(l), null;
          }
        }
      };
      ce(If, "_instance");
      let Wd = If;
      const _f = {
          MetaMask: "MetaMask",
          OkxDapp: "OkxDapp",
          Okx: "Okx"
        },
        Bf = class Bf {
          constructor() {
            ce(this, "apiScript", _u.instance);
            ce(this, "curProvider", _f.MetaMask);
          }
          static get instance() {
            return this._instance || (this._instance = new Bf()), this._instance;
          }
          async init(e) {
            e && (this.curProvider = e), await this.setProviderApi();
          }
          async setProviderApi() {
            switch (this.curProvider) {
              case _f.MetaMask:
                this.apiScript = _u.instance;
                break;
              case _f.OkxDapp:
                this.apiScript = jd.instance;
                break;
              case _f.Okx:
                this.apiScript = Wd.instance;
                break;
            }
            await this.apiScript.init();
          }
          async initCurChainId(e) {
            this.apiScript.initCurChainId(e);
          }
          async initConfig(e, t) {
            this.apiScript.initProviderConfig(e), this.apiScript.initTokenConfig(t);
          }
          async connect(e, t) {
            await this.apiScript.connect(e, t);
          }
          async isConnected() {
            return await this.apiScript.isConnected();
          }
          async getAddress() {
            return await this.apiScript.getAddress();
          }
          async sign(e) {
            let t = await this.getAddress();
            await this.apiScript.sign(t, e);
          }
          async getWalletConfig() {
            return this.apiScript.tokenConfig;
          }
          async getCurChainId() {
            return this.apiScript.curChainId;
          }
          async allowanceNum(e, t, r) {
            return await this.apiScript.allowanceNum(e, t, r);
          }
          async approveContract(e, t, r, i = !1) {
            await this.apiScript.approveContract(e, t, r, i);
          }
          async contractBalance(e, t, r = !1) {
            return await this.apiScript.contractBalance(e, t, r);
          }
          async transferToken(e, t, r) {
            return await this.apiScript.transferToken(e, t, r);
          }
          async setContractMap(e, t, r) {
            await this.apiScript.setContractMap(e, t, r);
          }
          async getContractMap(e) {
            return await this.apiScript.getContractMap(e);
          }
          async setContractReadMap(e, t, r) {
            await this.apiScript.setContractReadMap(e, t, r);
          }
          async getContractReadMap(e) {
            return await this.apiScript.getContractReadMap(e);
          }
        };
      ce(Bf, "_instance");
      let Ef = Bf;
      window.WalletManage = Ef, Tt.WalletManage = Ef, Object.defineProperty(Tt, Symbol.toStringTag, {
        value: "Module"
      });
    });
  }).call(root);
})( // The environment-specific global.
function () {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof self !== 'undefined') return self;
  if (typeof window !== 'undefined') return window;
  if (typeof global !== 'undefined') return global;
  if (typeof this !== 'undefined') return this;
  return {};
}.call(this));